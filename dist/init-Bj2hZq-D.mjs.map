{"version":3,"file":"init-Bj2hZq-D.mjs","names":["jobs: Array<Job>","__filename","__dirname","result: Array<UserPostProcessor>","processor: PostProcessor | undefined","preset: keyof typeof postProcessors | undefined","resolvePath","resolvePath","result: R | void | undefined","Mixed","ctx","ctx","ctx","Mixed","ctx","missing: Array<string>","impl: T | undefined","ctx","Mixed","ctx","index: number","reserved","Mixed","ctx","ctx","result!: AccessResult","node","accessChain: Array<TsDsl>","nodes: Array<TsDsl>","ctx","lines","ctx","ctx","Mixed","Mixed","ctx","ctx","ctx","ctx","missing: Array<string>","ctx","ctx","Mixed","ctx","missing: Array<string>","Mixed","ctx","missing: Array<string>","Mixed","ctx","Mixed","ctx","ctx","Mixed","ctx","entries: Record<string, string>","missing: Array<string>","ctx","Mixed","ctx","missing: Array<string>","ctx","ctx","Mixed","ctx","Mixed","ctx","ctx","Mixed","ctx","Mixed","ctx","f","Mixed","ctx","Mixed","ctx","Mixed","ctx","node","missing: Array<string>","Mixed","ctx","Mixed","ctx","Mixed","ctx","ctx","Mixed","ctx","Mixed","ctx","missing: Array<string>","ctx","Mixed","ctx","Mixed","ctx","Mixed","ctx","Mixed","ctx","ctx","lines","ctx","Mixed","ctx","result","missing: Array<string>","Mixed","ctx","fromValue","Mixed","ctx","Mixed","ctx","Mixed","ctx","normalized: Array<string | ts.Expression>","spans: Array<ts.TemplateSpan>","Mixed","ctx","missing: Array<string>","Mixed","ctx","ctx","lines","Mixed","ctx","missing: Array<string>","Mixed","ctx","Mixed","ctx","Mixed","ctx","missing: Array<string>","Mixed","ctx","missing: Array<string>","Mixed","ctx","missing: Array<string>","Mixed","ctx","flat: Array<ts.TypeNode>","Mixed","ctx","Mixed","ctx","missing: Array<string>","Mixed","ctx","missing: Array<string>","Mixed","ctx","Mixed","ctx","Mixed","ctx","missing: Array<string>","Mixed","ctx","missing: Array<string>","Mixed","ctx","missing: Array<string>","Mixed","ctx","missing: Array<string>","Mixed","ctx","flat: Array<ts.TypeNode>","Mixed","ctx","ctx","normalized: Array<string | ts.TypeNode>","spans: Array<ts.TemplateLiteralTypeSpan>","ctx","parentCount: number","lines: Array<string>","ctx","exprValue","typeValue","f","p","auth: Array<Auth>","nameToLocations: Record<string, Set<Location>>","signatureParameters: SignatureParameters","fields: Array<Field>","signatureParameter: SignatureParameter","result: OperationParameters","query: SymbolMeta","ref","responseTypeValue: ReturnType<typeof getResponseType> | undefined","statements: Array<ReturnType<typeof $.return | typeof $.const>>","args: Array<ReturnType<typeof $.expr>>","config: Array<ReturnType<typeof $.object>>","clientExpression: ReturnType<typeof $.attr | typeof $.binary>","f","source","attachComment","f","c","dependencies: Array<ReturnType<typeof $.class>>","node","p","ctx","t","nodes: Array<ReturnType<typeof $.var>>","nodes: Array<ReturnType<typeof $.class | typeof $.var>>","comments: Array<string>","f","ctx","node","nodes: Array<ReturnType<typeof $.var>>","nodes: Array<ReturnType<typeof $.class>>","handler: AngularCommonPlugin['Handler']","allDependencies: Array<ReturnType<typeof $.class | typeof $.var>>","allNodes: Array<ReturnType<typeof $.class | typeof $.var>>","defaultConfig: AngularCommonPlugin['Config']","defineConfig","defaultConfig","Api","defaultConfig: FakerJsFakerPlugin['Config']","Api","defineConfig","defaultConfig","renamed: Map<string, string> | undefined","isDevMode","dirPath","createClient: PluginHandler","defaultConfig: HeyApiClientAngularPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientAxiosPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientFetchPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientKyPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientNextPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientNuxtPlugin['Config']","defineConfig","defaultConfig","defaultConfig: HeyApiClientOfetchPlugin['Config']","defineConfig","defaultConfig","handler: HeyApiSchemasPlugin['Handler']","defaultConfig: HeyApiSchemasPlugin['Config']","defineConfig","defaultConfig","methods: OperationsConfig['methods']","strategy: OperationsConfig['strategy'] | undefined","containerName: OperationsConfig['containerName'] | undefined","segmentName: OperationsConfig['segmentName'] | undefined","methods: OperationsConfig['methods'] | undefined","nesting: OperationsConfig['nesting'] | undefined","methodName: OperationsConfig['methodName'] | undefined","handlerV1: HeyApiSdkPlugin['Handler']","allDependencies: Array<ReturnType<typeof $.class | typeof $.var>>","allNodes: Array<ReturnType<typeof $.class | typeof $.var>>","handler: HeyApiSdkPlugin['Handler']","handlerV1","defaultConfig: HeyApiSdkPlugin['Config']","defineConfig","defaultConfig","bigIntExpressions: ExpressionTransformer","dateExpressions: ExpressionTransformer","query: SymbolMeta","mapCallbackStatements: Array<Expr>","nodes: Array<Expr>","arrayNodes: Array<Expr>","handler: HeyApiTransformersPlugin['Handler']","defaultConfig: HeyApiTransformersPlugin['Config']","defineConfig","defaultConfig","types: Array<TypeTsDsl>","comments: Array<string>","keyCounts: Record<string, number>","typeofItems: Array<\n    'bigint' | 'boolean' | 'function' | 'number' | 'object' | 'string' | 'symbol' | 'undefined'\n  >","key: string | undefined","symbol","node","type","irSchema: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","operationToDataType","data: IR.SchemaObject","dataRequired: Array<string>","irSchemaToAst","node","data: IR.SchemaObject","dataRequired: Array<string>","node","irSchemaToAst","arrayToAst","itemTypes: Array<MaybeTsDsl<TypeTsDsl>>","irSchemaToAst","booleanToAst","enumToAst","irSchemaToAst","neverToAst","nullToAst","objectToAst","indexSchemas: Array<IR.SchemaObject>","irSchemaToAst","p","stringToAst","query: SymbolMeta","queryTypeId: SymbolMeta","symbolTypeId","tupleToAst","itemTypes: Array<MaybeTsDsl<TypeTsDsl>>","irSchemaToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","neverToAst","nullToAst","objectToAst","stringToAst","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","irSchemaWithTypeToAst","handleComponent","handlerV1: HeyApiTypeScriptPlugin['Handler']","servers: Array<IR.ServerObject>","webhooks: Array<Symbol>","Api","irSchemaToAstV1","handler: HeyApiTypeScriptPlugin['Handler']","handlerV1","defaultConfig: HeyApiTypeScriptPlugin['Config']","Api","defineConfig","defaultConfig","handleMeta","useTypeData","useTypeError","useTypeResponse","useTypeData","createMutationOptions","fnOptions","ctx","statements: Array<ReturnType<typeof $.var | typeof $.return>>","f","handleMeta","useTypeResponse","useTypeError","TOptionsType","createQueryKeyFunction","createQueryKeyLiteral","tagsExpression: ReturnType<typeof $.array> | undefined","createQueryKeyType","queryKeyStatement","optionsParamName","createQueryOptions","keyExpression: ReturnType<typeof $.call>","queryKeyStatement","tagsExpr: ReturnType<typeof $.array> | undefined","ctx","statements: Array<ReturnType<typeof $.return | typeof $.const>>","handleMeta","handlerV0: PiniaColadaPlugin['Handler']","handler: PiniaColadaPlugin['Handler']","defaultConfig: PiniaColadaPlugin['Config']","handler","defineConfig","defaultConfig","tagsArray: TsDsl<ts.ArrayLiteralExpression> | undefined","f","ctx","statements: Array<TsDsl<any>>","fnOptions","ctx","statements: Array<TsDsl<any>>","optionsParamName","ctx","statements: Array<TsDsl<any>>","handlerV5: PluginHandler","handler: PluginHandler","defaultConfig: TanStackAngularQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackReactQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackSolidQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackSvelteQueryPlugin['Config']","handler","defineConfig","defaultConfig","defaultConfig: TanStackVueQueryPlugin['Config']","handler","defineConfig","defaultConfig","Api","identifiers","exportAst","identifiers","nullToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","objectToAst","result: Partial<Omit<Ast, 'typeName'>>","irSchemaToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","irSchemaWithTypeToAst","nullToAst","objectToAst","irSchemaToAst","ast: Partial<Ast>","query: SymbolMeta","ref","irSchemaWithTypeToAst","handleComponent","handlerV2: ArktypePlugin['Handler']","handler: ArktypePlugin['Handler']","handlerV2","defaultConfig: ArktypePlugin['Config']","Api","fields","defaultValue","defineConfig","defaultConfig","errorsTypeReference: ReturnType<typeof $.type> | undefined","responsesTypeReference: ReturnType<typeof $.type> | undefined","handler: FastifyPlugin['Handler']","defaultConfig: FastifyPlugin['Config']","defineConfig","defaultConfig","ctx","statements: Array<TsDsl<any>>","handlerV2: SwrPlugin['Handler']","handler: SwrPlugin['Handler']","defaultConfig: SwrPlugin['Config']","handler","defineConfig","defaultConfig","identifiers","pipesToNode: PipesToNode","pipes","identifiers","pushPipes: PushPipes","pipes: PipesUtils","validatorResolver","ctx","identifiers","ctx: ValidatorResolverContext","Api","shouldCoerceToBigInt: ShouldCoerceToBigInt","maybeBigInt: MaybeBigInt","exportAst","v","identifiers","irOperationToAst","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","path","irWebhookToAst","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","unknownToAst","identifiers","arrayToAst","result: Omit<Ast, 'typeName'>","identifiers","unknownToAst","irSchemaToAst","booleanToAst","pipes: Array<ReturnType<typeof $.call>>","identifiers","pipes","itemsNode","ctx","enumMembers: Array<ReturnType<typeof $.literal>>","baseNode","identifiers","nullableNode","enumResolver","enumToAst","unknownToAst","ctx: EnumResolverContext","neverToAst","identifiers","nullToAst","identifiers","integerRange: Record<string, [Range, Range]>","getIntegerLimit: GetIntegerLimit","baseNode","ctx","identifiers","pipes: Pipes","pipes","constNode","maxNode","minNode","numberResolver","numberToNode","ctx: NumberResolverContext","additionalPropertiesNode","ctx","irSchemaToAst","baseNode","identifiers","objectResolver","shapeNode","objectToAst","ctx: ObjectResolverContext","baseNode","ctx","identifiers","constNode","formatNode","lengthNode","maxLengthNode","minLengthNode","patternNode","stringResolver","stringToNode","ctx: StringResolverContext","tupleToAst","result: Partial<Omit<Ast, 'typeName'>>","identifiers","irSchemaToAst","unknownToAst","undefinedToAst","identifiers","voidToAst","identifiers","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToNode","neverToAst","nullToAst","objectToAst","stringToNode","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Ast","query: SymbolMeta","ref","identifiers","irSchemaWithTypeToAst","handleComponent","handlerV1: ValibotPlugin['Handler']","handler: ValibotPlugin['Handler']","defaultConfig: ValibotPlugin['Config']","Api","defineConfig","defaultConfig","validatorResolver","ctx","ctx: ValidatorResolverContext","validatorResolver","ctx","ctx: ValidatorResolverContext","ctx","ctx: ValidatorResolverContext","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","path","schemaData: IR.SchemaObject","properties: Record<string, IR.SchemaObject>","required: Array<string>","unknownToAst","result: Partial<Omit<Ast, 'typeName'>>","arrayToAst","result: Partial<Omit<Ast, 'typeName'>>","unknownToAst","irSchemaToAst","intersectionExpression: ReturnType<typeof $.expr | typeof $.call>","checks: Array<ReturnType<typeof $.call>>","booleanToAst","result: Partial<Omit<Ast, 'typeName'>>","chain: ReturnType<typeof $.call>","itemsNode","ctx","enumMembers: Array<ReturnType<typeof $.literal>>","literalMembers: Array<Chain>","baseNode","nullableNode","enumResolver","enumToAst","unknownToAst","ctx: EnumResolverContext","neverToAst","result: Partial<Omit<Ast, 'typeName'>>","nullToAst","result: Partial<Omit<Ast, 'typeName'>>","baseNode","ctx","constNode","maxNode","minNode","numberResolver","checks: Array<Chain>","numberToNode","ast: Partial<Omit<Ast, 'typeName'>>","ctx: NumberResolverContext","additionalPropertiesNode","ctx","irSchemaToAst","baseNode","objectResolver","shapeNode","objectToAst","ast: Partial<Omit<Ast, 'typeName'>>","ctx: ObjectResolverContext","baseNode","ctx","constNode","formatNode","lengthNode","maxLengthNode","minLengthNode","patternNode","stringResolver","checks: Array<Chain>","stringToNode","ctx: StringResolverContext","tupleToAst","result: Partial<Omit<Ast, 'typeName'>>","tupleElements","tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>>","irSchemaToAst","undefinedToAst","result: Partial<Omit<Ast, 'typeName'>>","voidToAst","result: Partial<Omit<Ast, 'typeName'>>","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToNode","neverToAst","nullToAst","objectToAst","stringToNode","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Partial<Ast>","query: SymbolMeta","irSchemaWithTypeToAst","schema","handleComponent","handlerMini: ZodPlugin['Handler']","unknownToAst","arrayToAst","arrayExpression: ReturnType<typeof $.call> | undefined","unknownToAst","irSchemaToAst","intersectionExpression: ReturnType<typeof $.call | typeof $.expr>","booleanToAst","chain: ReturnType<typeof $.call>","itemsNode","ctx","enumMembers: Array<ReturnType<typeof $.literal>>","literalMembers: Array<Chain>","baseNode","nullableNode","enumResolver","enumToAst","unknownToAst","ctx: EnumResolverContext","neverToAst","nullToAst","baseNode","ctx","constNode","maxNode","minNode","numberResolver","numberToNode","ast: Partial<Omit<Ast, 'typeName'>>","ctx: NumberResolverContext","additionalPropertiesNode","ctx","irSchemaToAst","baseNode","objectResolver","shapeNode","objectToAst","ast: Partial<Omit<Ast, 'typeName'>>","ctx: ObjectResolverContext","baseNode","ctx","constNode","formatNode","lengthNode","maxLengthNode","minLengthNode","patternNode","stringResolver","stringToNode","ctx: StringResolverContext","tupleToAst","tupleElements","tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>>","irSchemaToAst","undefinedToAst","voidToAst","irSchemaWithTypeToAst","arrayToAst","booleanToAst","enumToAst","numberToNode","neverToAst","nullToAst","objectToAst","stringToNode","tupleToAst","undefinedToAst","unknownToAst","voidToAst","irSchemaToAst","ast: Partial<Ast>","query: SymbolMeta","irSchemaWithTypeToAst","handleComponent","handlerV3: ZodPlugin['Handler']","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","intersectionExpression: ReturnType<typeof $.call | typeof $.expr>","result: Partial<Omit<Ast, 'typeName'>>","chain: ReturnType<typeof $.call>","ctx","enumMembers: Array<ReturnType<typeof $.literal>>","literalMembers: Array<Chain>","baseNode","ctx: EnumResolverContext","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","baseNode","ctx","constNode","minNode","maxNode","ast: Partial<Omit<Ast, 'typeName'>>","ctx: NumberResolverContext","ctx","baseNode","ast: Partial<Omit<Ast, 'typeName'>>","ctx: ObjectResolverContext","ctx","constNode","baseNode","formatNode","lengthNode","minLengthNode","maxLengthNode","patternNode","ctx: StringResolverContext","result: Partial<Omit<Ast, 'typeName'>>","tupleElements","tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>>","result: Partial<Omit<Ast, 'typeName'>>","result: Partial<Omit<Ast, 'typeName'>>","ast: Partial<Ast>","query: SymbolMeta","schema","handlerV4: ZodPlugin['Handler']","handler: ZodPlugin['Handler']","defaultConfig: ZodPlugin['Config']","fields","defaultValue","defaultPluginConfigs: {\n  [K in PluginNames]: Plugin.Config<PluginConfigMap[K]>;\n}","angularCommon","fakerJsFaker","heyApiClientAngular","heyApiClientAxios","heyApiClientFetch","heyApiClientKy","heyApiClientNext","heyApiClientNuxt","heyApiClientOfetch","heyApiSchemas","heyApiSdk","heyApiTransformers","heyApiTypeScript","piniaColada","tanStackAngularQuery","tanStackReactQuery","tanStackSolidQuery","tanStackSvelteQuery","tanStackVueQuery","plugins: Config['plugins']","context: PluginContext","userPlugin","defaultConfig","defaultPlugin","userPluginsConfig: Config['plugins']","definedPlugins: UserConfig['plugins']","plugins: Pick<Config, 'plugins' | 'pluginOrder'>","config: Config","errors: Array<ConfigError>","configs: Array<UserConfig>","dependencies: Record<string, string>","configFile: string | undefined"],"sources":["../src/config/expand.ts","../src/config/packages.ts","../src/config/output/postprocess.ts","../src/config/output/config.ts","../src/plugins/@angular/common/httpRequests/config.ts","../src/plugins/@angular/common/httpRequests/resolve.ts","../src/plugins/@angular/common/httpResources/config.ts","../src/plugins/@angular/common/httpResources/resolve.ts","../src/config/utils.ts","../src/plugins/@hey-api/client-core/utils.ts","../src/ts-dsl/base.ts","../src/ts-dsl/expr/id.ts","../src/ts-dsl/layout/newline.ts","../src/ts-dsl/mixins/args.ts","../src/ts-dsl/expr/prefix.ts","../src/ts-dsl/utils/factories.ts","../src/ts-dsl/mixins/as.ts","../src/ts-dsl/expr/literal.ts","../src/ts-dsl/utils/regexp.ts","../src/ts-dsl/utils/keywords.ts","../src/ts-dsl/utils/reserved.ts","../src/ts-dsl/utils/name.ts","../src/ts-dsl/decl/decorator.ts","../src/ts-dsl/mixins/decorator.ts","../src/ts-dsl/utils/context.ts","../src/ts-dsl/layout/doc.ts","../src/ts-dsl/mixins/doc.ts","../src/ts-dsl/mixins/modifiers.ts","../src/ts-dsl/type/param.ts","../src/ts-dsl/mixins/type-params.ts","../src/ts-dsl/mixins/optional.ts","../src/ts-dsl/mixins/value.ts","../src/ts-dsl/token.ts","../src/ts-dsl/mixins/type-args.ts","../src/ts-dsl/mixins/type-expr.ts","../src/ts-dsl/type/attr.ts","../src/ts-dsl/type/expr.ts","../src/ts-dsl/decl/field.ts","../src/ts-dsl/stmt/stmt.ts","../src/ts-dsl/mixins/do.ts","../src/ts-dsl/decl/pattern.ts","../src/ts-dsl/mixins/pattern.ts","../src/ts-dsl/decl/param.ts","../src/ts-dsl/mixins/param.ts","../src/ts-dsl/mixins/layout.ts","../src/ts-dsl/stmt/block.ts","../src/ts-dsl/decl/init.ts","../src/ts-dsl/mixins/type-returns.ts","../src/ts-dsl/decl/method.ts","../src/ts-dsl/decl/class.ts","../src/ts-dsl/decl/member.ts","../src/ts-dsl/decl/enum.ts","../src/ts-dsl/decl/func.ts","../src/ts-dsl/decl/getter.ts","../src/ts-dsl/decl/setter.ts","../src/ts-dsl/expr/array.ts","../src/ts-dsl/mixins/expr.ts","../src/ts-dsl/expr/as.ts","../src/ts-dsl/expr/binary.ts","../src/ts-dsl/mixins/operator.ts","../src/ts-dsl/expr/attr.ts","../src/ts-dsl/expr/await.ts","../src/ts-dsl/expr/call.ts","../src/ts-dsl/expr/expr.ts","../src/ts-dsl/layout/hint.ts","../src/ts-dsl/mixins/hint.ts","../src/ts-dsl/expr/prop.ts","../src/ts-dsl/expr/object.ts","../src/ts-dsl/expr/fromValue.ts","../src/ts-dsl/expr/new.ts","../src/ts-dsl/expr/regexp.ts","../src/ts-dsl/expr/template.ts","../src/ts-dsl/expr/ternary.ts","../src/ts-dsl/expr/typeof.ts","../src/ts-dsl/layout/note.ts","../src/ts-dsl/stmt/if.ts","../src/ts-dsl/stmt/return.ts","../src/ts-dsl/stmt/throw.ts","../src/ts-dsl/stmt/try.ts","../src/ts-dsl/stmt/var.ts","../src/ts-dsl/type/alias.ts","../src/ts-dsl/type/and.ts","../src/ts-dsl/type/literal.ts","../src/ts-dsl/type/idx-sig.ts","../src/ts-dsl/type/prop.ts","../src/ts-dsl/type/object.ts","../src/ts-dsl/type/tuple.ts","../src/ts-dsl/type/fromValue.ts","../src/ts-dsl/type/func.ts","../src/ts-dsl/type/idx.ts","../src/ts-dsl/type/mapped.ts","../src/ts-dsl/type/operator.ts","../src/ts-dsl/type/or.ts","../src/ts-dsl/type/query.ts","../src/ts-dsl/type/template.ts","../src/ts-dsl/utils/lazy.ts","../src/ts-dsl/utils/render-utils.ts","../src/ts-dsl/utils/render.ts","../src/ts-dsl/index.ts","../src/plugins/@hey-api/sdk/shared/class.ts","../src/plugins/@hey-api/sdk/shared/constants.ts","../src/plugins/@hey-api/sdk/shared/auth.ts","../src/plugins/@hey-api/sdk/shared/signature.ts","../src/plugins/@hey-api/sdk/shared/validator.ts","../src/plugins/@hey-api/sdk/shared/operation.ts","../src/plugins/@hey-api/sdk/v1/node.ts","../src/plugins/shared/utils/operation.ts","../src/plugins/@angular/common/shared/node.ts","../src/plugins/@angular/common/plugin.ts","../src/plugins/@angular/common/config.ts","../src/plugins/@faker-js/faker/api.ts","../src/plugins/@faker-js/faker/config.ts","../src/plugins/@hey-api/client-core/config.ts","../src/generate/client.ts","../src/plugins/@hey-api/client-core/client.ts","../src/plugins/@hey-api/client-core/createClientConfig.ts","../src/plugins/@hey-api/client-core/plugin.ts","../src/plugins/@hey-api/client-angular/config.ts","../src/plugins/@hey-api/client-axios/config.ts","../src/plugins/@hey-api/client-fetch/config.ts","../src/plugins/@hey-api/client-ky/config.ts","../src/plugins/@hey-api/client-next/config.ts","../src/plugins/@hey-api/client-nuxt/config.ts","../src/plugins/@hey-api/client-ofetch/config.ts","../src/plugins/@hey-api/schemas/plugin.ts","../src/plugins/@hey-api/schemas/config.ts","../src/plugins/@hey-api/sdk/examples/config.ts","../src/plugins/@hey-api/sdk/operations/config.ts","../src/plugins/@hey-api/sdk/operations/resolve.ts","../src/plugins/@hey-api/sdk/shared/typeOptions.ts","../src/plugins/@hey-api/sdk/v1/plugin.ts","../src/plugins/@hey-api/sdk/plugin.ts","../src/plugins/@hey-api/sdk/config.ts","../src/plugins/@hey-api/transformers/expressions.ts","../src/plugins/@hey-api/transformers/plugin.ts","../src/plugins/@hey-api/transformers/config.ts","../src/plugins/@hey-api/typescript/shared/clientOptions.ts","../src/plugins/shared/utils/schema.ts","../src/plugins/@hey-api/typescript/shared/export.ts","../src/plugins/@hey-api/typescript/shared/operation.ts","../src/plugins/@hey-api/typescript/shared/webhook.ts","../src/plugins/@hey-api/typescript/v1/toAst/array.ts","../src/plugins/@hey-api/typescript/v1/toAst/boolean.ts","../src/plugins/@hey-api/typescript/v1/toAst/enum.ts","../src/plugins/@hey-api/typescript/v1/toAst/never.ts","../src/plugins/@hey-api/typescript/v1/toAst/null.ts","../src/plugins/@hey-api/typescript/v1/toAst/number.ts","../src/plugins/@hey-api/typescript/v1/toAst/object.ts","../src/plugins/@hey-api/typescript/v1/toAst/string.ts","../src/plugins/@hey-api/typescript/v1/toAst/tuple.ts","../src/plugins/@hey-api/typescript/v1/toAst/undefined.ts","../src/plugins/@hey-api/typescript/v1/toAst/unknown.ts","../src/plugins/@hey-api/typescript/v1/toAst/void.ts","../src/plugins/@hey-api/typescript/v1/toAst/index.ts","../src/plugins/@hey-api/typescript/v1/plugin.ts","../src/plugins/@hey-api/typescript/api.ts","../src/plugins/@hey-api/typescript/plugin.ts","../src/plugins/@hey-api/typescript/config.ts","../src/plugins/@pinia/colada/meta.ts","../src/plugins/@pinia/colada/useType.ts","../src/plugins/@pinia/colada/utils.ts","../src/plugins/@pinia/colada/mutationOptions.ts","../src/plugins/@pinia/colada/queryKey.ts","../src/plugins/@pinia/colada/queryOptions.ts","../src/plugins/@pinia/colada/v0/plugin.ts","../src/plugins/@pinia/colada/plugin.ts","../src/plugins/@pinia/colada/config.ts","../src/plugins/@tanstack/query-core/shared/useType.ts","../src/plugins/@tanstack/query-core/queryKey.ts","../src/plugins/@tanstack/query-core/shared/meta.ts","../src/plugins/@tanstack/query-core/v5/infiniteQueryOptions.ts","../src/plugins/@tanstack/query-core/v5/mutationOptions.ts","../src/plugins/@tanstack/query-core/v5/queryOptions.ts","../src/plugins/@tanstack/query-core/v5/useQuery.ts","../src/plugins/@tanstack/query-core/v5/plugin.ts","../src/plugins/@tanstack/query-core/plugin.ts","../src/plugins/@tanstack/angular-query-experimental/config.ts","../src/plugins/@tanstack/react-query/config.ts","../src/plugins/@tanstack/solid-query/config.ts","../src/plugins/@tanstack/svelte-query/config.ts","../src/plugins/@tanstack/vue-query/config.ts","../src/plugins/arktype/v2/api.ts","../src/plugins/arktype/api.ts","../src/plugins/arktype/constants.ts","../src/plugins/arktype/shared/export.ts","../src/plugins/arktype/v2/toAst/null.ts","../src/plugins/arktype/v2/toAst/object.ts","../src/plugins/arktype/v2/toAst/string.ts","../src/plugins/arktype/v2/toAst/index.ts","../src/plugins/arktype/v2/plugin.ts","../src/plugins/arktype/plugin.ts","../src/plugins/arktype/config.ts","../src/plugins/fastify/plugin.ts","../src/plugins/fastify/config.ts","../src/plugins/swr/v2/useSwr.ts","../src/plugins/swr/v2/plugin.ts","../src/plugins/swr/plugin.ts","../src/plugins/swr/config.ts","../src/plugins/valibot/v1/constants.ts","../src/plugins/valibot/shared/pipes.ts","../src/plugins/valibot/v1/api.ts","../src/plugins/valibot/api.ts","../src/plugins/shared/utils/coerce.ts","../src/plugins/valibot/shared/export.ts","../src/plugins/valibot/shared/operation.ts","../src/plugins/valibot/shared/webhook.ts","../src/plugins/valibot/v1/toAst/unknown.ts","../src/plugins/valibot/v1/toAst/array.ts","../src/plugins/valibot/v1/toAst/boolean.ts","../src/plugins/valibot/v1/toAst/enum.ts","../src/plugins/valibot/v1/toAst/never.ts","../src/plugins/valibot/v1/toAst/null.ts","../src/plugins/shared/utils/formats.ts","../src/plugins/valibot/v1/toAst/number.ts","../src/plugins/valibot/v1/toAst/object.ts","../src/plugins/valibot/v1/toAst/string.ts","../src/plugins/valibot/v1/toAst/tuple.ts","../src/plugins/valibot/v1/toAst/undefined.ts","../src/plugins/valibot/v1/toAst/void.ts","../src/plugins/valibot/v1/toAst/index.ts","../src/plugins/valibot/v1/plugin.ts","../src/plugins/valibot/plugin.ts","../src/plugins/valibot/config.ts","../src/plugins/zod/constants.ts","../src/plugins/zod/mini/api.ts","../src/plugins/zod/v3/api.ts","../src/plugins/zod/v4/api.ts","../src/plugins/zod/api.ts","../src/plugins/zod/shared/export.ts","../src/plugins/zod/shared/module.ts","../src/plugins/zod/shared/operation.ts","../src/plugins/zod/shared/webhook.ts","../src/plugins/zod/mini/toAst/unknown.ts","../src/plugins/zod/mini/toAst/array.ts","../src/plugins/zod/mini/toAst/boolean.ts","../src/plugins/zod/mini/toAst/enum.ts","../src/plugins/zod/mini/toAst/never.ts","../src/plugins/zod/mini/toAst/null.ts","../src/plugins/zod/mini/toAst/number.ts","../src/plugins/zod/mini/toAst/object.ts","../src/plugins/zod/mini/toAst/string.ts","../src/plugins/zod/mini/toAst/tuple.ts","../src/plugins/zod/mini/toAst/undefined.ts","../src/plugins/zod/mini/toAst/void.ts","../src/plugins/zod/mini/toAst/index.ts","../src/plugins/zod/mini/plugin.ts","../src/plugins/zod/v3/toAst/unknown.ts","../src/plugins/zod/v3/toAst/array.ts","../src/plugins/zod/v3/toAst/boolean.ts","../src/plugins/zod/v3/toAst/enum.ts","../src/plugins/zod/v3/toAst/never.ts","../src/plugins/zod/v3/toAst/null.ts","../src/plugins/zod/v3/toAst/number.ts","../src/plugins/zod/v3/toAst/object.ts","../src/plugins/zod/v3/toAst/string.ts","../src/plugins/zod/v3/toAst/tuple.ts","../src/plugins/zod/v3/toAst/undefined.ts","../src/plugins/zod/v3/toAst/void.ts","../src/plugins/zod/v3/toAst/index.ts","../src/plugins/zod/v3/plugin.ts","../src/plugins/zod/v4/toAst/unknown.ts","../src/plugins/zod/v4/toAst/array.ts","../src/plugins/zod/v4/toAst/boolean.ts","../src/plugins/zod/v4/toAst/enum.ts","../src/plugins/zod/v4/toAst/never.ts","../src/plugins/zod/v4/toAst/null.ts","../src/plugins/zod/v4/toAst/number.ts","../src/plugins/zod/v4/toAst/object.ts","../src/plugins/zod/v4/toAst/string.ts","../src/plugins/zod/v4/toAst/tuple.ts","../src/plugins/zod/v4/toAst/undefined.ts","../src/plugins/zod/v4/toAst/void.ts","../src/plugins/zod/v4/toAst/index.ts","../src/plugins/zod/v4/plugin.ts","../src/plugins/zod/plugin.ts","../src/plugins/zod/config.ts","../src/plugins/config.ts","../src/config/plugins.ts","../src/config/resolve.ts","../src/config/validate.ts","../src/config/init.ts"],"sourcesContent":["import { getInput } from '@hey-api/shared';\nimport colors from 'ansi-colors';\n\nimport type { UserConfig } from './types';\n\nexport interface Job {\n  config: UserConfig;\n  index: number;\n}\n\nexport function expandToJobs(configs: ReadonlyArray<UserConfig>): ReadonlyArray<Job> {\n  const jobs: Array<Job> = [];\n  let jobIndex = 0;\n\n  for (const config of configs) {\n    const inputs = getInput(config);\n    const outputs = config.output instanceof Array ? config.output : [config.output];\n\n    if (outputs.length === 1) {\n      jobs.push({\n        config: {\n          ...config,\n          input: inputs,\n          output: outputs[0]!, // output array with single item\n        },\n        index: jobIndex++,\n      });\n    } else if (outputs.length > 1 && inputs.length !== outputs.length) {\n      // Warn and create job per output (all with same inputs)\n      console.warn(\n        `⚙️ ${colors.yellow('Warning:')} You provided ${colors.cyan(String(inputs.length))} ${colors.cyan(inputs.length === 1 ? 'input' : 'inputs')} and ${colors.yellow(String(outputs.length))} ${colors.yellow('outputs')}. This will produce identical output in multiple locations. You likely want to provide a single output or the same number of outputs as inputs.`,\n      );\n      for (const output of outputs) {\n        jobs.push({\n          config: { ...config, input: inputs, output },\n          index: jobIndex++,\n        });\n      }\n    } else if (outputs.length > 1) {\n      // Pair inputs with outputs by index\n      outputs.forEach((output, index) => {\n        jobs.push({\n          config: { ...config, input: inputs[index]!, output },\n          index: jobIndex++,\n        });\n      });\n    }\n  }\n\n  return jobs;\n}\n","import fs from 'node:fs';\nimport path from 'node:path';\n\n/**\n * Finds and reads the project's package.json file by searching upwards from the config file location,\n * or from process.cwd() if no config file is provided.\n * This ensures we get the correct dependencies even in monorepo setups.\n *\n * @param configFilePath - The path to the configuration file (e.g., openapi-ts.config.ts)\n * @returns An object containing all project dependencies (dependencies, devDependencies, peerDependencies, optionalDependencies)\n */\nexport const getProjectDependencies = (configFilePath?: string): Record<string, string> => {\n  let currentDir = configFilePath ? path.dirname(configFilePath) : process.cwd();\n\n  while (currentDir !== path.dirname(currentDir)) {\n    const packageJsonPath = path.join(currentDir, 'package.json');\n\n    if (fs.existsSync(packageJsonPath)) {\n      try {\n        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));\n        return {\n          ...packageJson.dependencies,\n          ...packageJson.devDependencies,\n          ...packageJson.peerDependencies,\n          ...packageJson.optionalDependencies,\n        };\n      } catch {\n        // Silently ignore JSON parsing errors and continue searching\n      }\n    }\n\n    const parentDir = path.dirname(currentDir);\n    if (parentDir === currentDir) {\n      break;\n    }\n    currentDir = parentDir;\n  }\n\n  return {};\n};\n","import type { PostProcessor } from '@hey-api/shared';\n\n/**\n * @deprecated Use `PostProcessorPreset` instead.\n */\nexport type Formatters = 'biome' | 'prettier';\n\n/**\n * @deprecated Use `PostProcessorPreset` instead.\n */\nexport type Linters = 'biome' | 'eslint' | 'oxlint';\n\nexport const postProcessors = {\n  'biome:format': {\n    args: ['format', '--write', '{{path}}'],\n    command: 'biome',\n    name: 'Biome (Format)',\n  },\n  'biome:lint': {\n    args: ['lint', '--apply', '{{path}}'],\n    command: 'biome',\n    name: 'Biome (Lint)',\n  },\n  eslint: {\n    args: ['{{path}}', '--fix'],\n    command: 'eslint',\n    name: 'ESLint',\n  },\n  oxfmt: {\n    args: ['{{path}}'],\n    command: 'oxfmt',\n    name: 'Oxfmt',\n  },\n  oxlint: {\n    args: ['--fix', '{{path}}'],\n    command: 'oxlint',\n    name: 'Oxlint',\n  },\n  prettier: {\n    args: ['--ignore-unknown', '{{path}}', '--write', '--ignore-path', './.prettierignore'],\n    command: 'prettier',\n    name: 'Prettier',\n  },\n} as const satisfies Record<string, PostProcessor>;\n\nexport type PostProcessorPreset = keyof typeof postProcessors;\n","import path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nimport { log } from '@hey-api/codegen-core';\nimport type { PostProcessor, UserPostProcessor } from '@hey-api/shared';\nimport { findTsConfigPath, loadTsConfig, resolveSource, valueToObject } from '@hey-api/shared';\nimport type { MaybeArray } from '@hey-api/types';\nimport ts from 'typescript';\n\nimport { postProcessors } from './postprocess';\nimport type { Output, UserOutput } from './types';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nexport function getOutput(userConfig: { output: MaybeArray<string | UserOutput> }): Output {\n  if (userConfig.output instanceof Array) {\n    throw new Error(\n      'Unexpected array of outputs in user configuration. This should have been expanded already.',\n    );\n  }\n\n  const userOutput =\n    typeof userConfig.output === 'string' ? { path: userConfig.output } : (userConfig.output ?? {});\n\n  const legacyPostProcess = resolveLegacyPostProcess(userOutput);\n\n  const output = valueToObject({\n    defaultValue: {\n      clean: true,\n      entryFile: true,\n      fileName: {\n        case: 'preserve',\n        name: '{{name}}',\n        suffix: '.gen',\n      },\n      format: null,\n      header: '// This file is auto-generated by @hey-api/openapi-ts',\n      lint: null,\n      path: '',\n      postProcess: [],\n      preferExportAll: false,\n    },\n    mappers: {\n      object: (fields, defaultValue) => ({\n        ...fields,\n        fileName: valueToObject({\n          defaultValue: {\n            ...(defaultValue.fileName as Extract<\n              typeof defaultValue.fileName,\n              Record<string, unknown>\n            >),\n          },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: fields.fileName,\n        }),\n      }),\n    },\n    value: userOutput,\n  }) as Output;\n  output.tsConfig = loadTsConfig(findTsConfigPath(__dirname, output.tsConfigPath));\n  if (\n    output.importFileExtension === undefined &&\n    (output.tsConfig?.options.moduleResolution === ts.ModuleResolutionKind.NodeNext ||\n      output.tsConfig?.options.moduleResolution === ts.ModuleResolutionKind.Node16)\n  ) {\n    output.importFileExtension = '.js';\n  }\n  if (output.importFileExtension && !output.importFileExtension.startsWith('.')) {\n    output.importFileExtension = `.${output.importFileExtension}`;\n  }\n  output.postProcess = normalizePostProcess(userOutput.postProcess ?? legacyPostProcess);\n  output.source = resolveSource(output);\n  return output;\n}\n\nfunction resolveLegacyPostProcess(config: Partial<UserOutput>): ReadonlyArray<UserPostProcessor> {\n  const result: Array<UserPostProcessor> = [];\n\n  if (config.lint !== undefined) {\n    let processor: PostProcessor | undefined;\n    let preset: keyof typeof postProcessors | undefined;\n    if (config.lint) {\n      preset = config.lint === 'biome' ? 'biome:lint' : config.lint;\n      processor = postProcessors[preset];\n      if (processor) result.push(processor);\n    }\n\n    log.warnDeprecated({\n      context: 'output',\n      field: 'lint',\n      replacement: `postProcess: [${processor && preset ? `'${preset}'` : ''}]`,\n    });\n  }\n\n  if (config.format !== undefined) {\n    let processor: PostProcessor | undefined;\n    let preset: keyof typeof postProcessors | undefined;\n    if (config.format) {\n      preset = config.format === 'biome' ? 'biome:format' : config.format;\n      processor = postProcessors[preset];\n      if (processor) result.push(processor);\n    }\n\n    log.warnDeprecated({\n      context: 'output',\n      field: 'format',\n      replacement: `postProcess: [${processor && preset ? `'${preset}'` : ''}]`,\n    });\n  }\n\n  return result;\n}\n\nfunction normalizePostProcess(input: UserOutput['postProcess']): ReadonlyArray<PostProcessor> {\n  if (!input) return [];\n\n  return input.map((item) => {\n    if (typeof item === 'string') {\n      const preset = postProcessors[item];\n      if (!preset) {\n        throw new Error(`Unknown post-processor preset: \"${item}\"`);\n      }\n      return preset;\n    }\n    return {\n      name: item.name ?? item.command,\n      ...item,\n    };\n  });\n}\n","import type { PluginContext } from '@hey-api/shared';\n\nimport type { UserConfig } from '../types';\nimport type { HttpRequestsConfig, UserHttpRequestsConfig } from './types';\n\ntype Config = Omit<UserConfig, 'name'>;\n\nexport function resolveHttpRequests(config: Config, context: PluginContext): HttpRequestsConfig {\n  let input = config.httpRequests;\n  if (typeof input === 'string' || typeof input === 'function') {\n    input = { strategy: input };\n  } else if (typeof input === 'boolean' || !input) {\n    input = { enabled: Boolean(input) };\n  }\n\n  const strategy = input.strategy ?? 'flat';\n\n  return context.valueToObject({\n    defaultValue: {\n      container: 'class',\n      enabled: true,\n      methods: 'instance',\n      nesting: 'operationId',\n      nestingDelimiters: /[./]/,\n      strategy,\n      strategyDefaultTag: 'default',\n    },\n    mappers: {\n      object(value) {\n        value.containerName = context.valueToObject({\n          defaultValue:\n            strategy === 'single'\n              ? { casing: 'PascalCase', name: 'HttpRequests' }\n              : { casing: 'PascalCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.containerName,\n        });\n        value.methodName = context.valueToObject({\n          defaultValue:\n            strategy === 'flat'\n              ? { casing: 'camelCase', name: '{{name}}Request' }\n              : { casing: 'camelCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.methodName,\n        });\n        value.segmentName = context.valueToObject({\n          defaultValue: { casing: 'PascalCase', name: '{{name}}Requests' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.segmentName,\n        });\n        return value;\n      },\n    },\n    value: input as UserHttpRequestsConfig,\n  }) as HttpRequestsConfig;\n}\n","import type { OperationPathStrategy, OperationStructureStrategy } from '@hey-api/shared';\nimport { OperationPath, OperationStrategy } from '@hey-api/shared';\n\nimport type { AngularCommonPlugin } from '../types';\n\nfunction resolvePath(plugin: AngularCommonPlugin['Instance']): OperationPathStrategy {\n  if (plugin.config.httpRequests.nesting === 'id') {\n    return OperationPath.id();\n  }\n\n  if (plugin.config.httpRequests.nesting === 'operationId') {\n    return OperationPath.fromOperationId({\n      delimiters: plugin.config.httpRequests.nestingDelimiters,\n      fallback: OperationPath.id(),\n    });\n  }\n\n  return plugin.config.httpRequests.nesting;\n}\n\nexport function resolveHttpRequestsStrategy(\n  plugin: AngularCommonPlugin['Instance'],\n): OperationStructureStrategy {\n  if (plugin.config.httpRequests.strategy === 'flat') {\n    return OperationStrategy.flat({\n      path: (operation) => [resolvePath(plugin)(operation).join('.')],\n    });\n  }\n\n  if (plugin.config.httpRequests.strategy === 'single') {\n    const root = plugin.config.httpRequests.containerName;\n    return OperationStrategy.single({\n      path: resolvePath(plugin),\n      root: typeof root.name === 'string' ? root.name : (root.name?.('') ?? ''),\n    });\n  }\n\n  if (plugin.config.httpRequests.strategy === 'byTags') {\n    return OperationStrategy.byTags({\n      fallback: plugin.config.httpRequests.strategyDefaultTag,\n      path: resolvePath(plugin),\n    });\n  }\n\n  return plugin.config.httpRequests.strategy;\n}\n","import type { PluginContext } from '@hey-api/shared';\n\nimport type { UserConfig } from '../types';\nimport type { HttpResourcesConfig, UserHttpResourcesConfig } from './types';\n\ntype Config = Omit<UserConfig, 'name'>;\n\nexport function resolveHttpResources(config: Config, context: PluginContext): HttpResourcesConfig {\n  let input = config.httpResources;\n  if (typeof input === 'string' || typeof input === 'function') {\n    input = { strategy: input };\n  } else if (typeof input === 'boolean' || !input) {\n    input = { enabled: Boolean(input) };\n  }\n\n  const strategy = input.strategy ?? 'flat';\n\n  return context.valueToObject({\n    defaultValue: {\n      container: 'class',\n      enabled: true,\n      methods: 'instance',\n      nesting: 'operationId',\n      nestingDelimiters: /[./]/,\n      strategy,\n      strategyDefaultTag: 'default',\n    },\n    mappers: {\n      object(value) {\n        value.containerName = context.valueToObject({\n          defaultValue:\n            strategy === 'single'\n              ? { casing: 'PascalCase', name: 'HttpResources' }\n              : { casing: 'PascalCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.containerName,\n        });\n        value.methodName = context.valueToObject({\n          defaultValue:\n            strategy === 'flat'\n              ? { casing: 'camelCase', name: '{{name}}Resource' }\n              : { casing: 'camelCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.methodName,\n        });\n        value.segmentName = context.valueToObject({\n          defaultValue: { casing: 'PascalCase', name: '{{name}}Resources' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.segmentName,\n        });\n        return value;\n      },\n    },\n    value: input as UserHttpResourcesConfig,\n  }) as HttpResourcesConfig;\n}\n","import type { OperationPathStrategy, OperationStructureStrategy } from '@hey-api/shared';\nimport { OperationPath, OperationStrategy } from '@hey-api/shared';\n\nimport type { AngularCommonPlugin } from '../types';\n\nfunction resolvePath(plugin: AngularCommonPlugin['Instance']): OperationPathStrategy {\n  if (plugin.config.httpResources.nesting === 'id') {\n    return OperationPath.id();\n  }\n\n  if (plugin.config.httpResources.nesting === 'operationId') {\n    return OperationPath.fromOperationId({\n      delimiters: plugin.config.httpResources.nestingDelimiters,\n      fallback: OperationPath.id(),\n    });\n  }\n\n  return plugin.config.httpResources.nesting;\n}\n\nexport function resolveHttpResourcesStrategy(\n  plugin: AngularCommonPlugin['Instance'],\n): OperationStructureStrategy {\n  if (plugin.config.httpResources.strategy === 'flat') {\n    return OperationStrategy.flat({\n      path: (operation) => [resolvePath(plugin)(operation).join('.')],\n    });\n  }\n\n  if (plugin.config.httpResources.strategy === 'single') {\n    const root = plugin.config.httpResources.containerName;\n    return OperationStrategy.single({\n      path: resolvePath(plugin),\n      root: typeof root.name === 'string' ? root.name : (root.name?.('') ?? ''),\n    });\n  }\n\n  if (plugin.config.httpResources.strategy === 'byTags') {\n    return OperationStrategy.byTags({\n      fallback: plugin.config.httpResources.strategyDefaultTag,\n      path: resolvePath(plugin),\n    });\n  }\n\n  return plugin.config.httpResources.strategy;\n}\n","import type { Context, PluginInstance } from '@hey-api/shared';\n\nimport type { Config } from './types';\n\nexport function getTypedConfig(\n  plugin: Pick<PluginInstance, 'context'> | Pick<Context, 'config'>,\n): Config {\n  if ('context' in plugin) {\n    return plugin.context.config as Config;\n  }\n  return plugin.config as Config;\n}\n","import type { Config } from '../../../config/types';\nimport type { PluginClientNames } from '../../../plugins/types';\n\nexport function getClientBaseUrlKey(config: Config) {\n  const client = getClientPlugin(config);\n  if (client.name === '@hey-api/client-axios' || client.name === '@hey-api/client-nuxt') {\n    return 'baseURL';\n  }\n  return 'baseUrl';\n}\n\nexport function getClientPlugin(\n  config: Config,\n): Config['plugins'][PluginClientNames] & { name: PluginClientNames } {\n  for (const name of config.pluginOrder) {\n    const plugin = config.plugins[name];\n    if (plugin?.tags?.includes('client')) {\n      return plugin as Config['plugins'][PluginClientNames] & {\n        name: PluginClientNames;\n      };\n    }\n  }\n\n  return {\n    config: {\n      // @ts-expect-error\n      name: '',\n    },\n    // @ts-expect-error\n    name: '',\n  };\n}\n","// TODO: symbol should be protected, but needs to be public to satisfy types\nimport type {\n  AnalysisContext,\n  File,\n  FromRef,\n  Language,\n  Node,\n  NodeName,\n  NodeNameSanitizer,\n  NodeRelationship,\n  NodeScope,\n  Ref,\n  Symbol,\n} from '@hey-api/codegen-core';\nimport { fromRef, isNode, isRef, isSymbol, nodeBrand, ref } from '@hey-api/codegen-core';\nimport type { AnyString } from '@hey-api/types';\nimport ts from 'typescript';\n\nimport type { AccessOptions } from './utils/context';\n\nexport abstract class TsDsl<T extends ts.Node = ts.Node> implements Node<T> {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  analyze(_: AnalysisContext): void {}\n  clone(): this {\n    const cloned = Object.create(Object.getPrototypeOf(this));\n    Object.assign(cloned, this);\n    return cloned;\n  }\n  exported?: boolean;\n  file?: File;\n  get name(): Node['name'] {\n    return {\n      ...this._name,\n      set: (value) => {\n        this._name = ref(value);\n        if (isSymbol(value)) {\n          value.setNode(this);\n        }\n      },\n      toString: () => (this._name ? this.$name(this._name) : ''),\n    } as Node['name'];\n  }\n  readonly nameSanitizer?: NodeNameSanitizer;\n  language: Language = 'typescript';\n  parent?: Node;\n  root: boolean = false;\n  scope?: NodeScope = 'value';\n  structuralChildren?: Map<TsDsl, NodeRelationship>;\n  structuralParents?: Map<TsDsl, NodeRelationship>;\n  symbol?: Symbol;\n  toAst(): T {\n    return undefined as unknown as T;\n  }\n  readonly '~brand' = nodeBrand;\n\n  /** Branding property to identify the DSL class at runtime. */\n  abstract readonly '~dsl': AnyString;\n\n  /** Conditionally applies a callback to this builder. */\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: (self: T, v: Exclude<V, false | null | undefined>) => R | void,\n    ifFalse?: (self: T, v: Extract<V, false | null | undefined>) => R | void,\n  ): R | T;\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: (v: Exclude<V, false | null | undefined>) => R | void,\n    ifFalse?: (v: Extract<V, false | null | undefined>) => R | void,\n  ): R | T;\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: () => R | void,\n    ifFalse?: () => R | void,\n  ): R | T;\n  $if<T extends TsDsl, V, R extends TsDsl = T>(\n    this: T,\n    value: V,\n    ifTrue: any,\n    ifFalse?: any,\n  ): R | T {\n    if (value) {\n      // Try calling with (self, value), then (value), then ()\n      let result: R | void | undefined;\n      try {\n        result = ifTrue?.(this, value as Exclude<V, false | null | undefined>);\n      } catch {\n        // ignore and try other signatures\n      }\n      if (result === undefined) {\n        try {\n          result = ifTrue?.(value as Exclude<V, false | null | undefined>);\n        } catch {\n          // ignore and try zero-arg\n        }\n      }\n      if (result === undefined) {\n        try {\n          result = ifTrue?.();\n        } catch {\n          // swallow\n        }\n      }\n      return (result ?? this) as R | T;\n    }\n    if (ifFalse) {\n      let result: R | void | undefined;\n      try {\n        result = ifFalse?.(this, value as Extract<V, false | null | undefined>);\n      } catch {\n        // ignore\n      }\n      if (result === undefined) {\n        try {\n          result = ifFalse?.(value as Extract<V, false | null | undefined>);\n        } catch {\n          // ignore\n        }\n      }\n      if (result === undefined) {\n        try {\n          result = ifFalse?.();\n        } catch {\n          // ignore\n        }\n      }\n      return (result ?? this) as R | T;\n    }\n    return this;\n  }\n\n  /** Access patterns for this node. */\n  toAccessNode?(\n    node: this,\n    options: AccessOptions,\n    ctx: {\n      /** The full chain. */\n      chain: ReadonlyArray<TsDsl>;\n      /** Position in the chain (0 = root). */\n      index: number;\n      /** Is this the leaf node? */\n      isLeaf: boolean;\n      /** Is this the root node? */\n      isRoot: boolean;\n      /** Total length of the chain. */\n      length: number;\n    },\n  ): TsDsl | undefined;\n\n  protected $maybeId<T extends string | ts.Expression>(\n    expr: T,\n  ): T extends string ? ts.Identifier : T {\n    return (typeof expr === 'string' ? ts.factory.createIdentifier(expr) : expr) as T extends string\n      ? ts.Identifier\n      : T;\n  }\n\n  protected $name(name: Ref<NodeName>): string {\n    const value = fromRef(name);\n    if (isSymbol(value)) {\n      try {\n        return value.finalName;\n      } catch {\n        return value.name;\n      }\n    }\n    return String(value);\n  }\n\n  protected $node<I>(value: I): NodeOfMaybe<I> {\n    if (value === undefined) {\n      return undefined as NodeOfMaybe<I>;\n    }\n    // @ts-expect-error\n    if (isRef(value)) value = fromRef(value);\n    if (isSymbol(value)) {\n      return this.$maybeId(value.finalName) as NodeOfMaybe<I>;\n    }\n    if (typeof value === 'string') {\n      return this.$maybeId(value) as NodeOfMaybe<I>;\n    }\n    if (value instanceof Array) {\n      return value.map((item) => {\n        if (isRef(item)) item = fromRef(item);\n        return this.unwrap(item);\n      }) as NodeOfMaybe<I>;\n    }\n    return this.unwrap(value as any) as NodeOfMaybe<I>;\n  }\n\n  protected $type<I>(value: I, args?: ReadonlyArray<ts.TypeNode>): TypeOfMaybe<I> {\n    if (value === undefined) {\n      return undefined as TypeOfMaybe<I>;\n    }\n    // @ts-expect-error\n    if (isRef(value)) value = fromRef(value);\n    if (isSymbol(value)) {\n      return ts.factory.createTypeReferenceNode(value.finalName, args) as TypeOfMaybe<I>;\n    }\n    if (typeof value === 'string') {\n      return ts.factory.createTypeReferenceNode(value, args) as TypeOfMaybe<I>;\n    }\n    if (typeof value === 'boolean') {\n      const literal = value ? ts.factory.createTrue() : ts.factory.createFalse();\n      return ts.factory.createLiteralTypeNode(literal) as TypeOfMaybe<I>;\n    }\n    if (typeof value === 'number') {\n      return ts.factory.createLiteralTypeNode(\n        ts.factory.createNumericLiteral(value),\n      ) as TypeOfMaybe<I>;\n    }\n    if (value instanceof Array) {\n      return value.map((item) => this.$type(item, args)) as TypeOfMaybe<I>;\n    }\n    return this.unwrap(value as any) as TypeOfMaybe<I>;\n  }\n\n  private _name?: Ref<NodeName>;\n\n  /** Unwraps nested nodes into raw TypeScript AST. */\n  private unwrap<I>(value: I): I extends TsDsl<infer N> ? N : I {\n    return (isNode(value) ? value.toAst() : value) as I extends TsDsl<infer N> ? N : I;\n  }\n}\n\ntype NodeOfMaybe<I> = undefined extends I\n  ? NodeOf<NonNullable<FromRef<I>>> | undefined\n  : NodeOf<FromRef<I>>;\n\ntype NodeOf<I> =\n  I extends ReadonlyArray<infer U>\n    ? ReadonlyArray<U extends TsDsl<infer N> ? N : U>\n    : I extends string\n      ? ts.Expression\n      : I extends TsDsl<infer N>\n        ? N\n        : I extends ts.Node\n          ? I\n          : never;\n\nexport type MaybeTsDsl<T> =\n  T extends TsDsl<infer U> ? U | TsDsl<U> : T extends ts.Node ? T | TsDsl<T> : never;\n\nexport abstract class TypeTsDsl<\n  T extends\n    | ts.LiteralTypeNode\n    | ts.QualifiedName\n    | ts.TypeElement\n    | ts.TypeNode\n    | ts.TypeParameterDeclaration = ts.TypeNode,\n> extends TsDsl<T> {}\n\ntype TypeOfMaybe<I> = undefined extends I\n  ? TypeOf<NonNullable<FromRef<I>>> | undefined\n  : TypeOf<FromRef<I>>;\n\ntype TypeOf<I> =\n  I extends ReadonlyArray<infer U>\n    ? ReadonlyArray<TypeOf<U>>\n    : I extends string\n      ? ts.TypeNode\n      : I extends boolean\n        ? ts.LiteralTypeNode\n        : I extends TsDsl<infer N>\n          ? N\n          : I extends ts.TypeNode\n            ? I\n            : never;\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.Identifier>;\n\nexport class IdTsDsl extends Mixed {\n  readonly '~dsl' = 'IdTsDsl';\n\n  constructor(name: string) {\n    super();\n    this.name.set(name);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  override toAst() {\n    return ts.factory.createIdentifier(this.name.toString());\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\n\nexport class NewlineTsDsl extends TsDsl<ts.Identifier> {\n  readonly '~dsl' = 'NewlineTsDsl';\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  override toAst(): ts.Identifier {\n    return this.$node(new IdTsDsl('\\n'));\n  }\n}\n","import type { AnalysisContext, Node, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport type { BaseCtor, MixinCtor } from './types';\n\ntype Arg = NodeName | MaybeTsDsl<ts.Expression>;\n\nexport interface ArgsMethods extends Node {\n  /** Renders the arguments into an array of `Expression`s. */\n  $args(): ReadonlyArray<ts.Expression>;\n  /** Adds a single expression argument. */\n  arg(arg: Arg | undefined): this;\n  /** Adds one or more expression arguments. */\n  args(...args: ReadonlyArray<Arg | undefined>): this;\n}\n\n/**\n * Adds `.arg()` and `.args()` for managing expression arguments in call-like nodes.\n */\nexport function ArgsMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Args extends Base {\n    protected _args: Array<Ref<Arg>> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      for (const arg of this._args) {\n        ctx.analyze(arg);\n      }\n    }\n\n    protected arg(arg: Arg | undefined): this {\n      if (arg !== undefined) this._args.push(ref(arg));\n      return this;\n    }\n\n    protected args(...args: ReadonlyArray<Arg | undefined>): this {\n      this._args.push(\n        ...args.filter((a): a is NonNullable<typeof a> => a !== undefined).map((a) => ref(a)),\n      );\n      return this;\n    }\n\n    protected $args(): ReadonlyArray<ts.Expression> {\n      return this.$node(this._args).map((arg) => this.$node(arg));\n    }\n  }\n\n  return Args as unknown as MixinCtor<TBase, ArgsMethods>;\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.PrefixUnaryExpression>;\n\nexport class PrefixTsDsl extends Mixed {\n  readonly '~dsl' = 'PrefixTsDsl';\n\n  protected _expr?: string | MaybeTsDsl<ts.Expression>;\n  protected _op?: ts.PrefixUnaryOperator;\n\n  constructor(expr?: string | MaybeTsDsl<ts.Expression>, op?: ts.PrefixUnaryOperator) {\n    super();\n    this._expr = expr;\n    this._op = op;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._expr);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Sets the operand (the expression being prefixed). */\n  expr(expr: string | MaybeTsDsl<ts.Expression>): this {\n    this._expr = expr;\n    return this;\n  }\n\n  /** Sets the operator to MinusToken for negation (`-`). */\n  neg(): this {\n    this._op = ts.SyntaxKind.MinusToken;\n    return this;\n  }\n\n  /** Sets the operator to ExclamationToken for logical NOT (`!`). */\n  not(): this {\n    this._op = ts.SyntaxKind.ExclamationToken;\n    return this;\n  }\n\n  /** Sets the operator (e.g. `ts.SyntaxKind.ExclamationToken` for `!`). */\n  op(op: ts.PrefixUnaryOperator): this {\n    this._op = op;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    return ts.factory.createPrefixUnaryExpression(this._op, this.$node(this._expr));\n  }\n\n  $validate(): asserts this is this & {\n    _expr: string | MaybeTsDsl<ts.Expression>;\n    _op: ts.PrefixUnaryOperator;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Prefix unary expression missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._expr) missing.push('.expr()');\n    if (!this._op) missing.push('operator (e.g., .not(), .neg())');\n    return missing;\n  }\n}\n","import type { AsCtor } from '../expr/as';\nimport type { AttrCtor } from '../expr/attr';\nimport type { AwaitCtor } from '../expr/await';\nimport type { CallCtor } from '../expr/call';\nimport type { NewCtor } from '../expr/new';\nimport type { TypeOfExprCtor } from '../expr/typeof';\nimport type { ReturnCtor } from '../stmt/return';\nimport type { TypeExprCtor } from '../type/expr';\nimport type { TypeIdxCtor } from '../type/idx';\nimport type { TypeOperatorCtor } from '../type/operator';\nimport type { TypeQueryCtor } from '../type/query';\n\ntype Ctor = (...args: Array<any>) => any;\n\ntype Factory<T extends Ctor> = {\n  (...args: Parameters<T>): ReturnType<T>;\n  /** Sets the implementation of this factory. */\n  set(fn: T): void;\n};\n\nfunction createFactory<T extends Ctor>(name: string): Factory<T> {\n  let impl: T | undefined;\n\n  const slot = ((...args: Parameters<T>) => {\n    if (!impl) throw new Error(`${name} factory not registered`);\n    return impl(...args);\n  }) as Factory<T>;\n\n  slot.set = (fn: T) => {\n    impl = fn;\n  };\n\n  return slot;\n}\n\nexport const f = {\n  /** Factory for creating `as` type assertion expressions (e.g. `value as Type`). */\n  as: createFactory<AsCtor>('as'),\n\n  /** Factory for creating property access expressions (e.g. `obj.foo`). */\n  attr: createFactory<AttrCtor>('attr'),\n\n  /** Factory for creating await expressions (e.g. `await promise`). */\n  await: createFactory<AwaitCtor>('await'),\n\n  /** Factory for creating function or method call expressions (e.g. `fn(arg)`). */\n  call: createFactory<CallCtor>('call'),\n\n  /** Factory for creating new expressions (e.g. `new ClassName()`). */\n  new: createFactory<NewCtor>('new'),\n\n  /** Factory for creating return statements. */\n  return: createFactory<ReturnCtor>('return'),\n\n  /** Factories for creating type nodes. */\n  type: {\n    /** Factory for creating basic type references or type expressions (e.g. Foo or Foo<T>). */\n    expr: createFactory<TypeExprCtor>('type.expr'),\n\n    /** Factory for creating indexed-access types (e.g. `Foo<T>[K]`). */\n    idx: createFactory<TypeIdxCtor>('type.idx'),\n\n    /** Factory for creating type operator nodes (e.g. `readonly T`, `keyof T`, `unique T`). */\n    operator: createFactory<TypeOperatorCtor>('type.operator'),\n\n    /** Factory for creating type query nodes (e.g. `typeof Foo`). */\n    query: createFactory<TypeQueryCtor>('type.query'),\n  },\n\n  /** Factory for creating `typeof` expressions (e.g. `typeof value`). */\n  typeofExpr: createFactory<TypeOfExprCtor>('typeofExpr'),\n};\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { f } from '../utils/factories';\nimport type { BaseCtor, DropFirst, MixinCtor } from './types';\n\nexport interface AsMethods extends Node {\n  /** Creates an `as` type assertion expression (e.g. `value as Type`). */\n  as(...args: DropFirst<Parameters<typeof f.as>>): ReturnType<typeof f.as>;\n}\n\nexport function AsMixin<T extends ts.Expression, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class As extends Base {\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected as(...args: DropFirst<Parameters<typeof f.as>>): ReturnType<typeof f.as> {\n      return f.as(this, ...args);\n    }\n  }\n\n  return As as unknown as MixinCtor<TBase, AsMethods>;\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { PrefixTsDsl } from '../expr/prefix';\nimport { AsMixin } from '../mixins/as';\n\nexport type LiteralValue = string | number | boolean | bigint | null;\n\nconst Mixed = AsMixin(\n  TsDsl<\n    | ts.BigIntLiteral\n    | ts.BooleanLiteral\n    | ts.NullLiteral\n    | ts.NumericLiteral\n    | ts.PrefixUnaryExpression\n    | ts.StringLiteral\n  >,\n);\n\nexport class LiteralTsDsl extends Mixed {\n  readonly '~dsl' = 'LiteralTsDsl';\n\n  protected value: LiteralValue;\n\n  constructor(value: LiteralValue) {\n    super();\n    this.value = value;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  override toAst() {\n    if (typeof this.value === 'boolean') {\n      return this.value ? ts.factory.createTrue() : ts.factory.createFalse();\n    }\n    if (typeof this.value === 'number') {\n      const expr = ts.factory.createNumericLiteral(Math.abs(this.value));\n      return this.value < 0 ? this.$node(new PrefixTsDsl(expr).neg()) : expr;\n    }\n    if (typeof this.value === 'string') {\n      return ts.factory.createStringLiteral(this.value, true);\n    }\n    if (typeof this.value === 'bigint') {\n      return ts.factory.createBigIntLiteral(this.value.toString());\n    }\n    if (this.value === null) {\n      return ts.factory.createNull();\n    }\n    throw new Error(`Unsupported literal: ${String(this.value)}`);\n  }\n}\n","/**\n * Matches characters from the start as long as they're not allowed.\n */\nconst illegalStartCharactersRegExp = /^[^$_\\p{ID_Start}]+/u;\n\n/**\n * Matches string if it contains only digits and optionally decimal point or\n * leading minus sign.\n */\nconst numberRegExp = /^-?\\d+(\\.\\d+)?$/;\n\n/**\n * Javascript identifier regexp pattern retrieved from\n * {@link} https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n */\nconst validTypescriptIdentifierRegExp = /^[$_\\p{ID_Start}][$\\u200c\\u200d\\p{ID_Continue}]*$/u;\n\nexport const regexp = {\n  /**\n   * Matches characters from the start as long as they're not allowed.\n   */\n  illegalStartCharacters: illegalStartCharactersRegExp,\n  /**\n   * Matches string if it contains only digits and optionally decimal point or\n   * leading minus sign.\n   */\n  number: numberRegExp,\n  /**\n   * Javascript identifier regexp pattern retrieved from\n   * {@link} https://developer.mozilla.org/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers\n   */\n  typeScriptIdentifier: validTypescriptIdentifierRegExp,\n};\n","const browserGlobals = ['document', 'history', 'location', 'navigator', 'window'];\n\nconst javaScriptGlobals = [\n  'console',\n  'Array',\n  'Date',\n  'Error',\n  'Function',\n  'JSON',\n  'Map',\n  'Math',\n  'Object',\n  'Promise',\n  'RegExp',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n];\n\nconst javaScriptKeywords = [\n  'arguments',\n  'async',\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'enum',\n  'eval',\n  'export',\n  'extends',\n  'false',\n  'finally',\n  'for',\n  'from',\n  'function',\n  'if',\n  'implements',\n  'import',\n  'in',\n  'instanceof',\n  'interface',\n  'let',\n  'new',\n  'null',\n  'package',\n  'private',\n  'protected',\n  'public',\n  'return',\n  'static',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'true',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n];\n\nconst nodeGlobals = ['global', 'process', 'Buffer'];\n\nconst typeScriptKeywords = [\n  'any',\n  'as',\n  'bigint',\n  'boolean',\n  'namespace',\n  'never',\n  'null',\n  'number',\n  'string',\n  'symbol',\n  'type',\n  'undefined',\n  'unknown',\n  'void',\n];\n\nexport const keywords = {\n  browserGlobals,\n  javaScriptGlobals,\n  javaScriptKeywords,\n  nodeGlobals,\n  typeScriptKeywords,\n};\n","import { keywords } from './keywords';\n\ntype List = ReadonlyArray<string>;\n\nexport class ReservedList {\n  private _array: List;\n  private _set: Set<string>;\n\n  constructor(values: List) {\n    this._array = values;\n    this._set = new Set(values);\n  }\n\n  get '~values'() {\n    return this._set;\n  }\n\n  /**\n   * Updates the reserved list with new values.\n   *\n   * @param values New reserved values or a function that receives the previous\n   * reserved values and returns the new ones.\n   */\n  set(values: List | ((prev: List) => List)): void {\n    const vals = typeof values === 'function' ? values(this._array) : values;\n    this._array = vals;\n    this._set = new Set(vals);\n  }\n}\n\nconst runtimeReserved = new ReservedList([\n  ...keywords.browserGlobals,\n  ...keywords.javaScriptGlobals,\n  ...keywords.javaScriptKeywords,\n  ...keywords.nodeGlobals,\n  ...keywords.typeScriptKeywords,\n]);\n\nconst typeReserved = new ReservedList([\n  ...keywords.javaScriptKeywords,\n  ...keywords.typeScriptKeywords,\n]);\n\n/**\n * Reserved names for identifiers. These names will not be used\n * for variables, functions, classes, or other identifiers in generated code.\n */\nexport const reserved = {\n  /**\n   * Reserved names for runtime identifiers. These names will not be used\n   * for variables, functions, classes, or other runtime identifiers in\n   * generated code.\n   */\n  runtime: runtimeReserved,\n  /**\n   * Reserved names for type identifiers. These names will not be used\n   * for type or interface identifiers in generated code.\n   */\n  type: typeReserved,\n};\n","import type ts from 'typescript';\n\nimport type { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\nimport { LiteralTsDsl } from '../expr/literal';\nimport { regexp } from './regexp';\nimport type { ReservedList } from './reserved';\nimport { reserved } from './reserved';\n\nexport const safeAccessorName = (name: string): string => {\n  regexp.number.lastIndex = 0;\n  if (regexp.number.test(name)) {\n    return name.startsWith('-') ? `'${name}'` : name;\n  }\n\n  regexp.typeScriptIdentifier.lastIndex = 0;\n  if (regexp.typeScriptIdentifier.test(name)) {\n    return name;\n  }\n  return `'${name}'`;\n};\n\nexport const safeMemberName = (name: string): TsDsl<ts.StringLiteral> | IdTsDsl => {\n  regexp.typeScriptIdentifier.lastIndex = 0;\n  if (regexp.typeScriptIdentifier.test(name)) {\n    return new IdTsDsl(name);\n  }\n  return new LiteralTsDsl(name) as TsDsl<ts.StringLiteral>;\n};\n\nexport const safePropName = (\n  name: string,\n): TsDsl<ts.StringLiteral | ts.NumericLiteral> | IdTsDsl => {\n  regexp.number.lastIndex = 0;\n  if (regexp.number.test(name)) {\n    return name.startsWith('-')\n      ? (new LiteralTsDsl(name) as TsDsl<ts.StringLiteral>)\n      : (new LiteralTsDsl(Number(name)) as TsDsl<ts.NumericLiteral>);\n  }\n\n  regexp.typeScriptIdentifier.lastIndex = 0;\n  if (regexp.typeScriptIdentifier.test(name)) {\n    return new IdTsDsl(name);\n  }\n\n  return new LiteralTsDsl(name) as TsDsl<ts.StringLiteral>;\n};\n\nconst safeName = (name: string, reserved: ReservedList): string => {\n  let sanitized = '';\n  let index: number;\n\n  const first = name[0] ?? '';\n  regexp.illegalStartCharacters.lastIndex = 0;\n  if (regexp.illegalStartCharacters.test(first)) {\n    sanitized += '_';\n    index = 0;\n  } else {\n    sanitized += first;\n    index = 1;\n  }\n\n  while (index < name.length) {\n    const char = name[index] ?? '';\n    sanitized += /^[\\u200c\\u200d\\p{ID_Continue}]$/u.test(char) ? char : '_';\n    index += 1;\n  }\n\n  if (reserved['~values'].has(sanitized)) {\n    sanitized = `${sanitized}_`;\n  }\n\n  return sanitized || '_';\n};\n\nexport const safeRuntimeName = (name: string): string => safeName(name, reserved.runtime);\n\nexport const safeTypeName = (name: string): string => safeName(name, reserved.type);\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { ArgsMixin } from '../mixins/args';\nimport { safeRuntimeName } from '../utils/name';\n\nconst Mixed = ArgsMixin(TsDsl<ts.Decorator>);\n\nexport class DecoratorTsDsl extends Mixed {\n  readonly '~dsl' = 'DecoratorTsDsl';\n  override readonly nameSanitizer = safeRuntimeName;\n\n  constructor(name: NodeName, ...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression>>) {\n    super();\n    this.name.set(name);\n    this.args(...args);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n  }\n\n  override toAst() {\n    const target = this.$node(this.name);\n    const args = this.$args();\n    return ts.factory.createDecorator(\n      args.length ? ts.factory.createCallExpression(target, undefined, args) : target,\n    );\n  }\n}\n","import type { AnalysisContext, Node, NodeName } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { DecoratorTsDsl } from '../decl/decorator';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface DecoratorMethods extends Node {\n  /** Renders the decorators into an array of `ts.Decorator`s. */\n  $decorators(): ReadonlyArray<ts.Decorator>;\n  /** Adds a decorator (e.g. `@sealed({ in: 'root' })`). */\n  decorator(\n    name: NodeName | MaybeTsDsl<ts.Expression>,\n    ...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression>>\n  ): this;\n}\n\nexport function DecoratorMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Decorator extends Base {\n    protected decorators: Array<DecoratorTsDsl> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      for (const decorator of this.decorators) {\n        ctx.analyze(decorator);\n      }\n    }\n\n    protected decorator(\n      name: NodeName,\n      ...args: ReadonlyArray<string | MaybeTsDsl<ts.Expression>>\n    ): this {\n      this.decorators.push(new DecoratorTsDsl(name, ...args));\n      return this;\n    }\n\n    protected $decorators(): ReadonlyArray<ts.Decorator> {\n      return this.$node(this.decorators);\n    }\n  }\n\n  return Decorator as unknown as MixinCtor<TBase, DecoratorMethods>;\n}\n","import type { BindingKind, NodeScope, Symbol } from '@hey-api/codegen-core';\nimport { isSymbol } from '@hey-api/codegen-core';\nimport type { MaybeFunc } from '@hey-api/types';\nimport type ts from 'typescript';\n\nimport type { DollarTsDsl } from '../../ts-dsl';\nimport { $, TypeScriptRenderer } from '../../ts-dsl';\nimport type { TsDsl } from '../base';\nimport type { CallArgs } from '../expr/call';\n\nexport type NodeChain = ReadonlyArray<TsDsl>;\n\nexport interface AccessOptions {\n  /** The access context. */\n  context?: 'example';\n  /** Enable debug mode. */\n  debug?: boolean;\n  /** Transform function for each node in the access chain. */\n  transform?: (node: TsDsl, index: number, chain: NodeChain) => TsDsl;\n}\n\nexport type AccessResult = ReturnType<typeof $.expr | typeof $.attr | typeof $.call | typeof $.new>;\n\nexport interface ExampleOptions {\n  /** Import kind for the root node. */\n  importKind?: BindingKind;\n  /** Import name for the root node. */\n  importName?: string;\n  /** Setup to run before calling the example. */\n  importSetup?: MaybeFunc<\n    (\n      ctx: DollarTsDsl & {\n        /** The imported expression. */\n        node: TsDsl<ts.Expression>;\n      },\n    ) => TsDsl<ts.Expression>\n  >;\n  /** Module to import from. */\n  moduleName?: string;\n  /** Example request payload. */\n  payload?: MaybeFunc<(ctx: DollarTsDsl) => CallArgs | CallArgs[number]>;\n  /** Variable name for setup node. */\n  setupName?: string;\n}\n\nfunction accessChainToNode<T = AccessResult>(accessChain: NodeChain): T {\n  let result!: AccessResult;\n  accessChain.forEach((node, index) => {\n    if (index === 0) {\n      // assume correct node\n      result = node as typeof result;\n    } else {\n      result = result.attr(node.name);\n    }\n  });\n  return result as T;\n}\n\nfunction getAccessChainForNode(node: TsDsl): NodeChain {\n  const structuralChain = [...getStructuralChainForNode(node, new Set())];\n  const accessChain = structuralToAccessChain(structuralChain);\n  if (accessChain.length === 0) {\n    // I _think_ this should not happen, but it does and this fix works for now.\n    // I assume this will cause issues with imports in some cases, investigate\n    // when it actually happens.\n    return [node.clone()];\n  }\n  return accessChain.map((node) => node.clone());\n}\n\nfunction getScope(node: TsDsl): NodeScope {\n  return node.scope ?? 'value';\n}\n\nfunction getStructuralChainForNode(node: TsDsl, visited: Set<TsDsl>): NodeChain {\n  if (visited.has(node)) return [];\n  visited.add(node);\n\n  if (isStopNode(node)) return [];\n\n  if (node.structuralParents) {\n    for (const [parent] of node.structuralParents) {\n      if (getScope(parent) !== getScope(node)) continue;\n\n      const chain = getStructuralChainForNode(parent, visited);\n      if (chain.length > 0) return [...chain, node];\n    }\n  }\n\n  if (!node.root) return [];\n\n  return [node];\n}\n\nfunction isAccessorNode(node: TsDsl): boolean {\n  return (\n    node['~dsl'] === 'FieldTsDsl' ||\n    node['~dsl'] === 'GetterTsDsl' ||\n    node['~dsl'] === 'MethodTsDsl'\n  );\n}\n\nfunction isStopNode(node: TsDsl): boolean {\n  return node['~dsl'] === 'FuncTsDsl' || node['~dsl'] === 'TemplateTsDsl';\n}\n\n/**\n * Fold a structural chain to an access chain by removing\n * non-accessor nodes.\n */\nfunction structuralToAccessChain(structuralChain: NodeChain): NodeChain {\n  const accessChain: Array<TsDsl> = [];\n  structuralChain.forEach((node, index) => {\n    // assume first node is always included\n    if (index === 0) {\n      accessChain.push(node);\n    } else if (isAccessorNode(node)) {\n      accessChain.push(node);\n    }\n  });\n  return accessChain;\n}\n\nfunction transformAccessChain(accessChain: NodeChain, options: AccessOptions = {}): NodeChain {\n  return accessChain.map((node, index) => {\n    const transformedNode = options.transform?.(node, index, accessChain);\n    if (transformedNode) return transformedNode;\n    const accessNode = node.toAccessNode?.(node, options, {\n      chain: accessChain,\n      index,\n      isLeaf: index === accessChain.length - 1,\n      isRoot: index === 0,\n      length: accessChain.length,\n    });\n    if (accessNode) return accessNode;\n    if (index === 0) {\n      if (node['~dsl'] === 'ClassTsDsl') {\n        const nextNode = accessChain[index + 1];\n        if (nextNode && isAccessorNode(nextNode)) {\n          if ((nextNode as ReturnType<typeof $.field>).hasModifier('static')) {\n            return $(node.name);\n          }\n        }\n        return $.new(node.name).args();\n      }\n      return $(node.name);\n    }\n    return node;\n  });\n}\n\nexport class TsDslContext {\n  /**\n   * Build an expression for accessing the node.\n   *\n   * @param node - The node or symbol to build access for\n   * @param options - Access options\n   * @returns Expression for accessing the node\n   *\n   * @example\n   * ```ts\n   * ctx.access(node); // → Expression for accessing the node\n   * ```\n   */\n  access<T = AccessResult>(node: TsDsl | Symbol<TsDsl>, options?: AccessOptions): T {\n    const n = isSymbol(node) ? node.node : node;\n    if (!n) {\n      throw new Error(`Symbol ${node.name} is not resolved to a node.`);\n    }\n    const accessChain = getAccessChainForNode(n);\n    const finalChain = transformAccessChain(accessChain, options);\n    return accessChainToNode<T>(finalChain);\n  }\n\n  /**\n   * Build an example.\n   *\n   * @param node - The node to generate an example for\n   * @param options - Example options\n   * @returns Full example string\n   *\n   * @example\n   * ```ts\n   * ctx.example(node, { moduleName: 'my-sdk' }); // → Full example string\n   * ```\n   */\n  example(\n    node: TsDsl,\n    options?: ExampleOptions,\n    astOptions?: Parameters<typeof TypeScriptRenderer.astToString>[0],\n  ): string {\n    if (astOptions) {\n      return TypeScriptRenderer.astToString(astOptions);\n    }\n\n    options ||= {};\n\n    const accessChain = getAccessChainForNode(node);\n    if (options.importName) {\n      accessChain[0]!.name.set(options.importName);\n    }\n    const importNode = $(accessChain[0]!.name.toString()); // must store name before transform\n    const finalChain = transformAccessChain(accessChain, {\n      context: 'example',\n    });\n\n    const setupNode = options.importSetup\n      ? typeof options.importSetup === 'function'\n        ? options.importSetup({ $, node: importNode })\n        : options.importSetup\n      : (finalChain[0]! as TsDsl<ts.Expression>);\n    const setupName = options.setupName;\n    let payload = typeof options.payload === 'function' ? options.payload({ $ }) : options.payload;\n    payload = payload instanceof Array ? payload : payload ? [payload] : [];\n\n    let nodes: Array<TsDsl> = [];\n    if (setupName) {\n      nodes = [\n        $.const(setupName).assign(setupNode),\n        $.await(accessChainToNode([$(setupName), ...finalChain.slice(1)]).call(...payload)),\n      ];\n    } else {\n      nodes = [$.await(accessChainToNode([setupNode, ...finalChain.slice(1)]).call(...payload))];\n    }\n\n    const localName = importNode.name.toString();\n    return TypeScriptRenderer.astToString({\n      imports: [\n        [\n          {\n            imports:\n              !options.importKind || options.importKind === 'named'\n                ? [\n                    {\n                      isTypeOnly: false,\n                      localName,\n                      sourceName: localName,\n                    },\n                  ]\n                : [],\n            isTypeOnly: false,\n            kind: options.importKind ?? 'named',\n            localName: options.importKind !== 'named' ? localName : undefined,\n            modulePath: options.moduleName ?? 'your-package',\n          },\n        ],\n      ],\n      nodes,\n      trailingNewline: false,\n    });\n  }\n}\n\nexport const ctx = new TsDslContext();\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport type { MaybeArray } from '@hey-api/types';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\nimport type { TsDslContext } from '../utils/context';\nimport { ctx } from '../utils/context';\n\ntype DocMaybeLazy<T> = ((ctx: TsDslContext) => T) | T;\nexport type DocFn = (d: DocTsDsl) => void;\nexport type DocLines = DocMaybeLazy<MaybeArray<string>>;\n\nexport class DocTsDsl extends TsDsl<ts.Node> {\n  readonly '~dsl' = 'DocTsDsl';\n\n  protected _lines: Array<DocLines> = [];\n\n  constructor(lines?: DocLines, fn?: DocFn) {\n    super();\n    if (lines) this.add(lines);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  add(lines: DocLines): this {\n    this._lines.push(lines);\n    return this;\n  }\n\n  apply<T extends ts.Node>(node: T): T {\n    const lines = this._lines.reduce((lines: Array<string>, line: DocLines) => {\n      if (typeof line === 'function') line = line(ctx);\n      for (const l of typeof line === 'string' ? [line] : line) {\n        if (l || l === '') lines.push(l);\n      }\n      return lines;\n    }, []);\n    if (!lines.length) return node;\n\n    const jsdocTexts = lines.map((line) => ts.factory.createJSDocText(`${line}\\n`));\n\n    const jsdoc = ts.factory.createJSDocComment(ts.factory.createNodeArray(jsdocTexts), undefined);\n\n    const cleanedJsdoc = ts\n      .createPrinter()\n      .printNode(\n        ts.EmitHint.Unspecified,\n        jsdoc,\n        node.getSourceFile?.() ?? ts.createSourceFile('', '', ts.ScriptTarget.Latest),\n      )\n      .replace('/*', '')\n      .replace('*  */', '');\n\n    ts.addSyntheticLeadingComment(node, ts.SyntaxKind.MultiLineCommentTrivia, cleanedJsdoc, true);\n\n    return node;\n  }\n\n  override toAst(): ts.Node {\n    // this class does not build a standalone node;\n    // it modifies other nodes via `apply()`.\n    // Return a dummy comment node for compliance.\n    return this.$node(new IdTsDsl(''));\n  }\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { DocFn, DocLines } from '../layout/doc';\nimport { DocTsDsl } from '../layout/doc';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface DocMethods extends Node {\n  $docs<T extends ts.Node>(node: T): T;\n  doc(lines?: DocLines, fn?: DocFn): this;\n}\n\nexport function DocMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Doc extends Base {\n    private _doc?: DocTsDsl;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected doc(lines?: DocLines, fn?: DocFn): this {\n      this._doc = new DocTsDsl(lines, fn);\n      return this;\n    }\n\n    protected $docs<T extends ts.Node>(node: T): T {\n      return this._doc ? this._doc.apply(node) : node;\n    }\n  }\n\n  return Doc as unknown as MixinCtor<TBase, DocMethods>;\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport type Modifiers = {\n  /**\n   * Checks if the specified modifier is present.\n   *\n   * @param modifier - The modifier to check.\n   * @returns True if the modifier is present, false otherwise.\n   */\n  hasModifier(modifier: Modifier): boolean;\n  modifiers: Array<ts.Modifier>;\n};\n\ntype Modifier =\n  | 'abstract'\n  | 'async'\n  | 'const'\n  | 'declare'\n  | 'default'\n  | 'export'\n  | 'override'\n  | 'private'\n  | 'protected'\n  | 'public'\n  | 'readonly'\n  | 'static';\n\nexport interface ModifierMethods extends Modifiers {\n  /**\n   * Adds a modifier of the specified kind to the modifiers list if the condition is true.\n   *\n   * @param modifier - The modifier to add.\n   * @param condition - Whether to add the modifier.\n   * @returns The parent node for chaining.\n   */\n  _m(modifier: Modifier, condition: boolean): this;\n}\n\nfunction modifierToKind(modifier: Modifier): ts.ModifierSyntaxKind {\n  switch (modifier) {\n    case 'abstract':\n      return ts.SyntaxKind.AbstractKeyword;\n    case 'async':\n      return ts.SyntaxKind.AsyncKeyword;\n    case 'const':\n      return ts.SyntaxKind.ConstKeyword;\n    case 'declare':\n      return ts.SyntaxKind.DeclareKeyword;\n    case 'default':\n      return ts.SyntaxKind.DefaultKeyword;\n    case 'export':\n      return ts.SyntaxKind.ExportKeyword;\n    case 'override':\n      return ts.SyntaxKind.OverrideKeyword;\n    case 'private':\n      return ts.SyntaxKind.PrivateKeyword;\n    case 'protected':\n      return ts.SyntaxKind.ProtectedKeyword;\n    case 'public':\n      return ts.SyntaxKind.PublicKeyword;\n    case 'readonly':\n      return ts.SyntaxKind.ReadonlyKeyword;\n    case 'static':\n      return ts.SyntaxKind.StaticKeyword;\n  }\n}\n\nfunction ModifiersMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Modifiers extends Base {\n    protected modifiers: Array<ts.Modifier> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected hasModifier(modifier: Modifier): boolean {\n      const kind = modifierToKind(modifier);\n      return Boolean(this.modifiers.find((mod) => mod.kind === kind));\n    }\n\n    protected _m(modifier: Modifier, condition: boolean): this {\n      if (condition) {\n        const kind = modifierToKind(modifier);\n        this.modifiers.push(ts.factory.createModifier(kind));\n      }\n      return this;\n    }\n  }\n\n  return Modifiers as unknown as MixinCtor<TBase, ModifierMethods>;\n}\n\nexport interface AbstractMethods extends Modifiers {\n  /**\n   * Adds the `abstract` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  abstract(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds an `abstract` modifier to a node.\n */\nexport function AbstractMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Abstract extends Mixed {\n    protected abstract(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('abstract', cond);\n    }\n  }\n\n  return Abstract as unknown as MixinCtor<TBase, AbstractMethods>;\n}\n\nexport interface AsyncMethods extends Modifiers {\n  /**\n   * Adds the `async` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  async(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds an `async` modifier to a node.\n */\nexport function AsyncMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Async extends Mixed {\n    protected async(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('async', cond);\n    }\n  }\n\n  return Async as unknown as MixinCtor<TBase, AsyncMethods>;\n}\n\nexport interface ConstMethods extends Modifiers {\n  /**\n   * Adds the `const` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  const(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `const` modifier to a node.\n */\nexport function ConstMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Const extends Mixed {\n    protected const(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('const', cond);\n    }\n  }\n\n  return Const as unknown as MixinCtor<TBase, ConstMethods>;\n}\n\nexport interface DeclareMethods extends Modifiers {\n  /**\n   * Adds the `declare` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  declare(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `declare` modifier to a node.\n */\nexport function DeclareMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Declare extends Mixed {\n    protected declare(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('declare', cond);\n    }\n  }\n\n  return Declare as unknown as MixinCtor<TBase, DeclareMethods>;\n}\n\nexport interface DefaultMethods extends Modifiers {\n  /**\n   * Adds the `default` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  default(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `default` modifier to a node.\n */\nexport function DefaultMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Default extends Mixed {\n    /**\n     * Adds the `default` keyword modifier if the condition is true.\n     *\n     * @param condition - Whether to add the modifier (default: true).\n     * @returns The target object for chaining.\n     */\n    protected default(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('default', cond);\n    }\n  }\n\n  return Default as unknown as MixinCtor<TBase, DefaultMethods>;\n}\n\nexport interface ExportMethods extends Modifiers {\n  /**\n   * Adds the `export` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  export(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds an `export` modifier to a node.\n */\nexport function ExportMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Export extends Mixed {\n    /**\n     * Adds the `export` keyword modifier if the condition is true.\n     *\n     * @param condition - Whether to add the modifier (default: true).\n     * @returns The target object for chaining.\n     */\n    protected export(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      this.exported = cond;\n      // TODO: remove this side-effect once planner handles exported flag\n      if (this.symbol) this.symbol.setExported(cond);\n      return this._m('export', cond);\n    }\n  }\n\n  return Export as unknown as MixinCtor<TBase, ExportMethods>;\n}\n\nexport interface OverrideMethods extends Modifiers {\n  /**\n   * Adds the `override` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  override(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds an `override` modifier to a node.\n */\nexport function OverrideMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Override extends Mixed {\n    protected override(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('override', cond);\n    }\n  }\n\n  return Override as unknown as MixinCtor<TBase, OverrideMethods>;\n}\n\nexport interface PrivateMethods extends Modifiers {\n  /**\n   * Adds the `private` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  private(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `private` modifier to a node.\n */\nexport function PrivateMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Private extends Mixed {\n    protected private(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('private', cond);\n    }\n  }\n\n  return Private as unknown as MixinCtor<TBase, PrivateMethods>;\n}\n\nexport interface ProtectedMethods extends Modifiers {\n  /**\n   * Adds the `protected` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  protected(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `protected` modifier to a node.\n */\nexport function ProtectedMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Protected extends Mixed {\n    protected protected(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('protected', cond);\n    }\n  }\n\n  return Protected as unknown as MixinCtor<TBase, ProtectedMethods>;\n}\n\nexport interface PublicMethods extends Modifiers {\n  /**\n   * Adds the `public` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  public(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `public` modifier to a node.\n */\nexport function PublicMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Public extends Mixed {\n    protected public(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('public', cond);\n    }\n  }\n\n  return Public as unknown as MixinCtor<TBase, PublicMethods>;\n}\n\nexport interface ReadonlyMethods extends Modifiers {\n  /**\n   * Adds the `readonly` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  readonly(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `readonly` modifier to a node.\n */\nexport function ReadonlyMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Readonly extends Mixed {\n    protected readonly(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('readonly', cond);\n    }\n  }\n\n  return Readonly as unknown as MixinCtor<TBase, ReadonlyMethods>;\n}\n\nexport interface StaticMethods extends Modifiers {\n  /**\n   * Adds the `static` keyword modifier if the condition is true.\n   *\n   * @param condition - Whether to add the modifier (default: true).\n   * @returns The target object for chaining.\n   */\n  static(condition?: boolean): this;\n}\n\n/**\n * Mixin that adds a `static` modifier to a node.\n */\nexport function StaticMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  const Mixed = ModifiersMixin(Base as BaseCtor<T>);\n\n  abstract class Static extends Mixed {\n    protected static(condition?: boolean): this {\n      const cond = arguments.length === 0 ? true : Boolean(condition);\n      return this._m('static', cond);\n    }\n  }\n\n  return Static as unknown as MixinCtor<TBase, StaticMethods>;\n}\n","import type { AnalysisContext, NodeName, NodeScope, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nexport type TypeParamExpr = NodeName | boolean | MaybeTsDsl<TypeTsDsl>;\n\nconst Mixed = TsDsl<ts.TypeParameterDeclaration>;\n\nexport class TypeParamTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeParamTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected constraint?: Ref<TypeParamExpr>;\n  protected defaultValue?: Ref<TypeParamExpr>;\n\n  constructor(name?: NodeName, fn?: (name: TypeParamTsDsl) => void) {\n    super();\n    if (name) this.name.set(name);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.analyze(this.constraint);\n    ctx.analyze(this.defaultValue);\n  }\n\n  default(value: TypeParamExpr): this {\n    this.defaultValue = ref(value);\n    return this;\n  }\n\n  extends(constraint: TypeParamExpr): this {\n    this.constraint = ref(constraint);\n    return this;\n  }\n\n  override toAst() {\n    const name = this.name.toString();\n    if (!name) throw new Error('Missing type name');\n    return ts.factory.createTypeParameterDeclaration(\n      undefined,\n      this.$node(this.name) as ts.Identifier,\n      this.$type(this.constraint),\n      this.$type(this.defaultValue),\n    );\n  }\n}\n","import type { AnalysisContext, Node, NodeName } from '@hey-api/codegen-core';\nimport { isRef, isSymbol } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TypeParamTsDsl } from '../type/param';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface TypeParamsMethods extends Node {\n  /** Returns the type parameters as an array of ts.TypeParameterDeclaration nodes. */\n  $generics(): ReadonlyArray<ts.TypeParameterDeclaration> | undefined;\n  /** Adds a single type parameter (e.g. `T` in `Array<T>`). */\n  generic(...args: ConstructorParameters<typeof TypeParamTsDsl>): this;\n  /** Adds type parameters (e.g. `Map<string, T>`). */\n  generics(...args: ReadonlyArray<NodeName | MaybeTsDsl<TypeParamTsDsl>>): this;\n}\n\nexport function TypeParamsMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class TypeParams extends Base {\n    protected _generics: Array<MaybeTsDsl<TypeParamTsDsl>> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      for (const g of this._generics) {\n        ctx.analyze(g);\n      }\n    }\n\n    protected generic(...args: ConstructorParameters<typeof TypeParamTsDsl>): this {\n      const g = new TypeParamTsDsl(...args);\n      this._generics.push(g);\n      return this;\n    }\n\n    protected generics(...args: ReadonlyArray<NodeName | MaybeTsDsl<TypeParamTsDsl>>): this {\n      for (let arg of args) {\n        if (typeof arg === 'string' || typeof arg === 'number' || isSymbol(arg) || isRef(arg)) {\n          arg = new TypeParamTsDsl(arg);\n        }\n        this._generics.push(arg);\n      }\n      return this;\n    }\n\n    protected $generics(): ReadonlyArray<ts.TypeParameterDeclaration> | undefined {\n      return this.$node(this._generics);\n    }\n  }\n\n  return TypeParams as unknown as MixinCtor<TBase, TypeParamsMethods>;\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface OptionalMethods extends Node {\n  _optional?: boolean;\n  /** Marks the node as optional when the condition is true. */\n  optional(condition?: boolean): this;\n  /** Marks the node as required when the condition is true. */\n  required(condition?: boolean): this;\n}\n\nexport function OptionalMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Optional extends Base {\n    protected _optional?: boolean;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected optional(condition?: boolean): this {\n      this._optional = arguments.length === 0 ? true : Boolean(condition);\n      return this;\n    }\n\n    protected required(condition?: boolean): this {\n      this._optional = arguments.length === 0 ? false : !condition;\n      return this;\n    }\n  }\n\n  return Optional as unknown as MixinCtor<TBase, OptionalMethods>;\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport type ValueExpr = string | MaybeTsDsl<ts.Expression>;\n\nexport interface ValueMethods extends Node {\n  $value(): ts.Expression | undefined;\n  /** Sets the initializer expression (e.g. `= expr`). */\n  assign(expr: ValueExpr): this;\n}\n\nexport function ValueMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Value extends Base {\n    protected value?: ValueExpr;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      ctx.analyze(this.value);\n    }\n\n    protected assign(expr: ValueExpr): this {\n      this.value = expr;\n      return this;\n    }\n\n    protected $value(): ts.Expression | undefined {\n      return this.$node(this.value);\n    }\n  }\n\n  return Value as unknown as MixinCtor<TBase, ValueMethods>;\n}\n","import ts from 'typescript';\n\nimport { TsDsl } from './base';\n\nexport class TokenTsDsl<K extends ts.SyntaxKind = never> extends TsDsl<ts.Token<K>> {\n  readonly '~dsl' = 'TokenTsDsl';\n\n  protected _kind?: K;\n\n  /** Sets the token kind */\n  kind(kind: K): this {\n    this._kind = kind;\n    return this;\n  }\n\n  /** Creates `-` */\n  minus(): TokenTsDsl<ts.SyntaxKind.MinusToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.MinusToken>).kind(ts.SyntaxKind.MinusToken);\n  }\n\n  /** Creates `?` (optional) */\n  optional(): TokenTsDsl<ts.SyntaxKind.QuestionToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.QuestionToken>).kind(ts.SyntaxKind.QuestionToken);\n  }\n\n  /** Creates `+` */\n  plus(): TokenTsDsl<ts.SyntaxKind.PlusToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.PlusToken>).kind(ts.SyntaxKind.PlusToken);\n  }\n\n  /** Creates `?.` (optional chaining token) */\n  questionDot(): TokenTsDsl<ts.SyntaxKind.QuestionDotToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.QuestionDotToken>).kind(\n      ts.SyntaxKind.QuestionDotToken,\n    );\n  }\n\n  /** Creates `readonly` */\n  readonly(): TokenTsDsl<ts.SyntaxKind.ReadonlyKeyword> {\n    return (this as TokenTsDsl<ts.SyntaxKind.ReadonlyKeyword>).kind(ts.SyntaxKind.ReadonlyKeyword);\n  }\n\n  /** Creates `...` (spread / rest) */\n  spread(): TokenTsDsl<ts.SyntaxKind.DotDotDotToken> {\n    return (this as TokenTsDsl<ts.SyntaxKind.DotDotDotToken>).kind(ts.SyntaxKind.DotDotDotToken);\n  }\n\n  override toAst(): ts.Token<K> {\n    this.$validate();\n    // @ts-expect-error\n    return ts.factory.createToken(this._kind);\n  }\n\n  $validate(): asserts this is this & {\n    _kind: K;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Token missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._kind) missing.push('.kind()');\n    return missing;\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n}\n","import type { AnalysisContext, Node, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport type { BaseCtor, MixinCtor } from './types';\n\ntype Arg = NodeName | MaybeTsDsl<TypeTsDsl>;\n\nexport interface TypeArgsMethods extends Node {\n  /** Returns the type arguments as an array of ts.TypeNode nodes. */\n  $generics(): ReadonlyArray<ts.TypeNode> | undefined;\n  /** Adds a single type argument (e.g. `string` in `Foo<string>`). */\n  generic(arg: Arg): this;\n  /** Adds type arguments (e.g. `Map<string, number>`). */\n  generics(...args: ReadonlyArray<Arg>): this;\n}\n\nexport function TypeArgsMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class TypeArgs extends Base {\n    protected _generics: Array<Ref<Arg>> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      for (const g of this._generics) {\n        ctx.analyze(g);\n      }\n    }\n\n    protected generic(arg: Arg): this {\n      this._generics.push(ref(arg));\n      return this;\n    }\n\n    protected generics(...args: ReadonlyArray<Arg>): this {\n      this._generics.push(...args.map((a) => ref(a)));\n      return this;\n    }\n\n    protected $generics(): ReadonlyArray<ts.TypeNode> | undefined {\n      return this.$type(this._generics);\n    }\n  }\n\n  return TypeArgs as unknown as MixinCtor<TBase, TypeArgsMethods>;\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport { f } from '../utils/factories';\nimport type { BaseCtor, DropFirst, MixinCtor } from './types';\n\nexport interface TypeExprMethods extends Node {\n  /** Creates an indexed-access type (e.g. `Foo<T>[K]`). */\n  idx(\n    this: Parameters<typeof f.type.idx>[0],\n    ...args: DropFirst<Parameters<typeof f.type.idx>>\n  ): ReturnType<typeof f.type.idx>;\n  /** Shorthand: builds `keyof T`. */\n  keyof(this: MaybeTsDsl<TypeTsDsl>): ReturnType<typeof f.type.operator>;\n  /** Shorthand: builds `readonly T`. */\n  readonly(this: MaybeTsDsl<TypeTsDsl>): ReturnType<typeof f.type.operator>;\n  /** Create a TypeExpr node representing ReturnType<this>. */\n  returnType(\n    this: Parameters<typeof f.type.query>[0],\n    ...args: DropFirst<Parameters<typeof f.type.query>>\n  ): ReturnType<typeof f.type.expr>;\n  /** Create a TypeOfExpr node representing typeof this. */\n  typeofExpr(\n    this: Parameters<typeof f.typeofExpr>[0],\n    ...args: DropFirst<Parameters<typeof f.typeofExpr>>\n  ): ReturnType<typeof f.typeofExpr>;\n  /** Create a TypeQuery node representing typeof this. */\n  typeofType(\n    this: Parameters<typeof f.type.query>[0],\n    ...args: DropFirst<Parameters<typeof f.type.query>>\n  ): ReturnType<typeof f.type.query>;\n  /** Shorthand: builds `unique T`. */\n  unique(this: MaybeTsDsl<TypeTsDsl>): ReturnType<typeof f.type.operator>;\n}\n\nexport function TypeExprMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class TypeExpr extends Base {\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected idx(\n      this: Parameters<typeof f.type.idx>[0],\n      ...args: DropFirst<Parameters<typeof f.type.idx>>\n    ): ReturnType<typeof f.type.idx> {\n      return f.type.idx(this, ...args);\n    }\n\n    protected keyof(this: TypeTsDsl): ReturnType<typeof f.type.operator> {\n      return f.type.operator().keyof(this);\n    }\n\n    protected readonly(this: TypeTsDsl): ReturnType<typeof f.type.operator> {\n      return f.type.operator().readonly(this);\n    }\n\n    protected returnType(\n      this: Parameters<typeof f.type.query>[0],\n      ...args: DropFirst<Parameters<typeof f.type.query>>\n    ): ReturnType<typeof f.type.expr> {\n      return f.type.expr('ReturnType').generic(f.type.query(this, ...args));\n    }\n\n    protected typeofExpr(\n      this: Parameters<typeof f.typeofExpr>[0],\n      ...args: DropFirst<Parameters<typeof f.typeofExpr>>\n    ): ReturnType<typeof f.typeofExpr> {\n      return f.typeofExpr(this, ...args);\n    }\n\n    protected typeofType(\n      this: Parameters<typeof f.type.query>[0],\n      ...args: DropFirst<Parameters<typeof f.type.query>>\n    ): ReturnType<typeof f.type.query> {\n      return f.type.query(this, ...args);\n    }\n\n    protected unique(this: TypeTsDsl): ReturnType<typeof f.type.operator> {\n      return f.type.operator().unique(this);\n    }\n  }\n\n  return TypeExpr as unknown as MixinCtor<TBase, TypeExprMethods>;\n}\n","import type { AnalysisContext, NodeName, NodeScope, Ref } from '@hey-api/codegen-core';\nimport { isRef, ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { TypeExprMixin } from '../mixins/type-expr';\n\ntype Base = NodeName | MaybeTsDsl<ts.EntityName>;\ntype Right = NodeName | ts.Identifier;\n\nconst Mixed = TypeExprMixin(TsDsl<ts.QualifiedName>);\n\nexport class TypeAttrTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeAttrTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _base?: Ref<Base>;\n  protected _right!: Ref<Right>;\n\n  constructor(base: Base | Ref<Base>, right: string | ts.Identifier);\n  constructor(right: Right);\n  constructor(base: Base | Ref<Base>, right?: Right) {\n    super();\n    if (right) {\n      this.base(base);\n      this.right(right);\n    } else {\n      this.base();\n      this.right(base as Right);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._base);\n    ctx.analyze(this._right);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  base(base?: Base | Ref<Base>): this {\n    if (isRef(base)) {\n      this._base = base;\n    } else {\n      this._base = base ? ref(base) : undefined;\n    }\n    return this;\n  }\n\n  right(right: Right): this {\n    this._right = ref(right);\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    const left = this.$node(this._base);\n    if (!ts.isEntityName(left)) {\n      throw new Error('TypeAttrTsDsl: base must be an EntityName');\n    }\n    return ts.factory.createQualifiedName(left, this.$node(this._right) as ts.Identifier);\n  }\n\n  $validate(): asserts this is this & {\n    _base: Ref<Base>;\n    _right: Ref<Right>;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Type attribute missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._base) missing.push('.base()');\n    if (!this._right) missing.push('.right()');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeName, NodeScope, Ref } from '@hey-api/codegen-core';\nimport { isNode, ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { TypeArgsMixin } from '../mixins/type-args';\nimport { TypeExprMixin } from '../mixins/type-expr';\nimport { f } from '../utils/factories';\nimport { TypeAttrTsDsl } from './attr';\n\nexport type TypeExprExpr = NodeName | TypeAttrTsDsl;\nexport type TypeExprFn = (t: TypeExprTsDsl) => void;\nexport type TypeExprCtor = (nameOrFn?: NodeName | TypeExprFn, fn?: TypeExprFn) => TypeExprTsDsl;\n\nconst Mixed = TypeArgsMixin(TypeExprMixin(TsDsl<ts.TypeReferenceNode>));\n\nexport class TypeExprTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeExprTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _exprInput?: Ref<TypeExprExpr>;\n\n  constructor();\n  constructor(fn: TypeExprFn);\n  constructor(name: NodeName);\n  constructor(name: NodeName, fn?: TypeExprFn);\n  constructor(name?: NodeName | TypeExprFn, fn?: TypeExprFn) {\n    super();\n    if (typeof name === 'function') {\n      name(this);\n    } else {\n      this._exprInput = name ? ref(name) : undefined;\n      fn?.(this);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._exprInput);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Accesses a nested type (e.g. `Foo.Bar`). */\n  attr(right: string | ts.Identifier | TypeAttrTsDsl): this {\n    this._exprInput = isNode(right)\n      ? ref(right.base(this._exprInput))\n      : ref(new TypeAttrTsDsl(this._exprInput!, right));\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    return ts.factory.createTypeReferenceNode(\n      this.$type(this._exprInput) as ts.EntityName,\n      this.$generics(),\n    );\n  }\n\n  $validate(): asserts this is this & {\n    _exprInput: Ref<TypeExprExpr>;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Type expression missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._exprInput) missing.push('name or .attr()');\n    return missing;\n  }\n}\n\nf.type.expr.set(\n  (...args) => new TypeExprTsDsl(...(args as ConstructorParameters<typeof TypeExprTsDsl>)),\n);\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl, TypeTsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  ReadonlyMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { OptionalMixin } from '../mixins/optional';\nimport { ValueMixin } from '../mixins/value';\nimport { TokenTsDsl } from '../token';\nimport { TypeExprTsDsl } from '../type/expr';\nimport { safeAccessorName } from '../utils/name';\n\nexport type FieldType = NodeName | TypeTsDsl;\n\nconst Mixed = DecoratorMixin(\n  DocMixin(\n    OptionalMixin(\n      PrivateMixin(\n        ProtectedMixin(\n          PublicMixin(ReadonlyMixin(StaticMixin(ValueMixin(TsDsl<ts.PropertyDeclaration>)))),\n        ),\n      ),\n    ),\n  ),\n);\n\nexport class FieldTsDsl extends Mixed {\n  readonly '~dsl' = 'FieldTsDsl';\n  override readonly nameSanitizer = safeAccessorName;\n\n  protected _type?: TypeTsDsl;\n\n  constructor(name: NodeName, fn?: (f: FieldTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.analyze(this._type);\n  }\n\n  /** Sets the field type. */\n  type(type: FieldType): this {\n    this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  override toAst() {\n    const node = ts.factory.createPropertyDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      this.$node(this.name) as ts.PropertyName,\n      this._optional ? this.$node(new TokenTsDsl().optional()) : undefined,\n      this.$type(this._type),\n      this.$value(),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.Statement>;\n\nexport class StmtTsDsl extends Mixed {\n  readonly '~dsl' = 'StmtTsDsl';\n\n  protected _inner: ts.Expression | ts.Statement | TsDsl<any>;\n\n  constructor(inner: ts.Expression | ts.Statement | TsDsl<any>) {\n    super();\n    this._inner = inner;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._inner);\n  }\n\n  override toAst() {\n    const node = this.$node(this._inner);\n    return ts.isStatement(node) ? node : ts.factory.createExpressionStatement(node);\n  }\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { StmtTsDsl } from '../stmt/stmt';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport type DoExpr = MaybeTsDsl<ts.Expression | ts.Statement>;\n\nexport interface DoMethods extends Node {\n  /** Renders the collected `.do()` calls into an array of `Statement` nodes. */\n  $do(): ReadonlyArray<ts.Statement>;\n  _do: Array<DoExpr>;\n  /** Adds one or more expressions/statements to the body. */\n  do(...items: ReadonlyArray<DoExpr>): this;\n}\n\n/**\n * Adds `.do()` for appending statements or expressions to a body.\n */\nexport function DoMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Do extends Base {\n    protected _do: Array<DoExpr> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      ctx.pushScope();\n      try {\n        for (const item of this._do) {\n          ctx.analyze(item);\n        }\n      } finally {\n        ctx.popScope();\n      }\n    }\n\n    protected do(...items: ReadonlyArray<DoExpr>): this {\n      this._do.push(...items);\n      return this;\n    }\n\n    protected $do(): ReadonlyArray<ts.Statement> {\n      return this.$node(this._do.map((item) => new StmtTsDsl(item)));\n    }\n  }\n\n  return Do as unknown as MixinCtor<TBase, DoMethods>;\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport type { MaybeArray } from '@hey-api/types';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\nimport { TokenTsDsl } from '../token';\n\nconst Mixed = TsDsl<ts.BindingName>;\n\n/**\n * Builds binding patterns (e.g. `{ foo, bar }`, `[a, b, ...rest]`).\n */\nexport class PatternTsDsl extends Mixed {\n  readonly '~dsl' = 'PatternTsDsl';\n\n  protected pattern?:\n    | { kind: 'array'; values: ReadonlyArray<string> }\n    | { kind: 'object'; values: Record<string, string> };\n  protected _spread?: string;\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Defines an array pattern (e.g. `[a, b, c]`). */\n  array(...props: ReadonlyArray<string> | [ReadonlyArray<string>]): this {\n    const values = props[0] instanceof Array ? [...props[0]] : (props as ReadonlyArray<string>);\n    this.pattern = { kind: 'array', values };\n    return this;\n  }\n\n  /** Defines an object pattern (e.g. `{ a, b: alias }`). */\n  object(...props: ReadonlyArray<MaybeArray<string> | Record<string, string>>): this {\n    const entries: Record<string, string> = {};\n    for (const p of props) {\n      if (typeof p === 'string') entries[p] = p;\n      else if (p instanceof Array) for (const n of p) entries[n] = n;\n      else Object.assign(entries, p);\n    }\n    this.pattern = { kind: 'object', values: entries };\n    return this;\n  }\n\n  /** Adds a spread element (e.g. `...rest`, `...options`, `...args`). */\n  spread(name: string): this {\n    this._spread = name;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n\n    if (this.pattern.kind === 'object') {\n      const elements = Object.entries(this.pattern.values).map(([key, alias]) =>\n        key === alias\n          ? ts.factory.createBindingElement(undefined, undefined, key, undefined)\n          : ts.factory.createBindingElement(undefined, key, alias, undefined),\n      );\n      const spread = this.createSpread();\n      if (spread) elements.push(spread);\n      return ts.factory.createObjectBindingPattern(elements);\n    }\n\n    if (this.pattern.kind === 'array') {\n      const elements = this.pattern.values.map((p) =>\n        ts.factory.createBindingElement(undefined, undefined, p, undefined),\n      );\n      const spread = this.createSpread();\n      if (spread) elements.push(spread);\n      return ts.factory.createArrayBindingPattern(elements);\n    }\n\n    throw new Error('PatternTsDsl requires object() or array() pattern');\n  }\n\n  $validate(): asserts this is this & {\n    pattern:\n      | { kind: 'array'; values: ReadonlyArray<string> }\n      | { kind: 'object'; values: Record<string, string> };\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Binding pattern missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this.pattern) missing.push('.array() or .object()');\n    return missing;\n  }\n\n  private createSpread(): ts.BindingElement | undefined {\n    return this._spread\n      ? ts.factory.createBindingElement(\n          this.$node(new TokenTsDsl().spread()),\n          undefined,\n          this.$node(new IdTsDsl(this._spread)),\n        )\n      : undefined;\n  }\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type { MaybeArray } from '@hey-api/types';\nimport type ts from 'typescript';\n\nimport { PatternTsDsl } from '../decl/pattern';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface PatternMethods extends Node {\n  /** Renders the pattern into a `BindingName`. */\n  $pattern(): ts.BindingName | undefined;\n  /** Defines an array binding pattern. */\n  array(...props: ReadonlyArray<string> | [ReadonlyArray<string>]): this;\n  /** Defines an object binding pattern. */\n  object(...props: ReadonlyArray<MaybeArray<string> | Record<string, string>>): this;\n  /** Adds a spread element (e.g. `...args`, `...options`) to the pattern. */\n  spread(name: string): this;\n}\n\n/**\n * Mixin providing `.array()`, `.object()`, and `.spread()` methods for defining destructuring patterns.\n */\nexport function PatternMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Pattern extends Base {\n    protected pattern?: PatternTsDsl;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      ctx.analyze(this.pattern);\n    }\n\n    protected array(...props: ReadonlyArray<string> | [ReadonlyArray<string>]): this {\n      (this.pattern ??= new PatternTsDsl()).array(...props);\n      return this;\n    }\n\n    protected object(...props: ReadonlyArray<MaybeArray<string> | Record<string, string>>): this {\n      (this.pattern ??= new PatternTsDsl()).object(...props);\n      return this;\n    }\n\n    /** Adds a spread element (e.g. `...args`, `...options`) to the pattern. */\n    protected spread(name: string): this {\n      (this.pattern ??= new PatternTsDsl()).spread(name);\n      return this;\n    }\n\n    /** Renders the pattern into a `BindingName`. */\n    protected $pattern(): ts.BindingName | undefined {\n      if (!this.pattern) return;\n      return this.$node(this.pattern);\n    }\n  }\n\n  return Pattern as unknown as MixinCtor<TBase, PatternMethods>;\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl, TypeTsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { OptionalMixin } from '../mixins/optional';\nimport { PatternMixin } from '../mixins/pattern';\nimport { ValueMixin } from '../mixins/value';\nimport { TokenTsDsl } from '../token';\nimport { TypeExprTsDsl } from '../type/expr';\n\nexport type ParamCtor = (\n  name: NodeName | ((p: ParamTsDsl) => void),\n  fn?: (p: ParamTsDsl) => void,\n) => ParamTsDsl;\n\nconst Mixed = DecoratorMixin(\n  OptionalMixin(PatternMixin(ValueMixin(TsDsl<ts.ParameterDeclaration>))),\n);\n\nexport class ParamTsDsl extends Mixed {\n  readonly '~dsl' = 'ParamTsDsl';\n\n  protected _type?: TypeTsDsl;\n\n  constructor(name: NodeName | ((p: ParamTsDsl) => void), fn?: (p: ParamTsDsl) => void) {\n    super();\n    if (typeof name === 'function') {\n      name(this);\n    } else {\n      this.name.set(name);\n      fn?.(this);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.analyze(this._type);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Sets the parameter type. */\n  type(type: string | TypeTsDsl): this {\n    this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    return ts.factory.createParameterDeclaration(\n      this.$decorators(),\n      undefined,\n      this.$pattern() ?? this.name.toString(),\n      this._optional ? this.$node(new TokenTsDsl().optional()) : undefined,\n      this.$type(this._type),\n      this.$value(),\n    );\n  }\n\n  $validate(): asserts this {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Parameter missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this.$pattern() && !this.name.toString())\n      missing.push('name or pattern (.array()/.object())');\n    return missing;\n  }\n}\n","import type { AnalysisContext, Node, NodeName } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport type { ParamCtor } from '../decl/param';\nimport { ParamTsDsl } from '../decl/param';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface ParamMethods extends Node {\n  /** Renders the parameters into an array of `ParameterDeclaration`s. */\n  $params(): ReadonlyArray<ts.ParameterDeclaration>;\n  /** Adds a parameter. */\n  param(...args: Parameters<ParamCtor>): this;\n  /** Adds multiple parameters. */\n  params(...params: ReadonlyArray<MaybeTsDsl<ts.ParameterDeclaration>>): this;\n}\n\nexport function ParamMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Param extends Base {\n    protected _params: Array<MaybeTsDsl<ts.ParameterDeclaration>> = [];\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      for (const param of this._params) {\n        ctx.analyze(param);\n      }\n    }\n\n    protected param(\n      name: NodeName | ((p: ParamTsDsl) => void),\n      fn?: (p: ParamTsDsl) => void,\n    ): this {\n      const p = new ParamTsDsl(name, fn);\n      this._params.push(p);\n      return this;\n    }\n\n    protected params(...params: ReadonlyArray<MaybeTsDsl<ts.ParameterDeclaration>>): this {\n      this._params.push(...params);\n      return this;\n    }\n\n    protected $params(): ReadonlyArray<ts.ParameterDeclaration> {\n      return this.$node(this._params);\n    }\n  }\n\n  return Param as unknown as MixinCtor<TBase, ParamMethods>;\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface LayoutMethods extends Node {\n  /** Computes whether output should be multiline based on layout setting and element count. */\n  $multiline(count: number): boolean;\n  /** Sets automatic line output with optional threshold (default: 3). */\n  auto(threshold?: number): this;\n  /** Sets single line output. */\n  inline(): this;\n  /** Sets multi line output. */\n  pretty(): this;\n}\n\nexport function LayoutMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Layout extends Base {\n    protected static readonly DEFAULT_THRESHOLD = 3;\n    protected layout: boolean | number | undefined;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected auto(threshold: number = Layout.DEFAULT_THRESHOLD): this {\n      this.layout = threshold;\n      return this;\n    }\n\n    protected inline(): this {\n      this.layout = false;\n      return this;\n    }\n\n    protected pretty(): this {\n      this.layout = true;\n      return this;\n    }\n\n    protected $multiline(count: number): boolean {\n      if (this.layout === undefined) {\n        this.layout = Layout.DEFAULT_THRESHOLD;\n      }\n      if (count === 0) return false;\n      return typeof this.layout === 'number' ? count >= this.layout : this.layout;\n    }\n  }\n\n  return Layout as unknown as MixinCtor<TBase, LayoutMethods>;\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport type { DoExpr } from '../mixins/do';\nimport { DoMixin } from '../mixins/do';\nimport { LayoutMixin } from '../mixins/layout';\n\nconst Mixed = DoMixin(LayoutMixin(TsDsl<ts.Block>));\n\nexport class BlockTsDsl extends Mixed {\n  readonly '~dsl' = 'BlockTsDsl';\n\n  constructor(...items: Array<DoExpr>) {\n    super();\n    this.do(...items);\n  }\n\n  override analyze(ctx: AnalysisContext) {\n    super.analyze(ctx);\n  }\n\n  override toAst() {\n    const statements = this.$do();\n    return ts.factory.createBlock(statements, this.$multiline(statements.length));\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport { PrivateMixin, ProtectedMixin, PublicMixin } from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\nimport { BlockTsDsl } from '../stmt/block';\n\nconst Mixed = DecoratorMixin(\n  DoMixin(\n    DocMixin(\n      ParamMixin(PrivateMixin(ProtectedMixin(PublicMixin(TsDsl<ts.ConstructorDeclaration>)))),\n    ),\n  ),\n);\n\nexport class InitTsDsl extends Mixed {\n  readonly '~dsl' = 'InitTsDsl';\n\n  constructor(fn?: (i: InitTsDsl) => void) {\n    super();\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    ctx.pushScope();\n    try {\n      super.analyze(ctx);\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  override toAst() {\n    const node = ts.factory.createConstructorDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      this.$params(),\n      this.$node(new BlockTsDsl(...this._do).pretty()),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, Node, NodeName } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { TypeTsDsl } from '../base';\nimport { TypeExprTsDsl } from '../type/expr';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface TypeReturnsMethods extends Node {\n  /** Returns the return type node. */\n  $returns(): ts.TypeNode | undefined;\n  /** Sets the return type. */\n  returns(type: NodeName | TypeTsDsl): this;\n}\n\nexport function TypeReturnsMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class TypeReturns extends Base {\n    protected _returns?: TypeTsDsl;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n      ctx.analyze(this._returns);\n    }\n\n    protected returns(type: NodeName | TypeTsDsl): this {\n      this._returns = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n      return this;\n    }\n\n    protected $returns(): ts.TypeNode | undefined {\n      return this.$type(this._returns);\n    }\n  }\n\n  return TypeReturns as unknown as MixinCtor<TBase, TypeReturnsMethods>;\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  AbstractMixin,\n  AsyncMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { OptionalMixin } from '../mixins/optional';\nimport { ParamMixin } from '../mixins/param';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { TypeReturnsMixin } from '../mixins/type-returns';\nimport { BlockTsDsl } from '../stmt/block';\nimport { TokenTsDsl } from '../token';\nimport { safeAccessorName } from '../utils/name';\n\nconst Mixed = AbstractMixin(\n  AsyncMixin(\n    DecoratorMixin(\n      DoMixin(\n        DocMixin(\n          OptionalMixin(\n            ParamMixin(\n              PrivateMixin(\n                ProtectedMixin(\n                  PublicMixin(\n                    StaticMixin(TypeParamsMixin(TypeReturnsMixin(TsDsl<ts.MethodDeclaration>))),\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n\nexport class MethodTsDsl extends Mixed {\n  readonly '~dsl' = 'MethodTsDsl';\n  override readonly nameSanitizer = safeAccessorName;\n\n  constructor(name: NodeName, fn?: (m: MethodTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    ctx.analyze(this.name);\n\n    ctx.pushScope();\n    try {\n      super.analyze(ctx);\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  override toAst() {\n    const node = ts.factory.createMethodDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      undefined,\n      this.$node(this.name) as ts.PropertyName,\n      this._optional ? this.$node(new TokenTsDsl().optional()) : undefined,\n      this.$generics(),\n      this.$params(),\n      this.$returns(),\n      this.$node(new BlockTsDsl(...this._do).pretty()),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { isSymbol, ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { NewlineTsDsl } from '../layout/newline';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DocMixin } from '../mixins/doc';\nimport { AbstractMixin, DefaultMixin, ExportMixin } from '../mixins/modifiers';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { safeRuntimeName } from '../utils/name';\nimport { FieldTsDsl } from './field';\nimport { InitTsDsl } from './init';\nimport { MethodTsDsl } from './method';\n\ntype Body = Array<MaybeTsDsl<ts.ClassElement | ts.Node>>;\n\nconst Mixed = AbstractMixin(\n  DecoratorMixin(DefaultMixin(DocMixin(ExportMixin(TypeParamsMixin(TsDsl<ts.ClassDeclaration>))))),\n);\n\nexport class ClassTsDsl extends Mixed {\n  readonly '~dsl' = 'ClassTsDsl';\n  override readonly nameSanitizer = safeRuntimeName;\n\n  protected baseClass?: Ref<NodeName>;\n  protected body: Body = [];\n\n  constructor(name: NodeName) {\n    super();\n    this.name.set(name);\n    if (isSymbol(name)) {\n      name.setKind('class');\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.baseClass);\n    ctx.analyze(this.name);\n    ctx.pushScope();\n    try {\n      for (const item of this.body) {\n        ctx.analyze(item);\n      }\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  /** Returns true if the class has any members. */\n  get hasBody(): boolean {\n    return this.body.length > 0;\n  }\n\n  /** Adds one or more class members (fields, methods, etc.). */\n  do(...items: Body): this {\n    this.body.push(...items);\n    return this;\n  }\n\n  /** Records a base class to extend from. */\n  extends(base?: NodeName): this {\n    this.baseClass = base ? ref(base) : undefined;\n    return this;\n  }\n\n  /** Adds a class field. */\n  field(name: NodeName, fn?: (f: FieldTsDsl) => void): this {\n    const f = new FieldTsDsl(name, fn);\n    this.body.push(f);\n    return this;\n  }\n\n  /** Adds a class constructor. */\n  init(fn?: InitTsDsl | ((i: InitTsDsl) => void)): this {\n    const i = typeof fn === 'function' ? new InitTsDsl(fn) : fn || new InitTsDsl();\n    this.body.push(i);\n    return this;\n  }\n\n  /** Adds a class method. */\n  method(name: NodeName, fn?: (m: MethodTsDsl) => void): this {\n    const m = new MethodTsDsl(name, fn);\n    this.body.push(m);\n    return this;\n  }\n\n  /** Inserts an empty line between members for formatting. */\n  newline(): this {\n    this.body.push(new NewlineTsDsl());\n    return this;\n  }\n\n  override toAst() {\n    const body = this.$node(this.body) as ReadonlyArray<ts.ClassElement>;\n    const node = ts.factory.createClassDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      this.$node(this.name) as ts.Identifier,\n      this.$generics(),\n      this._heritage(),\n      body,\n    );\n    return this.$docs(node);\n  }\n\n  /** Builds heritage clauses (extends). */\n  private _heritage(): ReadonlyArray<ts.HeritageClause> {\n    const node = this.$node(this.baseClass);\n    if (!node) return [];\n    return [\n      ts.factory.createHeritageClause(ts.SyntaxKind.ExtendsKeyword, [\n        ts.factory.createExpressionWithTypeArguments(node, undefined),\n      ]),\n    ];\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { safeMemberName } from '../utils/name';\n\ntype Value = string | number | MaybeTsDsl<ts.Expression>;\ntype ValueFn = Value | ((m: EnumMemberTsDsl) => void);\n\nconst Mixed = DocMixin(TsDsl<ts.EnumMember>);\n\nexport class EnumMemberTsDsl extends Mixed {\n  readonly '~dsl' = 'EnumMemberTsDsl';\n\n  private _value?: Value;\n\n  constructor(name: NodeName, value?: ValueFn) {\n    super();\n    this.name.set(name);\n    if (typeof value === 'function') {\n      value(this);\n    } else {\n      this.value(value);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._value);\n  }\n\n  /** Sets the enum member value. */\n  value(value?: Value): this {\n    this._value = value;\n    return this;\n  }\n\n  override toAst() {\n    const node = ts.factory.createEnumMember(\n      this.$node(safeMemberName(this.name.toString())),\n      this.$node(this._value),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport { isSymbol } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { ConstMixin, ExportMixin } from '../mixins/modifiers';\nimport { safeRuntimeName } from '../utils/name';\nimport { EnumMemberTsDsl } from './member';\n\ntype Value = string | number | MaybeTsDsl<ts.Expression>;\ntype ValueFn = Value | ((m: EnumMemberTsDsl) => void);\n\nconst Mixed = ConstMixin(DocMixin(ExportMixin(TsDsl<ts.EnumDeclaration>)));\n\nexport class EnumTsDsl extends Mixed {\n  readonly '~dsl' = 'EnumTsDsl';\n  override readonly nameSanitizer = safeRuntimeName;\n\n  private _members: Array<EnumMemberTsDsl> = [];\n\n  constructor(name: NodeName, fn?: (e: EnumTsDsl) => void) {\n    super();\n    this.name.set(name);\n    if (isSymbol(name)) {\n      name.setKind('enum');\n    }\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.pushScope();\n    try {\n      for (const member of this._members) {\n        ctx.analyze(member);\n      }\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  /** Adds an enum member. */\n  member(name: string, value?: ValueFn): this {\n    const m = new EnumMemberTsDsl(name, value);\n    this._members.push(m);\n    return this;\n  }\n\n  /** Adds multiple enum members. */\n  members(...members: ReadonlyArray<EnumMemberTsDsl>): this {\n    this._members.push(...members);\n    return this;\n  }\n\n  override toAst() {\n    const node = ts.factory.createEnumDeclaration(\n      this.modifiers,\n      this.$node(this.name) as ts.Identifier,\n      this.$node(this._members) as ReadonlyArray<ts.EnumMember>,\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport { isSymbol } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  AbstractMixin,\n  AsyncMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { TypeReturnsMixin } from '../mixins/type-returns';\nimport { BlockTsDsl } from '../stmt/block';\nimport { safeRuntimeName } from '../utils/name';\n\nexport type FuncMode = 'arrow' | 'decl' | 'expr';\n\nconst Mixed = AbstractMixin(\n  AsMixin(\n    AsyncMixin(\n      DecoratorMixin(\n        DoMixin(\n          DocMixin(\n            ParamMixin(\n              PrivateMixin(\n                ProtectedMixin(\n                  PublicMixin(\n                    StaticMixin(TypeParamsMixin(TypeReturnsMixin(TsDsl<ts.ArrowFunction>))),\n                  ),\n                ),\n              ),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n\nclass ImplFuncTsDsl<M extends FuncMode = 'arrow'> extends Mixed {\n  readonly '~dsl' = 'FuncTsDsl';\n  override readonly nameSanitizer = safeRuntimeName;\n\n  protected mode?: FuncMode;\n\n  constructor();\n  constructor(fn: (f: ImplFuncTsDsl<'arrow'>) => void);\n  constructor(name: NodeName);\n  constructor(name: NodeName, fn: (f: ImplFuncTsDsl<'decl'>) => void);\n  constructor(\n    name?: NodeName | ((f: ImplFuncTsDsl<'arrow'>) => void),\n    fn?: (f: ImplFuncTsDsl<'decl'>) => void,\n  ) {\n    super();\n    if (typeof name === 'function') {\n      this.mode = 'arrow';\n      name(this as unknown as FuncTsDsl<'arrow'>);\n    } else if (name) {\n      this.mode = 'decl';\n      this.name.set(name);\n      if (isSymbol(name)) {\n        name.setKind('function');\n      }\n      fn?.(this as unknown as FuncTsDsl<'decl'>);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    ctx.pushScope();\n    try {\n      super.analyze(ctx);\n      ctx.analyze(this.name);\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Switches the function to an arrow function form. */\n  arrow(): FuncTsDsl<'arrow'> {\n    this.mode = 'arrow';\n    return this as unknown as FuncTsDsl<'arrow'>;\n  }\n\n  /** Switches the function to a function declaration form. */\n  decl(): FuncTsDsl<'decl'> {\n    this.mode = 'decl';\n    return this as unknown as FuncTsDsl<'decl'>;\n  }\n\n  /** Switches the function to a function expression form. */\n  expr(): FuncTsDsl<'expr'> {\n    this.mode = 'expr';\n    return this as unknown as FuncTsDsl<'expr'>;\n  }\n\n  // @ts-expect-error --- need to fix types ---\n  override toAst(): M extends 'decl'\n    ? ts.FunctionDeclaration\n    : M extends 'expr'\n      ? ts.FunctionExpression\n      : ts.ArrowFunction {\n    this.$validate();\n    const body = this.$node(new BlockTsDsl(...this._do).pretty());\n\n    if (this.mode === 'decl') {\n      const node = ts.factory.createFunctionDeclaration(\n        [...this.$decorators(), ...this.modifiers],\n        undefined,\n        this.$node(this.name) as ts.Identifier,\n        this.$generics(),\n        this.$params(),\n        this.$returns(),\n        body,\n      ) as any;\n      return this.$docs(node);\n    }\n\n    if (this.mode === 'expr') {\n      const node = ts.factory.createFunctionExpression(\n        this.modifiers,\n        undefined,\n        this.$node(this.name) as ts.Identifier,\n        this.$generics(),\n        this.$params(),\n        this.$returns(),\n        body,\n      ) as any;\n      return this.$docs(node);\n    }\n\n    const node = ts.factory.createArrowFunction(\n      this.modifiers,\n      this.$generics(),\n      this.$params(),\n      this.$returns(),\n      undefined,\n      body.statements.length === 1 &&\n        ts.isReturnStatement(body.statements[0]!) &&\n        body.statements[0].expression\n        ? body.statements[0].expression\n        : body,\n    ) as any;\n    return this.$docs(node);\n  }\n\n  $validate(): asserts this {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Function ${this.mode} missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (this.mode === 'decl' && !this.name.toString()) missing.push('name');\n    return missing;\n  }\n}\n\nexport const FuncTsDsl = ImplFuncTsDsl as {\n  new (): FuncTsDsl<'arrow'>;\n  new (fn: (f: FuncTsDsl<'arrow'>) => void): FuncTsDsl<'arrow'>;\n  new (name: NodeName): FuncTsDsl<'decl'>;\n  new (name: NodeName, fn: (f: FuncTsDsl<'decl'>) => void): FuncTsDsl<'decl'>;\n} & typeof ImplFuncTsDsl;\nexport type FuncTsDsl<M extends FuncMode = 'arrow'> = ImplFuncTsDsl<M>;\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  AbstractMixin,\n  AsyncMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\nimport { TypeReturnsMixin } from '../mixins/type-returns';\nimport { BlockTsDsl } from '../stmt/block';\nimport { safeAccessorName } from '../utils/name';\n\nconst Mixed = AbstractMixin(\n  AsyncMixin(\n    DecoratorMixin(\n      DoMixin(\n        DocMixin(\n          ParamMixin(\n            PrivateMixin(\n              ProtectedMixin(\n                PublicMixin(StaticMixin(TypeReturnsMixin(TsDsl<ts.GetAccessorDeclaration>))),\n              ),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n\nexport class GetterTsDsl extends Mixed {\n  readonly '~dsl' = 'GetterTsDsl';\n  override readonly nameSanitizer = safeAccessorName;\n\n  constructor(name: NodeName, fn?: (g: GetterTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    ctx.analyze(this.name);\n\n    ctx.pushScope();\n    try {\n      super.analyze(ctx);\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  override toAst() {\n    const node = ts.factory.createGetAccessorDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      this.$node(this.name) as ts.PropertyName,\n      this.$params(),\n      this.$returns(),\n      this.$node(new BlockTsDsl(...this._do).pretty()),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { DecoratorMixin } from '../mixins/decorator';\nimport { DoMixin } from '../mixins/do';\nimport { DocMixin } from '../mixins/doc';\nimport {\n  AbstractMixin,\n  AsyncMixin,\n  PrivateMixin,\n  ProtectedMixin,\n  PublicMixin,\n  StaticMixin,\n} from '../mixins/modifiers';\nimport { ParamMixin } from '../mixins/param';\nimport { BlockTsDsl } from '../stmt/block';\nimport { safeAccessorName } from '../utils/name';\n\nconst Mixed = AbstractMixin(\n  AsyncMixin(\n    DecoratorMixin(\n      DoMixin(\n        DocMixin(\n          ParamMixin(\n            PrivateMixin(\n              ProtectedMixin(PublicMixin(StaticMixin(TsDsl<ts.SetAccessorDeclaration>))),\n            ),\n          ),\n        ),\n      ),\n    ),\n  ),\n);\n\nexport class SetterTsDsl extends Mixed {\n  readonly '~dsl' = 'SetterTsDsl';\n  override readonly nameSanitizer = safeAccessorName;\n\n  constructor(name: NodeName, fn?: (s: SetterTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    ctx.analyze(this.name);\n\n    ctx.pushScope();\n    try {\n      super.analyze(ctx);\n    } finally {\n      ctx.popScope();\n    }\n  }\n\n  override toAst() {\n    const node = ts.factory.createSetAccessorDeclaration(\n      [...this.$decorators(), ...this.modifiers],\n      this.$node(this.name) as ts.PropertyName,\n      this.$params(),\n      this.$node(new BlockTsDsl(...this._do).pretty()),\n    );\n    return this.$docs(node);\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { LayoutMixin } from '../mixins/layout';\nimport { LiteralTsDsl } from './literal';\n\nconst Mixed = AsMixin(LayoutMixin(TsDsl<ts.ArrayLiteralExpression>));\n\nexport class ArrayTsDsl extends Mixed {\n  readonly '~dsl' = 'ArrayTsDsl';\n\n  protected _elements: Array<\n    | { expr: MaybeTsDsl<ts.Expression>; kind: 'element' }\n    | { expr: MaybeTsDsl<ts.Expression>; kind: 'spread' }\n  > = [];\n\n  constructor(...exprs: Array<string | number | boolean | MaybeTsDsl<ts.Expression>>) {\n    super();\n    this.elements(...exprs);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const item of this._elements) {\n      ctx.analyze(item.expr);\n    }\n  }\n\n  /** Adds a single array element. */\n  element(expr: string | number | boolean | MaybeTsDsl<ts.Expression>): this {\n    const node =\n      typeof expr === 'string' || typeof expr === 'number' || typeof expr === 'boolean'\n        ? new LiteralTsDsl(expr)\n        : expr;\n    this._elements.push({ expr: node, kind: 'element' });\n    return this;\n  }\n\n  /** Adds multiple array elements. */\n  elements(...exprs: ReadonlyArray<string | number | boolean | MaybeTsDsl<ts.Expression>>): this {\n    for (const expr of exprs) this.element(expr);\n    return this;\n  }\n\n  /** Adds a spread element (`...expr`). */\n  spread(expr: MaybeTsDsl<ts.Expression>): this {\n    this._elements.push({ expr, kind: 'spread' });\n    return this;\n  }\n\n  override toAst() {\n    const elements = this._elements.map((item) => {\n      const node = this.$node(item.expr);\n      return item.kind === 'spread' ? ts.factory.createSpreadElement(node) : node;\n    });\n\n    return ts.factory.createArrayLiteralExpression(\n      elements,\n      this.$multiline(this._elements.length),\n    );\n  }\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { f } from '../utils/factories';\nimport type { BaseCtor, DropFirst, MixinCtor } from './types';\n\nexport interface ExprMethods extends Node {\n  /** Accesses a property on the current expression (e.g. `this.foo`). */\n  attr(...args: DropFirst<Parameters<typeof f.attr>>): ReturnType<typeof f.attr>;\n  /** Awaits the current expression (e.g. `await expr`). */\n  await(): ReturnType<typeof f.await>;\n  /** Calls the current expression (e.g. `fn(arg1, arg2)`). */\n  call(...args: DropFirst<Parameters<typeof f.call>>): ReturnType<typeof f.call>;\n  /** Produces a `return` statement returning the current expression. */\n  return(): ReturnType<typeof f.return>;\n}\n\nexport function ExprMixin<T extends ts.Expression, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Expr extends Base {\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected attr(...args: DropFirst<Parameters<typeof f.attr>>): ReturnType<typeof f.attr> {\n      return f.attr(this, ...args);\n    }\n\n    protected await(): ReturnType<typeof f.await> {\n      return f.await(this);\n    }\n\n    protected call(...args: DropFirst<Parameters<typeof f.call>>): ReturnType<typeof f.call> {\n      return f.call(this, ...args);\n    }\n\n    protected return(): ReturnType<typeof f.return> {\n      return f.return(this);\n    }\n  }\n\n  return Expr as unknown as MixinCtor<TBase, ExprMethods>;\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { f } from '../utils/factories';\n\nexport type AsExpr = NodeName | MaybeTsDsl<ts.Expression>;\nexport type AsType = NodeName | TypeTsDsl;\nexport type AsCtor = (expr: AsExpr, type: AsType) => AsTsDsl;\n\nconst Mixed = AsMixin(ExprMixin(TsDsl<ts.AsExpression>));\n\nexport class AsTsDsl extends Mixed {\n  readonly '~dsl' = 'AsTsDsl';\n\n  protected expr: Ref<AsExpr>;\n  protected type: Ref<AsType>;\n\n  constructor(expr: AsExpr, type: AsType) {\n    super();\n    this.expr = ref(expr);\n    this.type = ref(type);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.expr);\n    ctx.analyze(this.type);\n  }\n\n  override toAst() {\n    return ts.factory.createAsExpression(this.$node(this.expr), this.$type(this.type));\n  }\n}\n\nf.as.set((...args) => new AsTsDsl(...args));\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\n\ntype Expr = NodeName | MaybeTsDsl<ts.Expression>;\ntype Op = Operator | ts.BinaryOperator;\ntype Operator =\n  | '!='\n  | '!=='\n  | '&&'\n  | '*'\n  | '+'\n  | '-'\n  | '/'\n  | '<'\n  | '<='\n  | '='\n  | '=='\n  | '==='\n  | '>'\n  | '>='\n  | '??'\n  | '??='\n  | '||';\n\nconst Mixed = AsMixin(ExprMixin(TsDsl<ts.BinaryExpression>));\n\nexport class BinaryTsDsl extends Mixed {\n  readonly '~dsl' = 'BinaryTsDsl';\n\n  protected _base: Ref<Expr>;\n  protected _expr?: Ref<Expr>;\n  protected _op?: Op;\n\n  constructor(base: Expr, op?: Op, expr?: Expr) {\n    super();\n    this._base = ref(base);\n    this._op = op;\n    if (expr) this._expr = ref(expr);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._base);\n    ctx.analyze(this._expr);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Logical AND — `this && expr` */\n  and(expr: Expr): this {\n    return this.opAndExpr('&&', expr);\n  }\n\n  /** Creates an assignment expression (e.g. `this = expr`). */\n  assign(expr: Expr): this {\n    return this.opAndExpr('=', expr);\n  }\n\n  /** Nullish coalescing — `this ?? expr` */\n  coalesce(expr: Expr): this {\n    return this.opAndExpr('??', expr);\n  }\n\n  /** Division — `this / expr` */\n  div(expr: Expr): this {\n    return this.opAndExpr('/', expr);\n  }\n\n  /** Strict equality — `this === expr` */\n  eq(expr: Expr): this {\n    return this.opAndExpr('===', expr);\n  }\n\n  /** Greater than — `this > expr` */\n  gt(expr: Expr): this {\n    return this.opAndExpr('>', expr);\n  }\n\n  /** Greater than or equal — `this >= expr` */\n  gte(expr: Expr): this {\n    return this.opAndExpr('>=', expr);\n  }\n\n  /** Loose equality — `this == expr` */\n  looseEq(expr: Expr): this {\n    return this.opAndExpr('==', expr);\n  }\n\n  /** Loose inequality — `this != expr` */\n  looseNeq(expr: Expr): this {\n    return this.opAndExpr('!=', expr);\n  }\n\n  /** Less than — `this < expr` */\n  lt(expr: Expr): this {\n    return this.opAndExpr('<', expr);\n  }\n\n  /** Less than or equal — `this <= expr` */\n  lte(expr: Expr): this {\n    return this.opAndExpr('<=', expr);\n  }\n\n  /** Subtraction — `this - expr` */\n  minus(expr: Expr): this {\n    return this.opAndExpr('-', expr);\n  }\n\n  /** Strict inequality — `this !== expr` */\n  neq(expr: Expr): this {\n    return this.opAndExpr('!==', expr);\n  }\n\n  /** Nullish assignment — `this ??= expr` */\n  nullishAssign(expr: Expr): this {\n    return this.opAndExpr('??=', expr);\n  }\n\n  /** Logical OR — `this || expr` */\n  or(expr: Expr): this {\n    return this.opAndExpr('||', expr);\n  }\n\n  /** Addition — `this + expr` */\n  plus(expr: Expr): this {\n    return this.opAndExpr('+', expr);\n  }\n\n  /** Multiplication — `this * expr` */\n  times(expr: Expr): this {\n    return this.opAndExpr('*', expr);\n  }\n\n  override toAst() {\n    this.$validate();\n    const base = this.$node(this._base);\n    const operator = typeof this._op === 'string' ? this.opToToken(this._op) : this._op;\n    return ts.factory.createBinaryExpression(base, operator, this.$node(this._expr));\n  }\n\n  $validate(): asserts this is this & {\n    _expr: Ref<Expr>;\n    _op: Op;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Binary expression missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._op) missing.push('operator (e.g., .eq(), .plus())');\n    if (!this._expr) missing.push('right-hand expression');\n    return missing;\n  }\n\n  /** Sets the binary operator and right-hand operand for this expression. */\n  private opAndExpr(op: Op, expr: Expr): this {\n    this._expr = ref(expr);\n    this._op = op;\n    return this;\n  }\n\n  private opToToken(op: Operator): ts.BinaryOperator | ts.BinaryOperatorToken {\n    const tokenMap: Record<Operator, ts.BinaryOperator> = {\n      '!=': ts.SyntaxKind.ExclamationEqualsToken,\n      '!==': ts.SyntaxKind.ExclamationEqualsEqualsToken,\n      '&&': ts.SyntaxKind.AmpersandAmpersandToken,\n      '*': ts.SyntaxKind.AsteriskToken,\n      '+': ts.SyntaxKind.PlusToken,\n      '-': ts.SyntaxKind.MinusToken,\n      '/': ts.SyntaxKind.SlashToken,\n      '<': ts.SyntaxKind.LessThanToken,\n      '<=': ts.SyntaxKind.LessThanEqualsToken,\n      '=': ts.SyntaxKind.EqualsToken,\n      '==': ts.SyntaxKind.EqualsEqualsToken,\n      '===': ts.SyntaxKind.EqualsEqualsEqualsToken,\n      '>': ts.SyntaxKind.GreaterThanToken,\n      '>=': ts.SyntaxKind.GreaterThanEqualsToken,\n      '??': ts.SyntaxKind.QuestionQuestionToken,\n      '??=': ts.SyntaxKind.QuestionQuestionEqualsToken,\n      '||': ts.SyntaxKind.BarBarToken,\n    };\n    const token = tokenMap[op];\n    if (!token) {\n      throw new Error(`Unsupported operator: ${op}`);\n    }\n    return token;\n  }\n}\n","import type { AnalysisContext, Node, NodeName } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { BinaryTsDsl } from '../expr/binary';\nimport type { BaseCtor, MixinCtor } from './types';\n\ntype Expr = NodeName | MaybeTsDsl<ts.Expression>;\n\nexport interface OperatorMethods extends Node {\n  /** Logical AND — `this && expr` */\n  and(expr: Expr): BinaryTsDsl;\n  /** Creates an assignment expression (e.g. `this = expr`). */\n  assign(expr: Expr): BinaryTsDsl;\n  /** Nullish coalescing — `this ?? expr` */\n  coalesce(expr: Expr): BinaryTsDsl;\n  /** Division — `this / expr` */\n  div(expr: Expr): BinaryTsDsl;\n  /** Strict equality — `this === expr` */\n  eq(expr: Expr): BinaryTsDsl;\n  /** Greater than — `this > expr` */\n  gt(expr: Expr): BinaryTsDsl;\n  /** Greater than or equal — `this >= expr` */\n  gte(expr: Expr): BinaryTsDsl;\n  /** Loose equality — `this == expr` */\n  looseEq(expr: Expr): BinaryTsDsl;\n  /** Loose inequality — `this != expr` */\n  looseNeq(expr: Expr): BinaryTsDsl;\n  /** Less than — `this < expr` */\n  lt(expr: Expr): BinaryTsDsl;\n  /** Less than or equal — `this <= expr` */\n  lte(expr: Expr): BinaryTsDsl;\n  /** Subtraction — `this - expr` */\n  minus(expr: Expr): BinaryTsDsl;\n  /** Strict inequality — `this !== expr` */\n  neq(expr: Expr): BinaryTsDsl;\n  /** Nullish assignment — `this ??= expr` */\n  nullishAssign(expr: Expr): BinaryTsDsl;\n  /** Logical OR — `this || expr` */\n  or(expr: Expr): BinaryTsDsl;\n  /** Addition — `this + expr` */\n  plus(expr: Expr): BinaryTsDsl;\n  /** Multiplication — `this * expr` */\n  times(expr: Expr): BinaryTsDsl;\n}\n\nexport function OperatorMixin<T extends ts.Expression, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Operator extends Base {\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected and(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).and(expr);\n    }\n\n    protected assign(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this, '=', expr);\n    }\n\n    protected coalesce(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).coalesce(expr);\n    }\n\n    protected div(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).div(expr);\n    }\n\n    protected eq(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).eq(expr);\n    }\n\n    protected gt(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).gt(expr);\n    }\n\n    protected gte(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).gte(expr);\n    }\n\n    protected looseEq(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).looseEq(expr);\n    }\n\n    protected looseNeq(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).looseNeq(expr);\n    }\n\n    protected lt(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).lt(expr);\n    }\n\n    protected lte(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).lte(expr);\n    }\n\n    protected minus(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).minus(expr);\n    }\n\n    protected neq(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).neq(expr);\n    }\n\n    protected nullishAssign(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).nullishAssign(expr);\n    }\n\n    protected or(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).or(expr);\n    }\n\n    protected plus(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).plus(expr);\n    }\n\n    protected times(expr: Expr): BinaryTsDsl {\n      return new BinaryTsDsl(this).times(expr);\n    }\n  }\n\n  return Operator as unknown as MixinCtor<TBase, OperatorMethods>;\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { fromRef, isSymbol, ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { OperatorMixin } from '../mixins/operator';\nimport { OptionalMixin } from '../mixins/optional';\nimport { TokenTsDsl } from '../token';\nimport { f } from '../utils/factories';\nimport { regexp } from '../utils/regexp';\nimport { LiteralTsDsl } from './literal';\n\nexport type AttrLeft = NodeName | MaybeTsDsl<ts.Expression>;\nexport type AttrCtor = (left: AttrLeft, right: NodeName) => AttrTsDsl;\n\nconst Mixed = AsMixin(\n  ExprMixin(\n    OperatorMixin(OptionalMixin(TsDsl<ts.PropertyAccessExpression | ts.ElementAccessExpression>)),\n  ),\n);\n\nexport class AttrTsDsl extends Mixed {\n  readonly '~dsl' = 'AttrTsDsl';\n\n  protected left: Ref<AttrLeft>;\n\n  constructor(left: AttrLeft, right: NodeName) {\n    super();\n    this.left = ref(left);\n    this.name.set(right);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.left);\n    ctx.analyze(this.name);\n  }\n\n  override toAst() {\n    const leftNode = this.$node(this.left);\n    regexp.typeScriptIdentifier.lastIndex = 0;\n    const right = fromRef(this.name);\n    if (!regexp.typeScriptIdentifier.test(this.name.toString())) {\n      let value = isSymbol(right) ? right.finalName : right;\n      if (typeof value === 'string') {\n        if (\n          (value.startsWith(\"'\") && value.endsWith(\"'\")) ||\n          (value.startsWith('\"') && value.endsWith('\"'))\n        ) {\n          value = value.slice(1, -1);\n        }\n      }\n      if (this._optional) {\n        return ts.factory.createElementAccessChain(\n          leftNode,\n          this.$node(new TokenTsDsl().questionDot()),\n          this.$node(new LiteralTsDsl(value)),\n        );\n      }\n      return ts.factory.createElementAccessExpression(\n        leftNode,\n        this.$node(new LiteralTsDsl(value)),\n      );\n    }\n    if (this._optional) {\n      return ts.factory.createPropertyAccessChain(\n        leftNode,\n        this.$node(new TokenTsDsl().questionDot()),\n        this.$node(this.name) as ts.MemberName,\n      );\n    }\n    return ts.factory.createPropertyAccessExpression(\n      leftNode,\n      this.$node(this.name) as ts.MemberName,\n    );\n  }\n}\n\nf.attr.set((...args) => new AttrTsDsl(...args));\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { ExprMixin } from '../mixins/expr';\nimport { f } from '../utils/factories';\n\nexport type AwaitExpr = NodeName | MaybeTsDsl<ts.Expression>;\nexport type AwaitCtor = (expr: AwaitExpr) => AwaitTsDsl;\n\nconst Mixed = ExprMixin(TsDsl<ts.AwaitExpression>);\n\nexport class AwaitTsDsl extends Mixed {\n  readonly '~dsl' = 'AwaitTsDsl';\n\n  protected _awaitExpr: Ref<AwaitExpr>;\n\n  constructor(expr: AwaitExpr) {\n    super();\n    this._awaitExpr = ref(expr);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._awaitExpr);\n  }\n\n  override toAst() {\n    return ts.factory.createAwaitExpression(this.$node(this._awaitExpr));\n  }\n}\n\nf.await.set((...args) => new AwaitTsDsl(...args));\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { ArgsMixin } from '../mixins/args';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { TypeArgsMixin } from '../mixins/type-args';\nimport { f } from '../utils/factories';\n\nexport type CallArgs = ReadonlyArray<CallExpr | undefined>;\nexport type CallExpr = NodeName | MaybeTsDsl<ts.Expression>;\nexport type CallCtor = (expr: CallExpr, ...args: CallArgs) => CallTsDsl;\n\nconst Mixed = ArgsMixin(AsMixin(ExprMixin(TypeArgsMixin(TsDsl<ts.CallExpression>))));\n\nexport class CallTsDsl extends Mixed {\n  readonly '~dsl' = 'CallTsDsl';\n\n  protected _callExpr: Ref<CallExpr>;\n\n  constructor(expr: CallExpr, ...args: CallArgs) {\n    super();\n    this._callExpr = ref(expr);\n    this.args(...args);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._callExpr);\n  }\n\n  override toAst() {\n    return ts.factory.createCallExpression(\n      this.$node(this._callExpr),\n      this.$generics(),\n      this.$args(),\n    );\n  }\n}\n\nf.call.set((...args) => new CallTsDsl(...args));\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { isNode, isSymbol, ref } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { OperatorMixin } from '../mixins/operator';\nimport { TypeExprMixin } from '../mixins/type-expr';\n\ntype Id = NodeName | MaybeTsDsl<ts.Expression>;\n\nconst Mixed = AsMixin(ExprMixin(OperatorMixin(TypeExprMixin(TsDsl<ts.Expression>))));\n\nexport class ExprTsDsl extends Mixed {\n  readonly '~dsl' = 'ExprTsDsl';\n\n  protected _exprInput: Ref<Id>;\n\n  constructor(id: Id) {\n    super();\n    this._exprInput = ref(id);\n    if (typeof id === 'string' || isSymbol(id)) {\n      this.name.set(id);\n    } else if (isNode(id)) {\n      this.name.set(id.name);\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._exprInput);\n  }\n\n  override toAst() {\n    return this.$node(this._exprInput);\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport type { MaybeArray } from '@hey-api/types';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\nimport type { TsDslContext } from '../utils/context';\nimport { ctx } from '../utils/context';\n\ntype HintMaybeLazy<T> = ((ctx: TsDslContext) => T) | T;\nexport type HintFn = (d: HintTsDsl) => void;\nexport type HintLines = HintMaybeLazy<MaybeArray<string>>;\n\nexport class HintTsDsl extends TsDsl<ts.Node> {\n  readonly '~dsl' = 'HintTsDsl';\n\n  protected _lines: Array<HintLines> = [];\n\n  constructor(lines?: HintLines, fn?: HintFn) {\n    super();\n    if (lines) this.add(lines);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  add(lines: HintLines): this {\n    this._lines.push(lines);\n    return this;\n  }\n\n  apply<T extends ts.Node>(node: T): T {\n    const lines = this._lines.reduce((lines: Array<string>, line: HintLines) => {\n      if (typeof line === 'function') line = line(ctx);\n      for (const l of typeof line === 'string' ? [line] : line) {\n        if (l || l === '') lines.push(l);\n      }\n      return lines;\n    }, []);\n    if (!lines.length) return node;\n\n    for (const line of lines) {\n      ts.addSyntheticLeadingComment(node, ts.SyntaxKind.SingleLineCommentTrivia, ` ${line}`, false);\n    }\n\n    return node;\n  }\n\n  override toAst(): ts.Node {\n    // this class does not build a standalone node;\n    // it modifies other nodes via `apply()`.\n    // Return a dummy comment node for compliance.\n    return this.$node(new IdTsDsl(''));\n  }\n}\n","import type { AnalysisContext, Node } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { HintFn, HintLines } from '../layout/hint';\nimport { HintTsDsl } from '../layout/hint';\nimport type { BaseCtor, MixinCtor } from './types';\n\nexport interface HintMethods extends Node {\n  $hint<T extends ts.Node>(node: T): T;\n  hint(lines?: HintLines, fn?: HintFn): this;\n}\n\nexport function HintMixin<T extends ts.Node, TBase extends BaseCtor<T>>(Base: TBase) {\n  abstract class Hint extends Base {\n    private _hint?: HintTsDsl;\n\n    override analyze(ctx: AnalysisContext): void {\n      super.analyze(ctx);\n    }\n\n    protected hint(lines?: HintLines, fn?: HintFn): this {\n      this._hint = new HintTsDsl(lines, fn);\n      return this;\n    }\n\n    protected $hint<T extends ts.Node>(node: T): T {\n      return this._hint ? this._hint.apply(node) : node;\n    }\n  }\n\n  return Hint as unknown as MixinCtor<TBase, HintMethods>;\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { GetterTsDsl } from '../decl/getter';\nimport { SetterTsDsl } from '../decl/setter';\nimport { DocMixin } from '../mixins/doc';\nimport { safePropName } from '../utils/name';\nimport { IdTsDsl } from './id';\n\ntype Expr = NodeName | MaybeTsDsl<ts.Expression>;\ntype Stmt = NodeName | MaybeTsDsl<ts.Statement>;\n\nexport type ObjectPropKind = 'computed' | 'getter' | 'prop' | 'setter' | 'spread';\n\ntype Meta =\n  | { kind: 'computed'; name: string }\n  | { kind: 'getter'; name: string }\n  | { kind: 'prop'; name: string }\n  | { kind: 'setter'; name: string }\n  | { kind: 'spread'; name?: undefined };\n\nconst Mixed = DocMixin(TsDsl<ts.ObjectLiteralElementLike>);\n\nexport class ObjectPropTsDsl extends Mixed {\n  readonly '~dsl' = 'ObjectPropTsDsl';\n\n  protected _value?: Ref<Expr | Stmt>;\n  protected _meta: Meta;\n\n  constructor(meta: Meta) {\n    super();\n    this._meta = meta;\n  }\n\n  get kind(): ObjectPropKind {\n    return this._meta.kind;\n  }\n\n  get propName(): string | undefined {\n    return this._meta.name;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._value);\n  }\n\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  value(value: Expr | Stmt | ((p: ObjectPropTsDsl) => void)) {\n    if (typeof value === 'function') {\n      value(this);\n    } else {\n      this._value = ref(value);\n    }\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    const node = this.$node(this._value);\n    if (this._meta.kind === 'spread') {\n      if (ts.isStatement(node)) {\n        throw new Error('Invalid spread: object spread must be an expression, not a statement.');\n      }\n      const result = ts.factory.createSpreadAssignment(node);\n      return this.$docs(result);\n    }\n    if (this._meta.kind === 'getter') {\n      const getter = new GetterTsDsl(this._meta.name).do(node);\n      const result = this.$node(getter);\n      return this.$docs(result);\n    }\n    if (this._meta.kind === 'setter') {\n      const setter = new SetterTsDsl(this._meta.name).do(node);\n      const result = this.$node(setter);\n      return this.$docs(result);\n    }\n    if (ts.isIdentifier(node) && node.text === this._meta.name) {\n      const result = ts.factory.createShorthandPropertyAssignment(this._meta.name);\n      return this.$docs(result);\n    }\n    if (ts.isStatement(node)) {\n      throw new Error(\n        'Invalid property: object property value must be an expression, not a statement.',\n      );\n    }\n    const result = ts.factory.createPropertyAssignment(\n      this._meta.kind === 'computed'\n        ? ts.factory.createComputedPropertyName(this.$node(new IdTsDsl(this._meta.name)))\n        : this.$node(safePropName(this._meta.name)),\n      node,\n    );\n    return this.$docs(result);\n  }\n\n  $validate(): asserts this is this & {\n    _value: Expr | Stmt;\n    kind: ObjectPropKind;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(\n      `Object property${this._meta.name ? ` \"${this._meta.name}\"` : ''} missing ${missing.join(' and ')}`,\n    );\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._value) missing.push('.value()');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { HintMixin } from '../mixins/hint';\nimport { LayoutMixin } from '../mixins/layout';\nimport { ObjectPropTsDsl } from './prop';\n\ntype Expr = NodeName | MaybeTsDsl<ts.Expression>;\ntype Stmt = NodeName | MaybeTsDsl<ts.Statement>;\ntype ExprFn = Expr | ((p: ObjectPropTsDsl) => void);\ntype StmtFn = Stmt | ((p: ObjectPropTsDsl) => void);\n\nconst Mixed = AsMixin(ExprMixin(HintMixin(LayoutMixin(TsDsl<ts.ObjectLiteralExpression>))));\n\nexport class ObjectTsDsl extends Mixed {\n  readonly '~dsl' = 'ObjectTsDsl';\n\n  protected _props = new Map<string, ObjectPropTsDsl>();\n  protected _spreadCounter = 0;\n\n  constructor(...props: Array<ObjectPropTsDsl>) {\n    super();\n    this.props(...props);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const prop of this._props.values()) {\n      ctx.analyze(prop);\n    }\n  }\n\n  /** Returns composite key for the property. */\n  private _propKey(prop: ObjectPropTsDsl): string {\n    if (prop.kind === 'spread') {\n      return `spread:${this._spreadCounter++}`;\n    }\n    return `${prop.kind}:${prop.propName}`;\n  }\n\n  /** Adds a computed property (e.g. `{ [expr]: value }`), or removes if null. */\n  computed(name: string, expr: ExprFn | null): this {\n    if (expr === null) {\n      this._props.delete(`computed:${name}`);\n    } else {\n      this._props.set(\n        `computed:${name}`,\n        new ObjectPropTsDsl({ kind: 'computed', name }).value(expr),\n      );\n    }\n    return this;\n  }\n\n  /** Adds a getter property (e.g. `{ get foo() { ... } }`), or removes if null. */\n  getter(name: string, stmt: StmtFn | null): this {\n    if (stmt === null) {\n      this._props.delete(`getter:${name}`);\n    } else {\n      this._props.set(`getter:${name}`, new ObjectPropTsDsl({ kind: 'getter', name }).value(stmt));\n    }\n    return this;\n  }\n\n  /** Returns true if object has at least one property or spread. */\n  hasProps(): boolean {\n    return this._props.size > 0;\n  }\n\n  /** Returns true if object has no properties or spreads. */\n  get isEmpty(): boolean {\n    return this._props.size === 0;\n  }\n\n  /** Adds a property assignment, or removes if null. */\n  prop(name: string, expr: ExprFn | null): this {\n    if (expr === null) {\n      this._props.delete(`prop:${name}`);\n    } else {\n      this._props.set(`prop:${name}`, new ObjectPropTsDsl({ kind: 'prop', name }).value(expr));\n    }\n    return this;\n  }\n\n  /** Adds multiple properties. */\n  props(...props: ReadonlyArray<ObjectPropTsDsl>): this {\n    for (const prop of props) {\n      this._props.set(this._propKey(prop), prop);\n    }\n    return this;\n  }\n\n  /** Adds a setter property (e.g. `{ set foo(v) { ... } }`), or removes if null. */\n  setter(name: string, stmt: StmtFn | null): this {\n    if (stmt === null) {\n      this._props.delete(`setter:${name}`);\n    } else {\n      this._props.set(`setter:${name}`, new ObjectPropTsDsl({ kind: 'setter', name }).value(stmt));\n    }\n    return this;\n  }\n\n  /** Adds a spread property (e.g. `{ ...options }`). */\n  spread(expr: ExprFn): this {\n    const key = `spread:${this._spreadCounter++}`;\n    this._props.set(key, new ObjectPropTsDsl({ kind: 'spread' }).value(expr));\n    return this;\n  }\n\n  override toAst() {\n    const props = [...this._props.values()];\n    const node = ts.factory.createObjectLiteralExpression(\n      this.$node(props),\n      this.$multiline(props.length),\n    );\n    return this.$hint(node);\n  }\n}\n","import { isNode } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { TsDsl } from '../base';\nimport { ArrayTsDsl } from './array';\nimport { LiteralTsDsl } from './literal';\nimport { ObjectTsDsl } from './object';\n\nexport const fromValue = (\n  input: unknown,\n  options?: {\n    layout?: 'pretty';\n  },\n): TsDsl<ts.Expression> => {\n  if (isNode(input)) {\n    return input as TsDsl<ts.Expression>;\n  }\n\n  if (\n    input === null ||\n    typeof input === 'number' ||\n    typeof input === 'boolean' ||\n    typeof input === 'string' ||\n    typeof input === 'bigint'\n  ) {\n    return new LiteralTsDsl(input);\n  }\n\n  if (input instanceof Array) {\n    const arr = new ArrayTsDsl(...input.map((v) => fromValue(v, options)));\n    if (options?.layout === 'pretty') arr.pretty();\n    return arr;\n  }\n\n  if (typeof input === 'object') {\n    const obj = new ObjectTsDsl();\n    for (const [key, val] of Object.entries(input)) {\n      const expr = fromValue(val, options);\n      obj.prop(key, expr);\n    }\n    if (options?.layout === 'pretty') obj.pretty();\n    return obj;\n  }\n\n  throw new Error(`$.fromValue(): Unsupported input type ${String(input)}`);\n};\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { ArgsMixin } from '../mixins/args';\nimport { AsMixin } from '../mixins/as';\nimport { ExprMixin } from '../mixins/expr';\nimport { TypeArgsMixin } from '../mixins/type-args';\nimport { f } from '../utils/factories';\n\nexport type NewArgs = ReadonlyArray<NewExpr | undefined>;\nexport type NewExpr = NodeName | MaybeTsDsl<ts.Expression>;\nexport type NewCtor = (expr: NewExpr, ...args: NewArgs) => NewTsDsl;\n\nconst Mixed = ArgsMixin(AsMixin(ExprMixin(TypeArgsMixin(TsDsl<ts.NewExpression>))));\n\nexport class NewTsDsl extends Mixed {\n  readonly '~dsl' = 'NewTsDsl';\n\n  protected _newExpr: Ref<NewExpr>;\n\n  constructor(expr: NewExpr, ...args: NewArgs) {\n    super();\n    this._newExpr = ref(expr);\n    this.args(...args);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._newExpr);\n  }\n\n  override toAst() {\n    return ts.factory.createNewExpression(\n      this.$node(this._newExpr),\n      this.$generics(),\n      this.$args(),\n    );\n  }\n}\n\nf.new.set((...args) => new NewTsDsl(...args));\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\n\ntype RegexFlag = 'g' | 'i' | 'm' | 's' | 'u' | 'y';\n\ntype RegexFlags<Avail extends string = RegexFlag> =\n  | ''\n  | {\n      [K in Avail]: `${K}${RegexFlags<Exclude<Avail, K>>}`;\n    }[Avail];\n\nconst Mixed = TsDsl<ts.RegularExpressionLiteral>;\n\nexport class RegExpTsDsl extends Mixed {\n  readonly '~dsl' = 'RegExpTsDsl';\n\n  protected pattern: string;\n  protected flags?: RegexFlags;\n\n  constructor(pattern: string, flags?: RegexFlags) {\n    super();\n    this.pattern = pattern;\n    this.flags = flags;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  override toAst() {\n    const patternContent =\n      this.pattern.startsWith('/') && this.pattern.endsWith('/')\n        ? this.pattern.slice(1, -1)\n        : this.pattern;\n    const escapedPattern = patternContent.replace(/(?<!\\\\)\\//g, '\\\\/');\n    const literal = `/${escapedPattern}/${this.flags ?? ''}`;\n    return ts.factory.createRegularExpressionLiteral(literal);\n  }\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { fromRef, isSymbol, ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nexport type TemplatePart = NodeName | MaybeTsDsl<ts.Expression>;\n\nconst Mixed = TsDsl<ts.TemplateExpression | ts.NoSubstitutionTemplateLiteral>;\n\nexport class TemplateTsDsl extends Mixed {\n  readonly '~dsl' = 'TemplateTsDsl';\n\n  protected parts: Array<Ref<TemplatePart>> = [];\n\n  constructor(value?: TemplatePart) {\n    super();\n    if (value !== undefined) this.add(value);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const part of this.parts) {\n      ctx.analyze(part);\n    }\n  }\n\n  add(value: TemplatePart): this {\n    this.parts.push(ref(value));\n    return this;\n  }\n\n  override toAst() {\n    const parts = this.$node(\n      this.parts.map((p) => {\n        const part = fromRef(p);\n        return isSymbol(part) ? part.finalName : part;\n      }),\n    );\n\n    const normalized: Array<string | ts.Expression> = [];\n    // merge consecutive string parts\n    for (let index = 0; index < parts.length; index++) {\n      const current = parts[index]!;\n      if (typeof current === 'string') {\n        let merged = current;\n        while (index + 1 < parts.length && typeof parts[index + 1] === 'string') {\n          merged += parts[index + 1];\n          index++;\n        }\n        normalized.push(merged);\n      } else if (typeof current === 'number') {\n        normalized.push(String(current));\n      } else {\n        normalized.push(current);\n      }\n    }\n\n    if (normalized.length === 0 || typeof normalized[0] !== 'string') {\n      normalized.unshift('');\n    }\n\n    if (normalized.length === 1 && typeof normalized[0] === 'string') {\n      return ts.factory.createNoSubstitutionTemplateLiteral(normalized[0]);\n    }\n\n    if (\n      normalized.length === 2 &&\n      typeof normalized[0] === 'string' &&\n      typeof normalized[1] !== 'string'\n    ) {\n      return ts.factory.createTemplateExpression(ts.factory.createTemplateHead(normalized[0]), [\n        ts.factory.createTemplateSpan(normalized[1]!, ts.factory.createTemplateTail('')),\n      ]);\n    }\n\n    const head = ts.factory.createTemplateHead(normalized.shift() as string);\n    const spans: Array<ts.TemplateSpan> = [];\n\n    while (normalized.length) {\n      const expr = normalized.shift() as ts.Expression;\n      const next = typeof normalized[0] === 'string' ? (normalized.shift() as string) : '';\n      const isLast = normalized.length === 0;\n      spans.push(\n        ts.factory.createTemplateSpan(\n          expr,\n          isLast ? ts.factory.createTemplateTail(next) : ts.factory.createTemplateMiddle(next),\n        ),\n      );\n    }\n\n    return ts.factory.createTemplateExpression(head, spans);\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.ConditionalExpression>;\n\nexport class TernaryTsDsl extends Mixed {\n  readonly '~dsl' = 'TernaryTsDsl';\n\n  protected _condition?: string | MaybeTsDsl<ts.Expression>;\n  protected _then?: string | MaybeTsDsl<ts.Expression>;\n  protected _else?: string | MaybeTsDsl<ts.Expression>;\n\n  constructor(condition?: string | MaybeTsDsl<ts.Expression>) {\n    super();\n    if (condition) this.condition(condition);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._condition);\n    ctx.analyze(this._then);\n    ctx.analyze(this._else);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  condition(condition: string | MaybeTsDsl<ts.Expression>) {\n    this._condition = condition;\n    return this;\n  }\n\n  do(expr: string | MaybeTsDsl<ts.Expression>) {\n    this._then = expr;\n    return this;\n  }\n\n  otherwise(expr: string | MaybeTsDsl<ts.Expression>) {\n    this._else = expr;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    return ts.factory.createConditionalExpression(\n      this.$node(this._condition),\n      undefined,\n      this.$node(this._then),\n      undefined,\n      this.$node(this._else),\n    );\n  }\n\n  $validate(): asserts this is this & {\n    _condition: string | MaybeTsDsl<ts.Expression>;\n    _else: string | MaybeTsDsl<ts.Expression>;\n    _then: string | MaybeTsDsl<ts.Expression>;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Ternary expression missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._condition) missing.push('.condition()');\n    if (!this._then) missing.push('.do()');\n    if (!this._else) missing.push('.otherwise()');\n    return missing;\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { OperatorMixin } from '../mixins/operator';\nimport { f } from '../utils/factories';\n\nexport type TypeOfExpr = string | MaybeTsDsl<ts.Expression>;\nexport type TypeOfExprCtor = (expr: TypeOfExpr) => TypeOfExprTsDsl;\n\nconst Mixed = OperatorMixin(TsDsl<ts.TypeOfExpression>);\n\nexport class TypeOfExprTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeOfExprTsDsl';\n\n  protected _expr: TypeOfExpr;\n\n  constructor(expr: TypeOfExpr) {\n    super();\n    this._expr = expr;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._expr);\n  }\n\n  override toAst() {\n    return ts.factory.createTypeOfExpression(this.$node(this._expr));\n  }\n}\n\nf.typeofExpr.set((...args) => new TypeOfExprTsDsl(...args));\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport type { MaybeArray } from '@hey-api/types';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { IdTsDsl } from '../expr/id';\nimport type { TsDslContext } from '../utils/context';\nimport { ctx } from '../utils/context';\n\ntype NoteMaybeLazy<T> = ((ctx: TsDslContext) => T) | T;\nexport type NoteFn = (d: NoteTsDsl) => void;\nexport type NoteLines = NoteMaybeLazy<MaybeArray<string>>;\n\nexport class NoteTsDsl extends TsDsl<ts.Node> {\n  readonly '~dsl' = 'NoteTsDsl';\n\n  protected _lines: Array<NoteLines> = [];\n\n  constructor(lines?: NoteLines, fn?: NoteFn) {\n    super();\n    if (lines) this.add(lines);\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  add(lines: NoteLines): this {\n    this._lines.push(lines);\n    return this;\n  }\n\n  apply<T extends ts.Node>(node: T): T {\n    const lines = this._lines.reduce((lines: Array<string>, line: NoteLines) => {\n      if (typeof line === 'function') line = line(ctx);\n      for (const l of typeof line === 'string' ? [line] : line) {\n        if (l || l === '') lines.push(l);\n      }\n      return lines;\n    }, []);\n    if (!lines.length) return node;\n\n    ts.addSyntheticLeadingComment(\n      node,\n      ts.SyntaxKind.MultiLineCommentTrivia,\n      `\\n${lines.join('\\n')}\\n`,\n      true,\n    );\n\n    return node;\n  }\n\n  override toAst(): ts.Node {\n    // this class does not build a standalone node;\n    // it modifies other nodes via `apply()`.\n    // Return a dummy comment node for compliance.\n    return this.$node(new IdTsDsl(''));\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport type { DoExpr } from '../mixins/do';\nimport { DoMixin } from '../mixins/do';\nimport { BlockTsDsl } from './block';\n\nexport type IfCondition = string | MaybeTsDsl<ts.Expression>;\n\nconst Mixed = DoMixin(TsDsl<ts.IfStatement>);\n\nexport class IfTsDsl extends Mixed {\n  readonly '~dsl' = 'IfTsDsl';\n\n  protected _condition?: IfCondition;\n  protected _else?: Array<DoExpr>;\n\n  constructor(condition?: IfCondition) {\n    super();\n    if (condition) this.condition(condition);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._condition);\n    if (this._else) {\n      ctx.pushScope();\n      try {\n        for (const stmt of this._else) {\n          ctx.analyze(stmt);\n        }\n      } finally {\n        ctx.popScope();\n      }\n    }\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  condition(condition: IfCondition): this {\n    this._condition = condition;\n    return this;\n  }\n\n  otherwise(...items: Array<DoExpr>): this {\n    this._else = items;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    return ts.factory.createIfStatement(\n      this.$node(this._condition),\n      this.$node(new BlockTsDsl(...this._do).pretty()),\n      this._else ? this.$node(new BlockTsDsl(...this._else).pretty()) : undefined,\n    );\n  }\n\n  $validate(): asserts this is this & {\n    _condition: IfCondition;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`If statement missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._condition) missing.push('.condition()');\n    if (this._do.length === 0) missing.push('.do()');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeName, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { f } from '../utils/factories';\n\nexport type ReturnExpr = NodeName | MaybeTsDsl<ts.Expression>;\nexport type ReturnCtor = (expr?: ReturnExpr) => ReturnTsDsl;\n\nconst Mixed = TsDsl<ts.ReturnStatement>;\n\nexport class ReturnTsDsl extends Mixed {\n  readonly '~dsl' = 'ReturnTsDsl';\n\n  protected _returnExpr?: Ref<ReturnExpr>;\n\n  constructor(expr?: ReturnExpr) {\n    super();\n    if (expr) this._returnExpr = ref(expr);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._returnExpr);\n  }\n\n  override toAst() {\n    return ts.factory.createReturnStatement(this.$node(this._returnExpr));\n  }\n}\n\nf.return.set((...args) => new ReturnTsDsl(...args));\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { LiteralTsDsl } from '../expr/literal';\n\nconst Mixed = TsDsl<ts.ThrowStatement>;\n\nexport class ThrowTsDsl extends Mixed {\n  readonly '~dsl' = 'ThrowTsDsl';\n\n  protected error: string | MaybeTsDsl<ts.Expression>;\n  protected msg?: string | MaybeTsDsl<ts.Expression>;\n  protected useNew: boolean;\n\n  constructor(error: string | MaybeTsDsl<ts.Expression>, useNew = true) {\n    super();\n    this.error = error;\n    this.useNew = useNew;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.error);\n    ctx.analyze(this.msg);\n  }\n\n  message(value: string | MaybeTsDsl<ts.Expression>): this {\n    this.msg = value;\n    return this;\n  }\n\n  override toAst() {\n    const errorNode = this.$node(this.error);\n    const messageNode = this.$node(this.msg ? [this.msg] : []).map((expr) =>\n      typeof expr === 'string' ? this.$node(new LiteralTsDsl(expr)) : expr,\n    );\n    if (this.useNew) {\n      return ts.factory.createThrowStatement(\n        ts.factory.createNewExpression(errorNode, undefined, messageNode),\n      );\n    }\n    const args = messageNode.length\n      ? [ts.factory.createCallExpression(errorNode, undefined, messageNode)]\n      : [errorNode];\n    return ts.factory.createThrowStatement(args[0]!);\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport type { DoExpr } from '../mixins/do';\nimport { BlockTsDsl } from './block';\n\nconst Mixed = TsDsl<ts.TryStatement>;\n\nexport class TryTsDsl extends Mixed {\n  readonly '~dsl' = 'TryTsDsl';\n\n  protected _catch?: Array<DoExpr>;\n  protected _catchArg?: NodeName;\n  protected _finally?: Array<DoExpr>;\n  protected _try?: Array<DoExpr>;\n\n  constructor(...tryBlock: Array<DoExpr>) {\n    super();\n    this.try(...tryBlock);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n\n    if (this._try) {\n      ctx.pushScope();\n      try {\n        for (const stmt of this._try) ctx.analyze(stmt);\n      } finally {\n        ctx.popScope();\n      }\n    }\n\n    if (this._catch || this._catchArg) {\n      ctx.pushScope();\n      try {\n        ctx.analyze(this._catchArg);\n        if (this._catch) {\n          for (const stmt of this._catch) ctx.analyze(stmt);\n        }\n      } finally {\n        ctx.popScope();\n      }\n    }\n\n    if (this._finally) {\n      ctx.pushScope();\n      try {\n        for (const stmt of this._finally) ctx.analyze(stmt);\n      } finally {\n        ctx.popScope();\n      }\n    }\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  catch(...items: Array<DoExpr>): this {\n    this._catch = items;\n    return this;\n  }\n\n  catchArg(arg: NodeName): this {\n    this._catchArg = arg;\n    return this;\n  }\n\n  finally(...items: Array<DoExpr>): this {\n    this._finally = items;\n    return this;\n  }\n\n  try(...items: Array<DoExpr>): this {\n    this._try = items;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    const catchParam = this._catchArg ? (this.$node(this._catchArg) as ts.BindingName) : undefined;\n\n    return ts.factory.createTryStatement(\n      this.$node(new BlockTsDsl(...this._try).pretty()),\n      ts.factory.createCatchClause(\n        catchParam ? ts.factory.createVariableDeclaration(catchParam) : undefined,\n        this.$node(new BlockTsDsl(...(this._catch ?? [])).pretty()),\n      ),\n      this._finally ? this.$node(new BlockTsDsl(...this._finally).pretty()) : undefined,\n    );\n  }\n\n  $validate(): asserts this is this & {\n    _try: Array<DoExpr>;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Try statement missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._try || this._try.length === 0) missing.push('.try()');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeName } from '@hey-api/codegen-core';\nimport { isSymbol } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl, TypeTsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { HintMixin } from '../mixins/hint';\nimport { DefaultMixin, ExportMixin } from '../mixins/modifiers';\nimport { PatternMixin } from '../mixins/pattern';\nimport { ValueMixin } from '../mixins/value';\nimport { TypeExprTsDsl } from '../type/expr';\nimport { safeRuntimeName } from '../utils/name';\n\nconst Mixed = DefaultMixin(\n  DocMixin(ExportMixin(HintMixin(PatternMixin(ValueMixin(TsDsl<ts.VariableStatement>))))),\n);\n\nexport class VarTsDsl extends Mixed {\n  readonly '~dsl' = 'VarTsDsl';\n  override readonly nameSanitizer = safeRuntimeName;\n\n  protected kind: ts.NodeFlags = ts.NodeFlags.None;\n  protected _type?: TypeTsDsl;\n\n  constructor(name?: NodeName) {\n    super();\n    if (name) this.name.set(name);\n    if (isSymbol(name)) {\n      name.setKind('var');\n    }\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.analyze(this._type);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  const(): this {\n    this.kind = ts.NodeFlags.Const;\n    return this;\n  }\n\n  let(): this {\n    this.kind = ts.NodeFlags.Let;\n    return this;\n  }\n\n  /** Sets the variable type. */\n  type(type: string | TypeTsDsl): this {\n    this._type = type instanceof TypeTsDsl ? type : new TypeExprTsDsl(type);\n    return this;\n  }\n\n  var(): this {\n    this.kind = ts.NodeFlags.None;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    const node = ts.factory.createVariableStatement(\n      this.modifiers,\n      ts.factory.createVariableDeclarationList(\n        [\n          ts.factory.createVariableDeclaration(\n            this.$pattern() ?? (this.$node(this.name) as ts.BindingName),\n            undefined,\n            this.$type(this._type),\n            this.$value(),\n          ),\n        ],\n        this.kind,\n      ),\n    );\n    return this.$docs(this.$hint(node));\n  }\n\n  $validate(): asserts this {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Variable declaration missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this.$pattern() && !this.name.toString())\n      missing.push('name or pattern (.array()/.object())');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeName, NodeScope } from '@hey-api/codegen-core';\nimport { isSymbol } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { ExportMixin } from '../mixins/modifiers';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { safeTypeName } from '../utils/name';\n\ntype Value = MaybeTsDsl<ts.TypeNode>;\n\nconst Mixed = DocMixin(ExportMixin(TypeParamsMixin(TsDsl<ts.TypeAliasDeclaration>)));\n\nexport class TypeAliasTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeAliasTsDsl';\n  override readonly nameSanitizer = safeTypeName;\n  override scope: NodeScope = 'type';\n\n  protected value?: Value;\n\n  constructor(name: NodeName, fn?: (t: TypeAliasTsDsl) => void) {\n    super();\n    this.name.set(name);\n    if (isSymbol(name)) {\n      name.setKind('type');\n    }\n    fn?.(this);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.name);\n    ctx.analyze(this.value);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Sets the type expression on the right-hand side of `= ...`. */\n  type(node: Value): this {\n    this.value = node;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    const node = ts.factory.createTypeAliasDeclaration(\n      this.modifiers,\n      this.$node(this.name) as ts.Identifier,\n      this.$generics(),\n      this.$type(this.value),\n    );\n    return this.$docs(node);\n  }\n\n  $validate(): asserts this is this & {\n    value: Value;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    const name = this.name.toString();\n    throw new Error(`Type alias${name ? ` \"${name}\"` : ''} missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this.value) missing.push('.type()');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeName, NodeScope, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\ntype Type = NodeName | ts.TypeNode | TypeTsDsl;\n\nconst Mixed = TsDsl<ts.IntersectionTypeNode>;\n\nexport class TypeAndTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeAndTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _types: Array<Ref<Type>> = [];\n\n  constructor(...nodes: Array<Type>) {\n    super();\n    this.types(...nodes);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const type of this._types) {\n      ctx.analyze(type);\n    }\n  }\n\n  types(...nodes: Array<Type>): this {\n    this._types.push(...nodes.map((n) => ref(n)));\n    return this;\n  }\n\n  override toAst() {\n    const flat: Array<ts.TypeNode> = [];\n\n    for (const node of this._types) {\n      const type = this.$type(node);\n      if (ts.isIntersectionTypeNode(type)) {\n        flat.push(...type.types);\n      } else {\n        flat.push(type);\n      }\n    }\n\n    return ts.factory.createIntersectionTypeNode(flat);\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { LiteralTsDsl } from '../expr/literal';\n\nconst Mixed = TsDsl<ts.LiteralTypeNode>;\n\nexport class TypeLiteralTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeLiteralTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected value: string | number | boolean | null;\n\n  constructor(value: string | number | boolean | null) {\n    super();\n    this.value = value;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  override toAst() {\n    return ts.factory.createLiteralTypeNode(this.$node(new LiteralTsDsl(this.value)));\n  }\n}\n","import type { AnalysisContext, NodeName, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { ReadonlyMixin } from '../mixins/modifiers';\n\nexport type TypeIdxSigType = string | MaybeTsDsl<ts.TypeNode>;\nexport type TypeIdxSigKind = 'idxSig';\n\nconst Mixed = DocMixin(ReadonlyMixin(TsDsl<ts.IndexSignatureDeclaration>));\n\nexport class TypeIdxSigTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeIdxSigTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _key?: TypeIdxSigType;\n  protected _type?: TypeIdxSigType;\n\n  constructor(name: NodeName, fn?: (i: TypeIdxSigTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn?.(this);\n  }\n\n  /** Element kind. */\n  get kind(): TypeIdxSigKind {\n    return 'idxSig';\n  }\n\n  /** Index signature parameter name. */\n  get propName(): string {\n    return this.name.toString();\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._key);\n    ctx.analyze(this._type);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Sets the key type: `[name: T]` */\n  key(type: TypeIdxSigType): this {\n    this._key = type;\n    return this;\n  }\n\n  /** Sets the property type. */\n  type(type: TypeIdxSigType): this {\n    this._type = type;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    const node = ts.factory.createIndexSignature(\n      this.modifiers,\n      [\n        ts.factory.createParameterDeclaration(\n          undefined,\n          undefined,\n          this.$node(this.name) as ts.BindingName,\n          undefined,\n          this.$type(this._key),\n        ),\n      ],\n      this.$type(this._type),\n    );\n    return this.$docs(node);\n  }\n\n  $validate(): asserts this is this & {\n    _key: TypeIdxSigType;\n    _type: TypeIdxSigType;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    const name = this.name.toString();\n    throw new Error(`Index signature${name ? ` \"${name}\"` : ''} missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._key) missing.push('.key()');\n    if (!this._type) missing.push('.\\u200Btype()');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeName, NodeScope, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { ReadonlyMixin } from '../mixins/modifiers';\nimport { OptionalMixin } from '../mixins/optional';\nimport { TokenTsDsl } from '../token';\nimport { safePropName } from '../utils/name';\n\nexport type TypePropType = NodeName | MaybeTsDsl<ts.TypeNode>;\nexport type TypePropKind = 'prop';\n\nconst Mixed = DocMixin(OptionalMixin(ReadonlyMixin(TsDsl<ts.TypeElement>)));\n\nexport class TypePropTsDsl extends Mixed {\n  readonly '~dsl' = 'TypePropTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _type?: Ref<TypePropType>;\n\n  constructor(name: NodeName, fn: (p: TypePropTsDsl) => void) {\n    super();\n    this.name.set(name);\n    fn(this);\n  }\n\n  /** Element kind. */\n  get kind(): TypePropKind {\n    return 'prop';\n  }\n\n  /** Property name. */\n  get propName(): string {\n    return this.name.toString();\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._type);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Sets the property type. */\n  type(type: TypePropType): this {\n    this._type = ref(type);\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    const name = this.name.toString();\n    const node = ts.factory.createPropertySignature(\n      this.modifiers,\n      this.$node(safePropName(name)),\n      this._optional ? this.$node(new TokenTsDsl().optional()) : undefined,\n      this.$type(this._type),\n    );\n    return this.$docs(node);\n  }\n\n  $validate(): asserts this is this & {\n    _type: Ref<TypePropType>;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    const name = this.name.toString();\n    throw new Error(`Type property${name ? ` \"${name}\"` : ''} missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._type) missing.push('.type()');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { TypeIdxSigTsDsl } from './idx-sig';\nimport { TypePropTsDsl } from './prop';\n\nconst Mixed = TsDsl<ts.TypeNode>;\n\nexport class TypeObjectTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeObjectTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _props = new Map<string, TypePropTsDsl | TypeIdxSigTsDsl>();\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const prop of this._props.values()) {\n      ctx.analyze(prop);\n    }\n  }\n\n  /** Returns true if object has at least one property or index signature. */\n  hasProps(): boolean {\n    return this._props.size > 0;\n  }\n\n  /** Adds an index signature to the object type, or removes if fn is null. */\n  idxSig(name: string, fn: ((i: TypeIdxSigTsDsl) => void) | null): this {\n    const key = `idxSig:${name}`;\n    if (fn === null) {\n      this._props.delete(key);\n    } else {\n      this._props.set(key, new TypeIdxSigTsDsl(name, fn));\n    }\n    return this;\n  }\n\n  /** Returns true if object has no properties or index signatures. */\n  get isEmpty(): boolean {\n    return this._props.size === 0;\n  }\n\n  /** Adds a property signature, or removes if fn is null. */\n  prop(name: string, fn: ((p: TypePropTsDsl) => void) | null): this {\n    const key = `prop:${name}`;\n    if (fn === null) {\n      this._props.delete(key);\n    } else {\n      this._props.set(key, new TypePropTsDsl(name, fn));\n    }\n    return this;\n  }\n\n  /** Adds multiple properties/index signatures. */\n  props(...members: ReadonlyArray<TypePropTsDsl | TypeIdxSigTsDsl>): this {\n    for (const member of members) {\n      this._props.set(`${member.kind}:${member.propName}`, member);\n    }\n    return this;\n  }\n\n  override toAst() {\n    return ts.factory.createTypeLiteralNode(this.$node([...this._props.values()]));\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.TupleTypeNode>;\n\nexport class TypeTupleTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeTupleTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _elements: Array<string | ts.TypeNode | TypeTsDsl> = [];\n\n  constructor(...nodes: Array<string | ts.TypeNode | TypeTsDsl>) {\n    super();\n    this.elements(...nodes);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const type of this._elements) {\n      ctx.analyze(type);\n    }\n  }\n\n  elements(...types: Array<string | ts.TypeNode | TypeTsDsl>): this {\n    this._elements.push(...types);\n    return this;\n  }\n\n  override toAst() {\n    return ts.factory.createTupleTypeNode(this._elements.map((t) => this.$type(t)));\n  }\n}\n","import { isNode } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport type { TsDsl } from '../base';\nimport { TypeLiteralTsDsl } from './literal';\nimport { TypeObjectTsDsl } from './object';\nimport { TypeTupleTsDsl } from './tuple';\n\nexport const fromValue = (input: unknown): TsDsl<ts.TypeNode> => {\n  if (isNode(input)) {\n    return input as TsDsl<ts.TypeNode>;\n  }\n\n  if (input === null) {\n    return new TypeLiteralTsDsl(input);\n  }\n\n  if (typeof input === 'number' || typeof input === 'boolean' || typeof input === 'string') {\n    return new TypeLiteralTsDsl(input);\n  }\n\n  if (input instanceof Array) {\n    const arr = new TypeTupleTsDsl(...input.map((v) => fromValue(v)));\n    return arr;\n  }\n\n  if (typeof input === 'object') {\n    const obj = new TypeObjectTsDsl();\n    for (const [key, val] of Object.entries(input)) {\n      const type = fromValue(val);\n      obj.prop(key, (p) => p.type(type));\n    }\n    return obj;\n  }\n\n  throw new Error(`$.type.fromValue(): Unsupported input type ${String(input)}`);\n};\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport { DocMixin } from '../mixins/doc';\nimport { ParamMixin } from '../mixins/param';\nimport { TypeParamsMixin } from '../mixins/type-params';\nimport { TypeReturnsMixin } from '../mixins/type-returns';\n\nconst Mixed = DocMixin(ParamMixin(TypeParamsMixin(TypeReturnsMixin(TsDsl<ts.FunctionTypeNode>))));\n\nexport class TypeFuncTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeFuncTsDsl';\n  override scope: NodeScope = 'type';\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  override toAst() {\n    this.$validate();\n    const node = ts.factory.createFunctionTypeNode(\n      this.$generics(),\n      this.$params(),\n      this.$returns()!,\n    );\n    return this.$docs(node);\n  }\n\n  $validate(): asserts this {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Function type missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (this.$returns() === undefined) missing.push('.returns()');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { TypeExprMixin } from '../mixins/type-expr';\nimport { f } from '../utils/factories';\n\ntype Base = string | MaybeTsDsl<ts.TypeNode>;\ntype Index = string | number | MaybeTsDsl<ts.TypeNode>;\nexport type TypeIdxCtor = (base: Base, index: Index) => TypeIdxTsDsl;\n\nconst Mixed = TypeExprMixin(TsDsl<ts.IndexedAccessTypeNode>);\n\nexport class TypeIdxTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeIdxTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _base!: Base;\n  protected _index!: Index;\n\n  constructor(base: Base, index: Index) {\n    super();\n    this.base(base);\n    this.index(index);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._base);\n    ctx.analyze(this._index);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  base(base: Base): this {\n    this._base = base;\n    return this;\n  }\n\n  index(index: Index): this {\n    this._index = index;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    return ts.factory.createIndexedAccessTypeNode(this.$type(this._base), this.$type(this._index));\n  }\n\n  $validate(): asserts this is this & {\n    _base: Base;\n    _index: Index;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Indexed access type missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (this._base === undefined) missing.push('.base()');\n    if (this._index === undefined) missing.push('.index()');\n    return missing;\n  }\n}\n\nf.type.idx.set((...args) => new TypeIdxTsDsl(...args));\n","import type { AnalysisContext, NodeName, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { TokenTsDsl } from '../token';\n\nconst Mixed = TsDsl<ts.MappedTypeNode>;\n\nexport class TypeMappedTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeMappedTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected questionToken?: TokenTsDsl<\n    ts.SyntaxKind.QuestionToken | ts.SyntaxKind.PlusToken | ts.SyntaxKind.MinusToken\n  >;\n  protected readonlyToken?: TokenTsDsl<\n    ts.SyntaxKind.ReadonlyKeyword | ts.SyntaxKind.MinusToken | ts.SyntaxKind.PlusToken\n  >;\n  protected _key?: string | MaybeTsDsl<ts.TypeNode>;\n  protected _type?: string | MaybeTsDsl<ts.TypeNode>;\n\n  constructor(name?: NodeName) {\n    super();\n    if (name) this.name.set(name);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.questionToken);\n    ctx.analyze(this.readonlyToken);\n    ctx.analyze(this._key);\n    ctx.analyze(this._type);\n  }\n\n  /** Returns true when all required builder calls are present. */\n  get isValid(): boolean {\n    return this.missingRequiredCalls().length === 0;\n  }\n\n  /** Sets the key constraint: `[K in Constraint]` */\n  key(type: string | MaybeTsDsl<ts.TypeNode>): this {\n    this._key = type;\n    return this;\n  }\n\n  /** Removes `readonly` from the mapped members (`[K in X]-readonly`). */\n  mutable(): this {\n    this.readonlyToken = new TokenTsDsl().minus();\n    return this;\n  }\n\n  /** Makes `[K in X]?:` optional. */\n  optional(): this {\n    this.questionToken = new TokenTsDsl().optional();\n    return this;\n  }\n\n  /** Makes `[K in X]` readonly */\n  readonly(): this {\n    this.readonlyToken = new TokenTsDsl().readonly();\n    return this;\n  }\n\n  /** Removes `?` from the mapped members (`[K in X]-?:`). */\n  required(): this {\n    this.questionToken = new TokenTsDsl().minus();\n    return this;\n  }\n\n  /** Sets the mapped value type: `[K in X]: ValueType` */\n  type(type: string | MaybeTsDsl<ts.TypeNode>): this {\n    this._type = type;\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    return ts.factory.createMappedTypeNode(\n      this.$node(this.readonlyToken),\n      ts.factory.createTypeParameterDeclaration(\n        undefined,\n        this.$node(this.name) as ts.Identifier,\n        this.$type(this._key),\n        undefined,\n      ),\n      undefined,\n      this.$node(this.questionToken),\n      this.$type(this._type),\n      undefined,\n    );\n  }\n\n  $validate(): asserts this is this & {\n    _key: string | MaybeTsDsl<ts.TypeNode>;\n    _type: string | MaybeTsDsl<ts.TypeNode>;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    const name = this.name.toString();\n    throw new Error(`Mapped type${name ? ` \"${name}\"` : ''} missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._key) missing.push('.key()');\n    if (!this._type) missing.push('.\\u200Btype()');\n    return missing;\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { f } from '../utils/factories';\n\ntype Op = ts.SyntaxKind.KeyOfKeyword | ts.SyntaxKind.ReadonlyKeyword | ts.SyntaxKind.UniqueKeyword;\ntype Type = string | MaybeTsDsl<ts.TypeNode>;\nexport type TypeOperatorCtor = () => TypeOperatorTsDsl;\n\nconst Mixed = TsDsl<ts.TypeOperatorNode>;\n\n/**\n * Builds a TypeScript `TypeOperatorNode`, such as:\n *\n * - `keyof T`\n * - `readonly U`\n * - `unique V`\n *\n * This DSL provides both a generic `.operator()` API and convenient\n * shorthand methods (`.keyof()`, `.readonly()`, `.unique()`).\n *\n * The node will throw during render if required fields are missing.\n */\nexport class TypeOperatorTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeOperatorTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _op?: Op;\n  protected _type?: Type;\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._type);\n  }\n\n  /** Shorthand: builds `keyof T`. */\n  keyof(type: Type): this {\n    this.operator(ts.SyntaxKind.KeyOfKeyword);\n    this.type(type);\n    return this;\n  }\n\n  /** Sets the operator explicitly. */\n  operator(op: Op): this {\n    this._op = op;\n    return this;\n  }\n\n  /** Shorthand: builds `readonly T`. */\n  readonly(type: Type): this {\n    this.operator(ts.SyntaxKind.ReadonlyKeyword);\n    this.type(type);\n    return this;\n  }\n\n  /** Sets the target type of the operator. */\n  type(type: Type): this {\n    this._type = type;\n    return this;\n  }\n\n  /** Shorthand: builds `unique T`. */\n  unique(type: Type): this {\n    this.operator(ts.SyntaxKind.UniqueKeyword);\n    this.type(type);\n    return this;\n  }\n\n  override toAst() {\n    this.$validate();\n    return ts.factory.createTypeOperatorNode(this._op, this.$type(this._type));\n  }\n\n  /** Throws if required fields are not set. */\n  $validate(): asserts this is this & {\n    _op: Op;\n    _type: Type;\n  } {\n    const missing = this.missingRequiredCalls();\n    if (missing.length === 0) return;\n    throw new Error(`Type operator missing ${missing.join(' and ')}`);\n  }\n\n  private missingRequiredCalls(): ReadonlyArray<string> {\n    const missing: Array<string> = [];\n    if (!this._op) missing.push('.operator()');\n    if (!this._type) missing.push('.\\u200Btype()');\n    return missing;\n  }\n}\n\nf.type.operator.set((...args) => new TypeOperatorTsDsl(...args));\n","import type { AnalysisContext, NodeName, NodeScope, Ref } from '@hey-api/codegen-core';\nimport { ref } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\ntype Type = NodeName | ts.TypeNode | TypeTsDsl;\n\nconst Mixed = TsDsl<ts.UnionTypeNode>;\n\nexport class TypeOrTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeOrTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _types: Array<Ref<Type>> = [];\n\n  constructor(...nodes: Array<Type>) {\n    super();\n    this.types(...nodes);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const type of this._types) {\n      ctx.analyze(type);\n    }\n  }\n\n  types(...nodes: Array<Type>): this {\n    this._types.push(...nodes.map((n) => ref(n)));\n    return this;\n  }\n\n  override toAst() {\n    const flat: Array<ts.TypeNode> = [];\n\n    for (const node of this._types) {\n      const type = this.$type(node);\n      if (ts.isUnionTypeNode(type)) {\n        flat.push(...type.types);\n      } else {\n        flat.push(type);\n      }\n    }\n\n    return ts.factory.createUnionTypeNode(flat);\n  }\n}\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../base';\nimport { TsDsl } from '../base';\nimport { TypeExprMixin } from '../mixins/type-expr';\nimport { f } from '../utils/factories';\n\nexport type TypeQueryExpr = string | MaybeTsDsl<TypeTsDsl | ts.Expression>;\nexport type TypeQueryCtor = (expr: TypeQueryExpr) => TypeQueryTsDsl;\n\nconst Mixed = TypeExprMixin(TsDsl<ts.TypeQueryNode>);\n\nexport class TypeQueryTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeQueryTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected _expr: TypeQueryExpr;\n\n  constructor(expr: TypeQueryExpr) {\n    super();\n    this._expr = expr;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this._expr);\n  }\n\n  override toAst() {\n    const expr = this.$node(this._expr);\n    return ts.factory.createTypeQueryNode(expr as unknown as ts.EntityName);\n  }\n}\n\nf.type.query.set((...args) => new TypeQueryTsDsl(...args));\n","import type { AnalysisContext, NodeScope } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nimport type { MaybeTsDsl } from '../base';\nimport { TsDsl } from '../base';\n\nconst Mixed = TsDsl<ts.TemplateLiteralTypeNode>;\n\nexport class TypeTemplateTsDsl extends Mixed {\n  readonly '~dsl' = 'TypeTemplateTsDsl';\n  override scope: NodeScope = 'type';\n\n  protected parts: Array<string | MaybeTsDsl<ts.TypeNode>> = [];\n\n  constructor(value?: string | MaybeTsDsl<ts.TypeNode>) {\n    super();\n    if (value !== undefined) this.add(value);\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    for (const part of this.parts) {\n      ctx.analyze(part);\n    }\n  }\n\n  /** Adds a raw string segment or embedded type expression. */\n  add(part: string | MaybeTsDsl<ts.TypeNode>): this {\n    this.parts.push(part);\n    return this;\n  }\n\n  override toAst() {\n    const parts = this.$node(this.parts);\n\n    const normalized: Array<string | ts.TypeNode> = [];\n    // merge consecutive string parts\n    for (let index = 0; index < parts.length; index++) {\n      const current = parts[index]!;\n      if (typeof current === 'string') {\n        let merged = current;\n        while (index + 1 < parts.length && typeof parts[index + 1] === 'string') {\n          merged += parts[index + 1]!;\n          index++;\n        }\n        normalized.push(merged);\n      } else {\n        normalized.push(current);\n      }\n    }\n\n    if (normalized.length === 0 || typeof normalized[0] !== 'string') {\n      normalized.unshift('');\n    }\n\n    if (normalized.length === 1 && typeof normalized[0] === 'string') {\n      return ts.factory.createTemplateLiteralType(ts.factory.createTemplateHead(normalized[0]), []);\n    }\n\n    if (\n      normalized.length === 2 &&\n      typeof normalized[0] === 'string' &&\n      typeof normalized[1] !== 'string'\n    ) {\n      return ts.factory.createTemplateLiteralType(ts.factory.createTemplateHead(normalized[0]), [\n        ts.factory.createTemplateLiteralTypeSpan(normalized[1]!, ts.factory.createTemplateTail('')),\n      ]);\n    }\n\n    const head = ts.factory.createTemplateHead(normalized.shift() as string);\n    const spans: Array<ts.TemplateLiteralTypeSpan> = [];\n\n    while (normalized.length) {\n      const type = normalized.shift() as ts.TypeNode;\n      const next = typeof normalized[0] === 'string' ? (normalized.shift() as string) : '';\n      const isLast = normalized.length === 0;\n      spans.push(\n        ts.factory.createTemplateLiteralTypeSpan(\n          type,\n          isLast ? ts.factory.createTemplateTail(next) : ts.factory.createTemplateMiddle(next),\n        ),\n      );\n    }\n\n    return ts.factory.createTemplateLiteralType(head, spans);\n  }\n}\n","import type { AnalysisContext } from '@hey-api/codegen-core';\nimport type ts from 'typescript';\n\nimport { TsDsl } from '../base';\nimport type { TsDslContext } from './context';\nimport { ctx } from './context';\n\nexport type LazyThunk<T extends ts.Node> = (ctx: TsDslContext) => TsDsl<T>;\n\nexport class LazyTsDsl<T extends ts.Node = ts.Node> extends TsDsl<T> {\n  readonly '~dsl' = 'LazyTsDsl';\n\n  private _thunk: LazyThunk<T>;\n\n  constructor(thunk: LazyThunk<T>) {\n    super();\n    this._thunk = thunk;\n  }\n\n  override analyze(ctx: AnalysisContext): void {\n    super.analyze(ctx);\n    ctx.analyze(this.toResult());\n  }\n\n  toResult(): TsDsl<T> {\n    return this._thunk(ctx);\n  }\n\n  override toAst(): T {\n    return this.toResult().toAst();\n  }\n}\n","import path from 'node:path';\n\nimport type { ExportModule, File, ImportModule } from '@hey-api/codegen-core';\nimport ts from 'typescript';\n\nconst printer = ts.createPrinter({\n  newLine: ts.NewLineKind.LineFeed,\n  removeComments: false,\n});\n\nconst blankFile = ts.createSourceFile('', '', ts.ScriptTarget.ESNext, false, ts.ScriptKind.TS);\n\n/** Print a TypeScript node to a string. */\nexport function astToString(node: ts.Node): string {\n  const result = printer.printNode(ts.EmitHint.Unspecified, node, blankFile);\n\n  try {\n    /**\n     * TypeScript Compiler API escapes unicode characters by default and there\n     * is no way to disable this behavior\n     * {@link https://github.com/microsoft/TypeScript/issues/36174}\n     */\n    return result.replace(/\\\\u([0-9a-fA-F]{4})/g, (_, hex: string) =>\n      String.fromCharCode(Number.parseInt(hex, 16)),\n    );\n  } catch {\n    return result;\n  }\n}\n\nexport const nodeBuiltins = new Set([\n  'buffer',\n  'child_process',\n  'cluster',\n  'console',\n  'constants',\n  'crypto',\n  'dgram',\n  'dns',\n  'domain',\n  'events',\n  'freelist',\n  'fs',\n  'http',\n  'https',\n  'module',\n  'net',\n  'os',\n  'path',\n  'process',\n  'punycode',\n  'querystring',\n  'readline',\n  'repl',\n  'stream',\n  'string_decoder',\n  'timers',\n  'tls',\n  'tty',\n  'url',\n  'util',\n  'v8',\n  'vm',\n  'worker_threads',\n  'zlib',\n]);\n\nexport type SortGroup = number;\nexport type SortDistance = number;\nexport type SortModule = string;\nexport type SortKey = [SortGroup, SortDistance, SortModule];\n\nexport type ModuleExport = Omit<ExportModule, 'from'> & {\n  /** Module specifier for re-exports, e.g. `./foo`. */\n  modulePath: string;\n};\n\nexport type ModuleImport = Omit<ImportModule, 'from'> & {\n  /** Module specifier for imports, e.g. `./foo`. */\n  modulePath: string;\n};\n\nexport function moduleSortKey({\n  file,\n  fromFile,\n  preferFileExtension,\n  root,\n}: {\n  file: Pick<File, 'finalPath'>;\n  fromFile: Pick<File, 'finalPath' | 'extension' | 'external' | 'name'>;\n  preferFileExtension: string;\n  root: string;\n}): SortKey {\n  const filePath = file.finalPath!.split(path.sep).join('/');\n  let modulePath = fromFile.finalPath!.split(path.sep).join('/');\n\n  // built-ins\n  // TODO: based on nodeBuiltins set\n\n  // external\n  if (fromFile.external && !path.isAbsolute(modulePath)) {\n    return [0, 0, modulePath];\n  }\n\n  // outside project root\n  if (!modulePath.startsWith(root.split(path.sep).join('/'))) {\n    return [1, 0, modulePath];\n  }\n\n  // local\n  const rel = path\n    .relative(path.dirname(filePath), path.dirname(modulePath))\n    .split(path.sep)\n    .join('/');\n\n  let parentCount: number;\n  // same folder\n  if (!rel.startsWith('..')) {\n    modulePath = `./${rel ? `${rel}/` : ''}${fromFile.name}${fromFile.extension ?? ''}`;\n    parentCount = 0;\n  } else {\n    modulePath = `${rel}/${fromFile.name}${fromFile.extension ?? ''}`;\n    parentCount = rel.split(path.sep).filter((segment) => segment === '..').length;\n  }\n\n  if (modulePath.endsWith('.ts')) {\n    modulePath = modulePath.slice(0, -'.ts'.length);\n  }\n  if (preferFileExtension) {\n    modulePath += preferFileExtension;\n  } else if (modulePath.endsWith('/index')) {\n    modulePath = modulePath.slice(0, -'/index'.length);\n  }\n\n  return [2, parentCount, modulePath];\n}\n","import type { RenderContext, Renderer } from '@hey-api/codegen-core';\nimport type { MaybeArray, MaybeFunc } from '@hey-api/types';\nimport ts from 'typescript';\n\nimport type { TsDsl } from '../../ts-dsl';\nimport { $ } from '../../ts-dsl';\nimport type { ModuleExport, ModuleImport, SortGroup, SortKey, SortModule } from './render-utils';\nimport { astToString, moduleSortKey } from './render-utils';\n\ntype Exports = ReadonlyArray<ReadonlyArray<ModuleExport>>;\ntype ExportsOptions = {\n  preferExportAll?: boolean;\n};\ntype Header = MaybeArray<string> | null | undefined;\ntype Imports = ReadonlyArray<ReadonlyArray<ModuleImport>>;\n\nfunction headerToLines(header: Header): ReadonlyArray<string> {\n  if (!header) return [];\n  const lines: Array<string> = [];\n  if (typeof header === 'string') {\n    lines.push(...header.split(/\\r?\\n/));\n    return lines;\n  }\n  for (const line of header) {\n    lines.push(...line.split(/\\r?\\n/));\n  }\n  return lines;\n}\n\nexport class TypeScriptRenderer implements Renderer {\n  /**\n   * Function to generate a file header.\n   *\n   * @private\n   */\n  private _header?: MaybeFunc<(ctx: RenderContext<TsDsl>) => Header>;\n  /**\n   * Whether `export * from 'module'` should be used when possible instead of named exports.\n   *\n   * @private\n   */\n  private _preferExportAll: boolean;\n  /**\n   * Controls whether imports/exports include a file extension (e.g., '.ts' or '.js').\n   *\n   * @private\n   */\n  private _preferFileExtension: string;\n  /**\n   * Optional function to transform module specifiers.\n   *\n   * @private\n   */\n  private _resolveModuleName?: (moduleName: string) => string | undefined;\n\n  constructor(\n    args: {\n      header?: MaybeFunc<(ctx: RenderContext<TsDsl>) => Header>;\n      preferExportAll?: boolean;\n      preferFileExtension?: string;\n      resolveModuleName?: (moduleName: string) => string | undefined;\n    } = {},\n  ) {\n    this._header = args.header;\n    this._preferExportAll = args.preferExportAll ?? false;\n    this._preferFileExtension = args.preferFileExtension ?? '';\n    this._resolveModuleName = args.resolveModuleName;\n  }\n\n  render(ctx: RenderContext<TsDsl>): string {\n    const header = typeof this._header === 'function' ? this._header(ctx) : this._header;\n    return TypeScriptRenderer.astToString({\n      exports: this.getExports(ctx),\n      exportsOptions: {\n        preferExportAll: this._preferExportAll,\n      },\n      header,\n      imports: this.getImports(ctx),\n      nodes: ctx.file.nodes,\n    });\n  }\n\n  supports(ctx: RenderContext): boolean {\n    return ctx.file.language === 'typescript';\n  }\n\n  static astToString(args: {\n    exports?: Exports;\n    exportsOptions?: ExportsOptions;\n    header?: Header;\n    imports?: Imports;\n    nodes?: ReadonlyArray<TsDsl>;\n    /**\n     * Whether to include a trailing newline at the end of the file.\n     *\n     * @default true\n     */\n    trailingNewline?: boolean;\n  }): string {\n    let text = '';\n    for (const header of headerToLines(args.header)) {\n      text += `${header}\\n`;\n    }\n\n    let imports = '';\n    for (const group of args.imports ?? []) {\n      if (imports) imports += '\\n';\n      for (const imp of group) {\n        imports += `${astToString(TypeScriptRenderer.toImportAst(imp))}\\n`;\n      }\n    }\n    text = `${text}${text && imports ? '\\n' : ''}${imports}`;\n\n    let nodes = '';\n    for (const node of args.nodes ?? []) {\n      if (nodes) nodes += '\\n';\n      nodes += `${astToString(node.toAst())}\\n`;\n    }\n    text = `${text}${text && nodes ? '\\n' : ''}${nodes}`;\n\n    let exports = '';\n    for (const group of args.exports ?? []) {\n      if ((!exports && nodes) || exports) exports += '\\n';\n      for (const exp of group) {\n        exports += `${astToString(TypeScriptRenderer.toExportAst(exp, args.exportsOptions))}\\n`;\n      }\n    }\n    text = `${text}${text && exports ? '\\n' : ''}${exports}`;\n\n    if (args.trailingNewline === false && text.endsWith('\\n')) {\n      text = text.slice(0, -1);\n    }\n\n    return text;\n  }\n\n  static toExportAst(group: ModuleExport, options?: ExportsOptions): ts.ExportDeclaration {\n    const specifiers = group.exports.map((exp) => {\n      const specifier = ts.factory.createExportSpecifier(\n        exp.isTypeOnly,\n        exp.sourceName !== exp.exportedName ? $.id(exp.sourceName).toAst() : undefined,\n        $.id(exp.exportedName).toAst(),\n      );\n      return specifier;\n    });\n    const exportClause = group.namespaceExport\n      ? ts.factory.createNamespaceExport($.id(group.namespaceExport).toAst())\n      : (!group.canExportAll || !options?.preferExportAll) && specifiers.length\n        ? ts.factory.createNamedExports(specifiers)\n        : undefined;\n    return ts.factory.createExportDeclaration(\n      undefined,\n      group.isTypeOnly,\n      exportClause,\n      $.literal(group.modulePath).toAst(),\n    );\n  }\n\n  static toImportAst(group: ModuleImport): ts.ImportDeclaration {\n    const specifiers = group.imports.map((imp) => {\n      const specifier = ts.factory.createImportSpecifier(\n        imp.isTypeOnly,\n        imp.sourceName !== imp.localName ? $.id(imp.sourceName).toAst() : undefined,\n        $.id(imp.localName).toAst(),\n      );\n      return specifier;\n    });\n    const importClause = ts.factory.createImportClause(\n      group.isTypeOnly,\n      group.kind === 'default' ? $.id(group.localName ?? '').toAst() : undefined,\n      group.kind === 'namespace'\n        ? ts.factory.createNamespaceImport($.id(group.localName ?? '').toAst())\n        : specifiers.length > 0\n          ? ts.factory.createNamedImports(specifiers)\n          : undefined,\n    );\n    return ts.factory.createImportDeclaration(\n      undefined,\n      importClause,\n      $.literal(group.modulePath).toAst(),\n    );\n  }\n\n  private getExports(ctx: RenderContext): Exports {\n    type ModuleEntry = {\n      group: ModuleExport;\n      sortKey: SortKey;\n    };\n\n    const groups = new Map<SortGroup, Map<SortModule, ModuleEntry>>();\n\n    for (const exp of ctx.file.exports) {\n      const sortKey = moduleSortKey({\n        file: ctx.file,\n        fromFile: exp.from,\n        preferFileExtension: this._preferFileExtension,\n        root: ctx.project.root,\n      });\n      const modulePath = this._resolveModuleName?.(sortKey[2]) ?? sortKey[2];\n      const [groupIndex] = sortKey;\n\n      if (!groups.has(groupIndex)) groups.set(groupIndex, new Map());\n      const moduleMap = groups.get(groupIndex)!;\n\n      if (!moduleMap.has(modulePath)) {\n        moduleMap.set(modulePath, {\n          group: {\n            canExportAll: exp.canExportAll,\n            exports: exp.exports,\n            isTypeOnly: exp.isTypeOnly,\n            modulePath,\n            namespaceExport: exp.namespaceExport,\n          },\n          sortKey,\n        });\n      }\n    }\n\n    const exports: Array<Array<ModuleExport>> = Array.from(groups.entries())\n      .sort((a, b) => a[0] - b[0])\n      .map(([, moduleMap]) => {\n        const entries = Array.from(moduleMap.values());\n\n        entries.sort((a, b) => {\n          const d = a.sortKey[1] - b.sortKey[1];\n          return d !== 0 ? d : a.group.modulePath.localeCompare(b.group.modulePath);\n        });\n\n        return entries.map((e) => {\n          const group = e.group;\n          if (group.namespaceExport) {\n            group.exports = [];\n          } else {\n            const isTypeOnly = !group.exports.find((exp) => !exp.isTypeOnly);\n            if (isTypeOnly) {\n              group.isTypeOnly = true;\n              for (const exp of group.exports) {\n                exp.isTypeOnly = false;\n              }\n            }\n            group.exports.sort((a, b) => a.exportedName.localeCompare(b.exportedName));\n          }\n          return group;\n        });\n      });\n\n    return exports;\n  }\n\n  private getImports(ctx: RenderContext): Imports {\n    type ModuleEntry = {\n      group: ModuleImport;\n      sortKey: SortKey;\n    };\n\n    const groups = new Map<SortGroup, Map<SortModule, ModuleEntry>>();\n\n    for (const imp of ctx.file.imports) {\n      const sortKey = moduleSortKey({\n        file: ctx.file,\n        fromFile: imp.from,\n        preferFileExtension: this._preferFileExtension,\n        root: ctx.project.root,\n      });\n      const modulePath = this._resolveModuleName?.(sortKey[2]) ?? sortKey[2];\n      const [groupIndex] = sortKey;\n\n      if (!groups.has(groupIndex)) groups.set(groupIndex, new Map());\n      const moduleMap = groups.get(groupIndex)!;\n\n      if (!moduleMap.has(modulePath)) {\n        moduleMap.set(modulePath, {\n          group: {\n            imports: [],\n            isTypeOnly: false,\n            kind: imp.kind,\n            modulePath,\n          },\n          sortKey,\n        });\n      }\n\n      const entry = moduleMap.get(modulePath)!;\n      const group = entry.group;\n\n      if (imp.kind !== 'named') {\n        group.isTypeOnly = imp.isTypeOnly;\n        group.kind = imp.kind;\n        group.localName = imp.localName;\n      } else {\n        group.imports.push(...imp.imports);\n      }\n    }\n\n    const imports: Array<Array<ModuleImport>> = Array.from(groups.entries())\n      .sort((a, b) => a[0] - b[0])\n      .map(([, moduleMap]) => {\n        const entries = Array.from(moduleMap.values());\n\n        entries.sort((a, b) => {\n          const d = a.sortKey[1] - b.sortKey[1];\n          return d !== 0 ? d : a.group.modulePath.localeCompare(b.group.modulePath);\n        });\n\n        return entries.map((e) => {\n          const group = e.group;\n          if (group.kind === 'namespace') {\n            group.imports = [];\n          } else {\n            const isTypeOnly = !group.imports.find((imp) => !imp.isTypeOnly);\n            if (isTypeOnly) {\n              group.isTypeOnly = true;\n              for (const imp of group.imports) {\n                imp.isTypeOnly = false;\n              }\n            }\n            group.imports.sort((a, b) => a.localName.localeCompare(b.localName));\n          }\n          return group;\n        });\n      });\n\n    return imports;\n  }\n}\n","import type ts from 'typescript';\n\nimport { ClassTsDsl } from './decl/class';\nimport { DecoratorTsDsl } from './decl/decorator';\nimport { EnumTsDsl } from './decl/enum';\nimport { FieldTsDsl } from './decl/field';\nimport { FuncTsDsl } from './decl/func';\nimport { GetterTsDsl } from './decl/getter';\nimport { InitTsDsl } from './decl/init';\nimport { EnumMemberTsDsl } from './decl/member';\nimport { MethodTsDsl } from './decl/method';\nimport { ParamTsDsl } from './decl/param';\nimport { PatternTsDsl } from './decl/pattern';\nimport { SetterTsDsl } from './decl/setter';\nimport { ArrayTsDsl } from './expr/array';\nimport { AsTsDsl } from './expr/as';\nimport { AttrTsDsl } from './expr/attr';\nimport { AwaitTsDsl } from './expr/await';\nimport { BinaryTsDsl } from './expr/binary';\nimport { CallTsDsl } from './expr/call';\nimport { ExprTsDsl } from './expr/expr';\nimport { fromValue as exprValue } from './expr/fromValue';\nimport { IdTsDsl } from './expr/id';\nimport { LiteralTsDsl } from './expr/literal';\nimport { NewTsDsl } from './expr/new';\nimport { ObjectTsDsl } from './expr/object';\nimport { PrefixTsDsl } from './expr/prefix';\nimport { ObjectPropTsDsl } from './expr/prop';\nimport { RegExpTsDsl } from './expr/regexp';\nimport { TemplateTsDsl } from './expr/template';\nimport { TernaryTsDsl } from './expr/ternary';\nimport { TypeOfExprTsDsl } from './expr/typeof';\nimport { DocTsDsl } from './layout/doc';\nimport { HintTsDsl } from './layout/hint';\nimport { NewlineTsDsl } from './layout/newline';\nimport { NoteTsDsl } from './layout/note';\nimport { BlockTsDsl } from './stmt/block';\nimport { IfTsDsl } from './stmt/if';\nimport { ReturnTsDsl } from './stmt/return';\nimport { StmtTsDsl } from './stmt/stmt';\nimport { ThrowTsDsl } from './stmt/throw';\nimport { TryTsDsl } from './stmt/try';\nimport { VarTsDsl } from './stmt/var';\nimport { TokenTsDsl } from './token';\nimport { TypeAliasTsDsl } from './type/alias';\nimport { TypeAndTsDsl } from './type/and';\nimport { TypeAttrTsDsl } from './type/attr';\nimport { TypeExprTsDsl } from './type/expr';\nimport { fromValue as typeValue } from './type/fromValue';\nimport { TypeFuncTsDsl } from './type/func';\nimport { TypeIdxTsDsl } from './type/idx';\nimport { TypeLiteralTsDsl } from './type/literal';\nimport { TypeMappedTsDsl } from './type/mapped';\nimport { TypeObjectTsDsl } from './type/object';\nimport { TypeOperatorTsDsl } from './type/operator';\nimport { TypeOrTsDsl } from './type/or';\nimport { TypeParamTsDsl } from './type/param';\nimport { TypeQueryTsDsl } from './type/query';\nimport { TypeTemplateTsDsl } from './type/template';\nimport { TypeTupleTsDsl } from './type/tuple';\nimport { LazyTsDsl } from './utils/lazy';\n\nconst tsDsl = {\n  /** Creates an array literal expression (e.g. `[1, 2, 3]`). */\n  array: (...args: ConstructorParameters<typeof ArrayTsDsl>) => new ArrayTsDsl(...args),\n\n  /** Creates an `as` type assertion expression (e.g. `value as Type`). */\n  as: (...args: ConstructorParameters<typeof AsTsDsl>) => new AsTsDsl(...args),\n\n  /** Creates a property access expression (e.g. `obj.foo`). */\n  attr: (...args: ConstructorParameters<typeof AttrTsDsl>) => new AttrTsDsl(...args),\n\n  /** Creates an await expression (e.g. `await promise`). */\n  await: (...args: ConstructorParameters<typeof AwaitTsDsl>) => new AwaitTsDsl(...args),\n\n  /** Creates a binary expression (e.g. `a + b`). */\n  binary: (...args: ConstructorParameters<typeof BinaryTsDsl>) => new BinaryTsDsl(...args),\n\n  /** Creates a statement block (`{ ... }`). */\n  block: (...args: ConstructorParameters<typeof BlockTsDsl>) => new BlockTsDsl(...args),\n\n  /** Creates a function or method call expression (e.g. `fn(arg)`). */\n  call: (...args: ConstructorParameters<typeof CallTsDsl>) => new CallTsDsl(...args),\n\n  /** Creates a class declaration or expression. */\n  class: (...args: ConstructorParameters<typeof ClassTsDsl>) => new ClassTsDsl(...args),\n\n  /** Creates a constant variable declaration (`const`). */\n  const: (...args: ConstructorParameters<typeof VarTsDsl>) => new VarTsDsl(...args).const(),\n\n  /** Creates a decorator expression (e.g. `@decorator`). */\n  decorator: (...args: ConstructorParameters<typeof DecoratorTsDsl>) => new DecoratorTsDsl(...args),\n\n  /** Creates a JSDoc documentation block. */\n  doc: (...args: ConstructorParameters<typeof DocTsDsl>) => new DocTsDsl(...args),\n\n  /** Creates an enum declaration. */\n  enum: (...args: ConstructorParameters<typeof EnumTsDsl>) => new EnumTsDsl(...args),\n\n  /** Creates a general expression node. */\n  expr: (...args: ConstructorParameters<typeof ExprTsDsl>) => new ExprTsDsl(...args),\n\n  /** Creates a field declaration in a class or object. */\n  field: (...args: ConstructorParameters<typeof FieldTsDsl>) => new FieldTsDsl(...args),\n\n  /** Converts a runtime value into a corresponding expression node. */\n  fromValue: (...args: Parameters<typeof exprValue>) => exprValue(...args),\n\n  /** Creates a function expression or declaration. */\n  func: ((nameOrFn?: any, fn?: any) => {\n    if (nameOrFn === undefined) return new FuncTsDsl();\n    if (typeof nameOrFn !== 'string') return new FuncTsDsl(nameOrFn);\n    if (fn === undefined) return new FuncTsDsl(nameOrFn);\n    return new FuncTsDsl(nameOrFn, fn);\n  }) as {\n    (): FuncTsDsl<'arrow'>;\n    (fn: (f: FuncTsDsl<'arrow'>) => void): FuncTsDsl<'arrow'>;\n    (name: string): FuncTsDsl<'decl'>;\n    (name: string, fn: (f: FuncTsDsl<'decl'>) => void): FuncTsDsl<'decl'>;\n    (name?: string, fn?: (f: FuncTsDsl<'decl'>) => void): FuncTsDsl<'arrow'> | FuncTsDsl<'decl'>;\n  },\n\n  /** Creates a getter method declaration. */\n  getter: (...args: ConstructorParameters<typeof GetterTsDsl>) => new GetterTsDsl(...args),\n\n  /** Creates a single-line comment (//). */\n  hint: (...args: ConstructorParameters<typeof HintTsDsl>) => new HintTsDsl(...args),\n\n  /** Creates an identifier (e.g. `foo`). */\n  id: (...args: ConstructorParameters<typeof IdTsDsl>) => new IdTsDsl(...args),\n\n  /** Creates an if statement. */\n  if: (...args: ConstructorParameters<typeof IfTsDsl>) => new IfTsDsl(...args),\n\n  /** Creates an initialization block or statement. */\n  init: (...args: ConstructorParameters<typeof InitTsDsl>) => new InitTsDsl(...args),\n\n  /** Creates a lazy, context-aware node with deferred evaluation. */\n  lazy: <T extends ts.Node>(...args: ConstructorParameters<typeof LazyTsDsl<T>>) =>\n    new LazyTsDsl<T>(...args),\n\n  /** Creates a let variable declaration (`let`). */\n  let: (...args: ConstructorParameters<typeof VarTsDsl>) => new VarTsDsl(...args).let(),\n\n  /** Creates a literal value (e.g. string, number, boolean). */\n  literal: (...args: ConstructorParameters<typeof LiteralTsDsl>) => new LiteralTsDsl(...args),\n\n  /** Creates an enum member declaration. */\n  member: (...args: ConstructorParameters<typeof EnumMemberTsDsl>) => new EnumMemberTsDsl(...args),\n\n  /** Creates a method declaration inside a class or object. */\n  method: (...args: ConstructorParameters<typeof MethodTsDsl>) => new MethodTsDsl(...args),\n\n  /** Creates a negation expression (`-x`). */\n  neg: (...args: ConstructorParameters<typeof PrefixTsDsl>) => new PrefixTsDsl(...args).neg(),\n\n  /** Creates a new expression (e.g. `new ClassName()`). */\n  new: (...args: ConstructorParameters<typeof NewTsDsl>) => new NewTsDsl(...args),\n\n  /** Creates a newline (for formatting purposes). */\n  newline: (...args: ConstructorParameters<typeof NewlineTsDsl>) => new NewlineTsDsl(...args),\n\n  /** Creates a logical NOT expression (`!x`). */\n  not: (...args: ConstructorParameters<typeof PrefixTsDsl>) => new PrefixTsDsl(...args).not(),\n\n  /** Creates a block comment (/* ... *\\/). */\n  note: (...args: ConstructorParameters<typeof NoteTsDsl>) => new NoteTsDsl(...args),\n\n  /** Creates an object literal expression. */\n  object: (...args: ConstructorParameters<typeof ObjectTsDsl>) => new ObjectTsDsl(...args),\n\n  /** Creates a parameter declaration for functions or methods. */\n  param: (...args: ConstructorParameters<typeof ParamTsDsl>) => new ParamTsDsl(...args),\n\n  /** Creates a pattern for destructuring or matching. */\n  pattern: (...args: ConstructorParameters<typeof PatternTsDsl>) => new PatternTsDsl(...args),\n\n  /** Creates a prefix unary expression (e.g. `-x`, `!x`, `~x`). */\n  prefix: (...args: ConstructorParameters<typeof PrefixTsDsl>) => new PrefixTsDsl(...args),\n\n  /** Creates an object literal property (e.g. `{ foo: bar }`). */\n  prop: (...args: ConstructorParameters<typeof ObjectPropTsDsl>) => new ObjectPropTsDsl(...args),\n\n  /** Creates a regular expression literal (e.g. `/foo/gi`). */\n  regexp: (...args: ConstructorParameters<typeof RegExpTsDsl>) => new RegExpTsDsl(...args),\n\n  /** Creates a return statement. */\n  return: (...args: ConstructorParameters<typeof ReturnTsDsl>) => new ReturnTsDsl(...args),\n\n  /** Creates a setter method declaration. */\n  setter: (...args: ConstructorParameters<typeof SetterTsDsl>) => new SetterTsDsl(...args),\n\n  /** Wraps an expression or statement-like value into a `StmtTsDsl`. */\n  stmt: (...args: ConstructorParameters<typeof StmtTsDsl>) => new StmtTsDsl(...args),\n\n  /** Creates a template literal expression. */\n  template: (...args: ConstructorParameters<typeof TemplateTsDsl>) => new TemplateTsDsl(...args),\n\n  /** Creates a ternary conditional expression (if ? then : else). */\n  ternary: (...args: ConstructorParameters<typeof TernaryTsDsl>) => new TernaryTsDsl(...args),\n\n  /** Creates a throw statement. */\n  throw: (...args: ConstructorParameters<typeof ThrowTsDsl>) => new ThrowTsDsl(...args),\n\n  /** Creates a syntax token (e.g. `?`, `readonly`, `+`, `-`). */\n  token: (...args: ConstructorParameters<typeof TokenTsDsl>) => new TokenTsDsl(...args),\n\n  /** Creates a try/catch/finally statement. */\n  try: (...args: ConstructorParameters<typeof TryTsDsl>) => new TryTsDsl(...args),\n\n  /** Creates a basic type reference or type expression (e.g. Foo or Foo<T>). */\n  type: Object.assign(\n    (...args: ConstructorParameters<typeof TypeExprTsDsl>) => new TypeExprTsDsl(...args),\n    {\n      /** Creates a type alias declaration (e.g. `type Foo = Bar`). */\n      alias: (...args: ConstructorParameters<typeof TypeAliasTsDsl>) => new TypeAliasTsDsl(...args),\n\n      /** Creates an intersection type (e.g. `A & B`). */\n      and: (...args: ConstructorParameters<typeof TypeAndTsDsl>) => new TypeAndTsDsl(...args),\n\n      /** Creates a qualified type reference (e.g. Foo.Bar). */\n      attr: (...args: ConstructorParameters<typeof TypeAttrTsDsl>) => new TypeAttrTsDsl(...args),\n\n      /** Creates a basic type reference or type expression (e.g. Foo or Foo<T>). */\n      expr: (...args: ConstructorParameters<typeof TypeExprTsDsl>) => new TypeExprTsDsl(...args),\n\n      /** Converts a runtime value into a corresponding type expression node. */\n      fromValue: (...args: Parameters<typeof typeValue>) => typeValue(...args),\n\n      /** Creates a function type node (e.g. `(a: string) => number`). */\n      func: (...args: ConstructorParameters<typeof TypeFuncTsDsl>) => new TypeFuncTsDsl(...args),\n\n      /** Creates an indexed-access type (e.g. `Foo<T>[K]`). */\n      idx: (...args: ConstructorParameters<typeof TypeIdxTsDsl>) => new TypeIdxTsDsl(...args),\n\n      /** Creates a literal type node (e.g. 'foo', 42, or true). */\n      literal: (...args: ConstructorParameters<typeof TypeLiteralTsDsl>) =>\n        new TypeLiteralTsDsl(...args),\n\n      /** Creates a mapped type (e.g. `{ [K in keyof T]: U }`). */\n      mapped: (...args: ConstructorParameters<typeof TypeMappedTsDsl>) =>\n        new TypeMappedTsDsl(...args),\n\n      /** Creates a type literal node (e.g. { foo: string }). */\n      object: (...args: ConstructorParameters<typeof TypeObjectTsDsl>) =>\n        new TypeObjectTsDsl(...args),\n\n      /** Creates a type operator node (e.g. `readonly T`, `keyof T`, `unique T`). */\n      operator: (...args: ConstructorParameters<typeof TypeOperatorTsDsl>) =>\n        new TypeOperatorTsDsl(...args),\n\n      /** Represents a union type (e.g. `A | B | C`). */\n      or: (...args: ConstructorParameters<typeof TypeOrTsDsl>) => new TypeOrTsDsl(...args),\n\n      /** Creates a type parameter (e.g. `<T>`). */\n      param: (...args: ConstructorParameters<typeof TypeParamTsDsl>) => new TypeParamTsDsl(...args),\n\n      /** Creates a type query node (e.g. `typeof Foo`). */\n      query: (...args: ConstructorParameters<typeof TypeQueryTsDsl>) => new TypeQueryTsDsl(...args),\n\n      /** Builds a TypeScript template literal *type* (e.g. `${Foo}-${Bar}` as a type). */\n      template: (...args: ConstructorParameters<typeof TypeTemplateTsDsl>) =>\n        new TypeTemplateTsDsl(...args),\n\n      /** Creates a tuple type (e.g. [A, B, C]). */\n      tuple: (...args: ConstructorParameters<typeof TypeTupleTsDsl>) => new TypeTupleTsDsl(...args),\n    },\n  ),\n\n  /** Creates a `typeof` expression (e.g. `typeof value`). */\n  typeofExpr: (...args: ConstructorParameters<typeof TypeOfExprTsDsl>) =>\n    new TypeOfExprTsDsl(...args),\n\n  /** Creates a variable declaration (`var`). */\n  var: (...args: ConstructorParameters<typeof VarTsDsl>) => new VarTsDsl(...args),\n};\n\nexport const $ = Object.assign(\n  (...args: ConstructorParameters<typeof ExprTsDsl>) => new ExprTsDsl(...args),\n  tsDsl,\n);\n\nexport type DollarTsDsl = {\n  /**\n   * Entry point to the TypeScript DSL.\n   *\n   * `$` creates a general expression node by default, but also exposes\n   * builders for all other constructs such as `.type()`, `.call()`,\n   * `.object()`, `.func()`, etc.\n   *\n   * Example:\n   * ```ts\n   * const node = $('console').attr('log').call($.literal('Hello'));\n   * ```\n   *\n   * Returns:\n   * - A new `ExprTsDsl` instance when called directly.\n   * - The `tsDsl` object for constructing more specific nodes.\n   */\n  $: typeof $;\n};\n\nexport type { MaybeTsDsl, TypeTsDsl } from './base';\nexport { TsDsl } from './base';\nexport type { CallArgs } from './expr/call';\nexport type { ExampleOptions } from './utils/context';\nexport { ctx, TsDslContext } from './utils/context';\nexport { keywords } from './utils/keywords';\nexport { regexp } from './utils/regexp';\nexport { TypeScriptRenderer } from './utils/render';\nexport { reserved } from './utils/reserved';\n","import type { Symbol } from '@hey-api/codegen-core';\n\nimport { $ } from '../../../../ts-dsl';\nimport type { HeyApiSdkPlugin } from '../types';\n\nexport const createRegistryClass = ({\n  plugin,\n  sdkSymbol,\n  symbol,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n  sdkSymbol: Symbol;\n  symbol: Symbol;\n}): ReturnType<typeof $.class> => {\n  const symbolDefaultKey = plugin.symbol('defaultKey');\n  const symbolInstances = plugin.symbol('instances');\n  return $.class(symbol)\n    .generic('T')\n    .field(symbolDefaultKey, (f) => f.private().readonly().assign($.literal('default')))\n    .newline()\n    .field(symbolInstances, (f) =>\n      f.private().readonly().type($.type('Map').generics('string', 'T')).assign($.new('Map')),\n    )\n    .newline()\n    .method('get', (m) =>\n      m\n        .returns('T')\n        .param('key', (p) => p.type('string').optional())\n        .do(\n          $.const('instance').assign(\n            $('this')\n              .attr(symbolInstances)\n              .attr('get')\n              .call($('key').coalesce($('this').attr(symbolDefaultKey))),\n          ),\n          $.if($.not('instance')).do(\n            $.throw('Error').message(\n              $.template('No SDK client found. Create one with \"new ')\n                .add(sdkSymbol)\n                .add('()\" to fix this error.'),\n            ),\n          ),\n          $.return('instance'),\n        ),\n    )\n    .newline()\n    .method('set', (m) =>\n      m\n        .returns('void')\n        .param('value', (p) => p.type('T'))\n        .param('key', (p) => p.type('string').optional())\n        .do(\n          $('this')\n            .attr(symbolInstances)\n            .attr('set')\n            .call($('key').coalesce($('this').attr(symbolDefaultKey)), 'value'),\n        ),\n    );\n};\n\nexport const createClientClass = ({\n  plugin,\n  symbol,\n}: {\n  plugin: HeyApiSdkPlugin['Instance'];\n  symbol: Symbol;\n}): ReturnType<typeof $.class> => {\n  const symClient = plugin.getSymbol({ category: 'client' });\n  const optionalClient = Boolean(plugin.config.client && symClient);\n  const symbolClient = plugin.external('client.Client');\n  return $.class(symbol)\n    .field('client', (f) => f.protected().type(symbolClient))\n    .newline()\n    .init((i) =>\n      i\n        .param('args', (p) =>\n          p\n            .optional(optionalClient)\n            .type(\n              $.type.object().prop('client', (p) => p.optional(optionalClient).type(symbolClient)),\n            ),\n        )\n        .do(\n          $('this')\n            .attr('client')\n            .assign(\n              $('args')\n                .attr('client')\n                .optional(optionalClient)\n                .$if(optionalClient, (a) => a.coalesce(symClient!)),\n            ),\n        ),\n    );\n};\n","export const nuxtTypeComposable = 'TComposable';\nexport const nuxtTypeDefault = 'DefaultT';\nexport const nuxtTypeResponse = 'ResT';\n","import type { Context, IR } from '@hey-api/shared';\n\nimport type { Auth } from '../../client-core/bundle/auth';\nimport type { HeyApiSdkPlugin } from '../types';\n\n// TODO: parser - handle more security types\nconst securitySchemeObjectToAuthObject = ({\n  securitySchemeObject,\n}: {\n  securitySchemeObject: IR.SecurityObject;\n}): Auth | undefined => {\n  if (securitySchemeObject.type === 'openIdConnect') {\n    return {\n      scheme: 'bearer',\n      type: 'http',\n    };\n  }\n\n  if (securitySchemeObject.type === 'oauth2') {\n    if (\n      securitySchemeObject.flows.password ||\n      securitySchemeObject.flows.authorizationCode ||\n      securitySchemeObject.flows.clientCredentials ||\n      securitySchemeObject.flows.implicit\n    ) {\n      return {\n        scheme: 'bearer',\n        type: 'http',\n      };\n    }\n\n    return;\n  }\n\n  if (securitySchemeObject.type === 'apiKey') {\n    if (securitySchemeObject.in === 'header') {\n      return {\n        name: securitySchemeObject.name,\n        type: 'apiKey',\n      };\n    }\n\n    if (securitySchemeObject.in === 'query' || securitySchemeObject.in == 'cookie') {\n      return {\n        in: securitySchemeObject.in,\n        name: securitySchemeObject.name,\n        type: 'apiKey',\n      };\n    }\n\n    return;\n  }\n\n  if (securitySchemeObject.type === 'http') {\n    const scheme = securitySchemeObject.scheme.toLowerCase();\n    if (scheme === 'bearer' || scheme === 'basic') {\n      return {\n        scheme: scheme as 'bearer' | 'basic',\n        type: 'http',\n      };\n    }\n\n    return;\n  }\n\n  return;\n};\n\nexport const operationAuth = ({\n  operation,\n  plugin,\n}: {\n  context: Context;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): Array<Auth> => {\n  if (!operation.security || !plugin.config.auth) {\n    return [];\n  }\n\n  const auth: Array<Auth> = [];\n\n  for (const securitySchemeObject of operation.security) {\n    const authObject = securitySchemeObjectToAuthObject({\n      securitySchemeObject,\n    });\n    if (authObject) {\n      auth.push(authObject);\n    } else if (securitySchemeObject.type !== 'mutualTLS') {\n      console.warn(\n        `❗️ SDK warning: unsupported security scheme. Please open an issue if you'd like it added https://github.com/hey-api/openapi-ts/issues\\n${JSON.stringify(securitySchemeObject, null, 2)}`,\n      );\n    }\n  }\n\n  return auth;\n};\n","import type { IR, PluginInstance } from '@hey-api/shared';\nimport { refToName, toCase } from '@hey-api/shared';\n\nimport type { Field } from '../../client-core/bundle/params';\n\ntype Location = keyof IR.ParametersObject | 'body';\n\ntype SignatureParameter = {\n  /**\n   * Is this parameter required in the SDK method signature?\n   */\n  isRequired: boolean;\n  /**\n   * Parameter name in the SDK method signature.\n   */\n  name: string;\n  /**\n   * If the name was modified due to conflicts, this holds the original name.\n   */\n  originalName?: string;\n  /**\n   * Parameter schema object.\n   */\n  schema: IR.SchemaObject;\n};\n\ntype SignatureParameters = Record<string, SignatureParameter>;\n\ntype Signature = {\n  fields: ReadonlyArray<Field>;\n  parameters: SignatureParameters;\n};\n\n/**\n * Collects and resolves all operation parameters for flattened SDK signatures.\n * - Prefixes all conflicting names with their location (e.g. path_foo, query_foo)\n * - Returns a flat map of resolved parameter names to their metadata\n */\nexport function getSignatureParameters({\n  operation,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): Signature | undefined {\n  // TODO: add cookies\n  const locations = ['header', 'path', 'query'] as const satisfies ReadonlyArray<Location>;\n  const nameToLocations: Record<string, Set<Location>> = {};\n\n  const addParameter = (name: string, location: Location): void => {\n    if (!nameToLocations[name]) {\n      nameToLocations[name] = new Set();\n    }\n    nameToLocations[name].add(location);\n  };\n\n  for (const location of locations) {\n    const parameters = operation.parameters?.[location];\n    if (parameters) {\n      for (const key in parameters) {\n        const parameter = parameters[key]!;\n        addParameter(parameter.name, location);\n      }\n    }\n  }\n\n  if (operation.body) {\n    // spread body if there's only a single object\n    if (\n      !operation.body.schema.logicalOperator &&\n      operation.body.schema.type === 'object' &&\n      operation.body.schema.properties\n    ) {\n      const properties = operation.body.schema.properties;\n      for (const key in properties) {\n        addParameter(key, 'body');\n      }\n    } else if (operation.body.schema.$ref) {\n      // alias body for more ergonomic naming, e.g. user if the type is User\n      const name = refToName(operation.body.schema.$ref);\n      const key = toCase(name, 'camelCase');\n      addParameter(key, 'body');\n    } else {\n      addParameter('body', 'body');\n    }\n  }\n\n  const conflicts = new Set<string>();\n  for (const name in nameToLocations) {\n    if (nameToLocations[name]!.size > 1) {\n      conflicts.add(name);\n    }\n  }\n\n  const signatureParameters: SignatureParameters = {};\n  const fields: Array<Field> = [];\n\n  for (const location of locations) {\n    const parameters = operation.parameters?.[location];\n    if (parameters) {\n      for (const key in parameters) {\n        const parameter = parameters[key]!;\n        const originalName = parameter.name;\n        const name = conflicts.has(originalName) ? `${location}_${originalName}` : originalName;\n        const signatureParameter: SignatureParameter = {\n          isRequired: parameter.required ?? false,\n          name,\n          schema: parameter.schema,\n        };\n        if (name !== originalName) {\n          signatureParameter.originalName = originalName;\n        }\n        signatureParameters[name] = signatureParameter;\n        fields.push({\n          in: location === 'header' ? 'headers' : location,\n          key: name,\n          ...(name !== originalName ? { map: originalName } : {}),\n        });\n      }\n    }\n  }\n\n  if (operation.body) {\n    const location = 'body';\n    if (\n      !operation.body.schema.logicalOperator &&\n      operation.body.schema.type === 'object' &&\n      operation.body.schema.properties\n    ) {\n      const properties = operation.body.schema.properties;\n      for (const originalName in properties) {\n        const property = properties[originalName]!;\n        const name = conflicts.has(originalName) ? `${location}_${originalName}` : originalName;\n        const signatureParameter: SignatureParameter = {\n          isRequired: property.required?.includes(originalName) ?? false,\n          name,\n          schema: property,\n        };\n        if (name !== originalName) {\n          signatureParameter.originalName = originalName;\n        }\n        signatureParameters[name] = signatureParameter;\n        fields.push({\n          in: location,\n          key: name,\n          ...(name !== originalName ? { map: originalName } : {}),\n        });\n      }\n    } else if (operation.body.schema.$ref) {\n      const value = refToName(operation.body.schema.$ref);\n      const originalName = toCase(value, 'camelCase');\n      const name = conflicts.has(originalName) ? `${location}_${originalName}` : originalName;\n      const signatureParameter: SignatureParameter = {\n        isRequired: operation.body.required ?? false,\n        name,\n        schema: operation.body.schema,\n      };\n      if (name !== originalName) {\n        signatureParameter.originalName = originalName;\n      }\n      signatureParameters[name] = signatureParameter;\n      fields.push({\n        key: name,\n        map: 'body',\n      });\n    } else {\n      // never alias body\n      signatureParameters.body = {\n        isRequired: operation.body.required ?? false,\n        name: 'body',\n        schema: operation.body.schema,\n      };\n      fields.push({\n        key: 'body',\n        map: 'body',\n      });\n    }\n  }\n\n  if (!Object.keys(signatureParameters).length) {\n    return;\n  }\n\n  return { fields, parameters: signatureParameters };\n}\n","import type { IR } from '@hey-api/shared';\n\nimport type { $ } from '../../../../ts-dsl';\nimport type { HeyApiSdkPlugin } from '../types';\n\ninterface ValidatorProps {\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}\n\nexport const createRequestValidator = ({\n  operation,\n  plugin,\n}: ValidatorProps): ReturnType<typeof $.func> | undefined => {\n  if (!plugin.config.validator.request) return;\n\n  const validator = plugin.getPluginOrThrow(plugin.config.validator.request);\n  if (!validator.api.createRequestValidator) return;\n\n  return validator.api.createRequestValidator({\n    operation,\n    // @ts-expect-error\n    plugin: validator,\n  });\n};\n\nexport const createResponseValidator = ({\n  operation,\n  plugin,\n}: ValidatorProps): ReturnType<typeof $.func> | undefined => {\n  if (!plugin.config.validator.response) return;\n\n  const validator = plugin.getPluginOrThrow(plugin.config.validator.response);\n  if (!validator.api.createResponseValidator) return;\n\n  return validator.api.createResponseValidator({\n    operation,\n    // @ts-expect-error\n    plugin: validator,\n  });\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { refs } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { statusCodeToGroup } from '@hey-api/shared';\n\nimport { getTypedConfig } from '../../../../config/utils';\nimport { getClientPlugin } from '../../../../plugins/@hey-api/client-core/utils';\nimport { $ } from '../../../../ts-dsl';\nimport type { Field, Fields } from '../../client-core/bundle/params';\nimport type { HeyApiSdkPlugin } from '../types';\nimport { isInstance } from '../v1/node';\nimport { operationAuth } from './auth';\nimport { nuxtTypeComposable, nuxtTypeDefault } from './constants';\nimport { getSignatureParameters } from './signature';\nimport { createRequestValidator, createResponseValidator } from './validator';\n\n/** TODO: needs complete refactor */\nexport const operationOptionsType = ({\n  isDataAllowed = true,\n  operation,\n  plugin,\n  throwOnError,\n}: {\n  isDataAllowed?: boolean;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n  throwOnError?: string;\n}): ReturnType<typeof $.type> => {\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const symbolDataType = isDataAllowed\n    ? plugin.querySymbol({\n        category: 'type',\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'data',\n        tool: 'typescript',\n      })\n    : undefined;\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n\n  if (isNuxtClient) {\n    const symbolResponseType = plugin.querySymbol({\n      category: 'type',\n      resource: 'operation',\n      resourceId: operation.id,\n      role: 'response',\n    });\n    return $.type(symbolOptions)\n      .generic(nuxtTypeComposable)\n      .generic(isDataAllowed ? (symbolDataType ?? 'unknown') : 'never')\n      .generic(symbolResponseType ?? 'unknown')\n      .generic(nuxtTypeDefault);\n  }\n\n  // TODO: refactor this to be more generic, works for now\n  if (throwOnError) {\n    return $.type(symbolOptions)\n      .generic(isDataAllowed ? (symbolDataType ?? 'unknown') : 'never')\n      .generic(throwOnError);\n  }\n  return $.type(symbolOptions).$if(!isDataAllowed || symbolDataType, (t) =>\n    t.generic(isDataAllowed ? symbolDataType! : 'never'),\n  );\n};\n\ntype OperationParameters = {\n  argNames: Array<string>;\n  fields: Array<Field | Fields>;\n  parameters: Array<ReturnType<typeof $.param>>;\n};\n\nexport function operationParameters({\n  isRequiredOptions,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): OperationParameters {\n  const result: OperationParameters = {\n    argNames: [],\n    fields: [],\n    parameters: [],\n  };\n\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  if (plugin.config.paramsStructure === 'flat') {\n    const signature = getSignatureParameters({ operation, plugin });\n    const flatParams = $.type.object();\n\n    if (signature) {\n      let isParametersRequired = false;\n\n      for (const key in signature.parameters) {\n        const parameter = signature.parameters[key]!;\n        if (parameter.isRequired) {\n          isParametersRequired = true;\n        }\n        flatParams.prop(parameter.name, (p) =>\n          p.required(parameter.isRequired).type(\n            pluginTypeScript.api.schemaToType({\n              plugin: pluginTypeScript,\n              schema: parameter.schema,\n              state: refs({\n                path: [],\n              }),\n            }),\n          ),\n        );\n      }\n\n      result.argNames.push('parameters');\n      for (const field of signature.fields) {\n        result.fields.push(field);\n      }\n\n      result.parameters.push(\n        $.param('parameters', (p) => p.required(isParametersRequired).type(flatParams)),\n      );\n    }\n  }\n\n  result.parameters.push(\n    $.param('options', (p) =>\n      p.required(isRequiredOptions).type(\n        operationOptionsType({\n          isDataAllowed: plugin.config.paramsStructure === 'grouped',\n          operation,\n          plugin,\n          throwOnError: isNuxtClient ? undefined : 'ThrowOnError',\n        }),\n      ),\n    ),\n  );\n\n  return result;\n}\n\n/**\n * Infers `responseType` value from provided response content type. This is\n * an adapted version of `getParseAs()` from the Fetch API client.\n *\n * From Axios documentation:\n * `responseType` indicates the type of data that the server will respond with\n * options are: 'arraybuffer', 'document', 'json', 'text', 'stream'\n * browser only: 'blob'\n */\nconst getResponseType = (\n  contentType: string | null | undefined,\n): 'arraybuffer' | 'blob' | 'document' | 'json' | 'stream' | 'text' | undefined => {\n  if (!contentType) {\n    return;\n  }\n\n  const cleanContent = contentType.split(';')[0]?.trim();\n\n  if (!cleanContent) {\n    return;\n  }\n\n  if (cleanContent.startsWith('application/json') || cleanContent.endsWith('+json')) {\n    return 'json';\n  }\n\n  // Axios does not handle form data out of the box\n  // if (cleanContent === 'multipart/form-data') {\n  //   return 'formData';\n  // }\n\n  if (\n    ['application/', 'audio/', 'image/', 'video/'].some((type) => cleanContent.startsWith(type))\n  ) {\n    return 'blob';\n  }\n\n  if (cleanContent.startsWith('text/')) {\n    return 'text';\n  }\n\n  return;\n};\n\nexport function operationStatements({\n  isRequiredOptions,\n  opParameters,\n  operation,\n  plugin,\n}: {\n  isRequiredOptions: boolean;\n  opParameters: OperationParameters;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): Array<ReturnType<typeof $.return | typeof $.const>> {\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: isNuxtClient ? 'response' : 'responses',\n  });\n\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: isNuxtClient ? 'error' : 'errors',\n  });\n\n  // TODO: transform parameters\n  // const query = {\n  //   BarBaz: options.query.bar_baz,\n  //   qux_quux: options.query.qux_quux,\n  //   fooBar: options.query.foo_bar,\n  // };\n\n  // if (operation.parameters) {\n  //   for (const name in operation.parameters.query) {\n  //     const parameter = operation.parameters.query[name]\n  //     if (parameter.name !== fieldName({ context, name: parameter.name })) {\n  //       console.warn(parameter.name)\n  //     }\n  //   }\n  // }\n\n  const reqOptions = $.object();\n\n  if (operation.body) {\n    // Check if body has binary format - if so, don't use JSON serializer\n    const isBinaryFormat = operation.body.schema?.format === 'binary';\n\n    switch (operation.body.type) {\n      case 'form-data': {\n        const symbol = plugin.external('client.formDataBodySerializer');\n        reqOptions.spread(symbol);\n        break;\n      }\n      case 'json':\n        // jsonBodySerializer is the default, no need to specify\n        // unless the schema has binary format\n        if (isBinaryFormat) {\n          reqOptions.prop('bodySerializer', $.literal(null));\n        }\n        break;\n      case 'text':\n      case 'octet-stream':\n        // ensure we don't use any serializer by default\n        reqOptions.prop('bodySerializer', $.literal(null));\n        break;\n      case 'url-search-params': {\n        const symbol = plugin.external('client.urlSearchParamsBodySerializer');\n        reqOptions.spread(symbol);\n        break;\n      }\n      default:\n        // For unrecognized media types with binary format, don't use JSON serializer\n        if (isBinaryFormat) {\n          reqOptions.prop('bodySerializer', $.literal(null));\n        }\n        break;\n    }\n  }\n\n  // TODO: parser - set parseAs to skip inference if every response has the same\n  // content type. currently impossible because successes do not contain\n  // header information\n\n  const paramSerializers = $.object();\n\n  for (const name in operation.parameters?.query) {\n    const parameter = operation.parameters.query[name]!;\n\n    if (parameter.schema.type === 'array' || parameter.schema.type === 'tuple') {\n      if (parameter.style !== 'form' || !parameter.explode) {\n        // override the default settings for array serialization\n        paramSerializers.prop(\n          parameter.name,\n          $.object().prop(\n            'array',\n            $.object()\n              .$if(parameter.explode === false, (o) =>\n                o.prop('explode', $.literal(parameter.explode)),\n              )\n              .$if(parameter.style !== 'form', (o) => o.prop('style', $.literal(parameter.style))),\n          ),\n        );\n      }\n    } else if (parameter.schema.type === 'object') {\n      if (parameter.style !== 'deepObject' || !parameter.explode) {\n        // override the default settings for object serialization\n        paramSerializers.prop(\n          parameter.name,\n          $.object().prop(\n            'object',\n            $.object()\n              .$if(parameter.explode === false, (o) =>\n                o.prop('explode', $.literal(parameter.explode)),\n              )\n              .$if(parameter.style !== 'deepObject', (o) =>\n                o.prop('style', $.literal(parameter.style)),\n              ),\n          ),\n        );\n      }\n    }\n  }\n\n  if (paramSerializers.hasProps()) {\n    // TODO: if all parameters have the same serialization,\n    // apply it globally to reduce output size\n    reqOptions.prop('querySerializer', $.object().prop('parameters', paramSerializers));\n  }\n\n  const requestValidator = createRequestValidator({ operation, plugin });\n  const responseValidator = createResponseValidator({ operation, plugin });\n  if (requestValidator) {\n    reqOptions.prop('requestValidator', requestValidator.arrow());\n  }\n\n  if (plugin.config.transformer) {\n    const query: SymbolMeta = {\n      category: 'transform',\n      resource: 'operation',\n      resourceId: operation.id,\n      role: 'response',\n    };\n    if (plugin.isSymbolRegistered(query)) {\n      const ref = plugin.referenceSymbol(query);\n      reqOptions.prop('responseTransformer', $(ref));\n    }\n  }\n\n  let hasServerSentEvents = false;\n  let responseTypeValue: ReturnType<typeof getResponseType> | undefined;\n\n  for (const statusCode in operation.responses) {\n    const response = operation.responses[statusCode]!;\n\n    // try to infer `responseType` option for Axios. We don't need this in\n    // Fetch API client because it automatically detects the correct response\n    // during runtime.\n    if (!responseTypeValue && client.name === '@hey-api/client-axios') {\n      // this doesn't handle default status code for now\n      if (statusCodeToGroup({ statusCode }) === '2XX') {\n        responseTypeValue = getResponseType(response.mediaType);\n        if (responseTypeValue) {\n          reqOptions.prop('responseType', $.literal(responseTypeValue));\n        }\n      }\n    }\n\n    if (response.mediaType === 'text/event-stream') {\n      hasServerSentEvents = true;\n    }\n  }\n\n  if (responseValidator) {\n    reqOptions.prop('responseValidator', responseValidator.arrow());\n  }\n\n  if (plugin.config.responseStyle === 'data') {\n    reqOptions.prop('responseStyle', $.literal(plugin.config.responseStyle));\n  }\n\n  const auth = operationAuth({ context: plugin.context, operation, plugin });\n  if (auth.length) {\n    reqOptions.prop('security', $.fromValue(auth));\n  }\n\n  reqOptions.prop('url', $.literal(operation.path));\n\n  // options must go last to allow overriding parameters above\n  reqOptions.spread('options');\n\n  const statements: Array<ReturnType<typeof $.return | typeof $.const>> = [];\n  const hasParams = opParameters.argNames.length;\n\n  if (hasParams) {\n    const args: Array<ReturnType<typeof $.expr>> = [];\n    const config: Array<ReturnType<typeof $.object>> = [];\n    for (const argName of opParameters.argNames) {\n      args.push($(argName));\n    }\n    for (const field of opParameters.fields) {\n      const shape = $.object();\n      if ('in' in field) {\n        shape.prop('in', $.literal(field.in));\n      }\n      if ('key' in field) {\n        if (field.key) {\n          shape.prop('key', $.literal(field.key));\n        }\n        if (field.map) {\n          shape.prop('map', $.literal(field.map));\n        }\n      }\n      config.push(shape);\n    }\n    const symbol = plugin.external('client.buildClientParams');\n    statements.push(\n      $.const('params').assign(\n        $(symbol).call($.array(...args), $.array($.object().prop('args', $.array(...config)))),\n      ),\n    );\n    reqOptions.spread('params');\n  }\n\n  if (operation.body) {\n    const parameterContentType = operation.parameters?.header?.['content-type'];\n    const hasRequiredContentType = Boolean(parameterContentType?.required);\n    // spreading required Content-Type on generated header would throw a TypeScript error\n    if (!hasRequiredContentType) {\n      const headers = $.object()\n        .pretty()\n        // form-data does not need Content-Type header, browser will set it automatically\n        .prop(\n          parameterContentType?.name ?? 'Content-Type',\n          $.literal(operation.body.type === 'form-data' ? null : operation.body.mediaType),\n        )\n        .spread($('options').attr('headers').required(isRequiredOptions));\n      if (hasParams) {\n        headers.spread($('params').attr('headers'));\n      }\n      reqOptions.prop('headers', headers);\n    }\n  }\n\n  const symbolClient = plugin.config.client\n    ? plugin.getSymbol({\n        category: 'client',\n      })\n    : undefined;\n\n  let clientExpression: ReturnType<typeof $.attr | typeof $.binary>;\n  const optionsClient = $('options').attr('client').required(isRequiredOptions);\n  if (isInstance(plugin)) {\n    clientExpression = optionsClient.coalesce($('this').attr('client'));\n  } else if (symbolClient) {\n    clientExpression = optionsClient.coalesce(symbolClient);\n  } else {\n    clientExpression = optionsClient;\n  }\n\n  let functionName = hasServerSentEvents ? clientExpression.attr('sse') : clientExpression;\n  functionName = functionName.attr(operation.method);\n\n  statements.push(\n    $.return(\n      functionName\n        .call(reqOptions)\n        .$if(\n          isNuxtClient,\n          (f) =>\n            f\n              .generic(nuxtTypeComposable)\n              .generic($.type.or(symbolResponseType ?? 'unknown', nuxtTypeDefault))\n              .generic(symbolErrorType ?? 'unknown')\n              .generic(nuxtTypeDefault),\n          (f) =>\n            f\n              .generic(symbolResponseType ?? 'unknown')\n              .generic(symbolErrorType ?? 'unknown')\n              .generic('ThrowOnError'),\n        )\n        .$if(plugin.config.responseStyle === 'data', (f) =>\n          f.generic($.type.literal(plugin.config.responseStyle)),\n        ),\n    ),\n  );\n\n  return statements;\n}\n","import type {\n  StructureItem,\n  StructureNode,\n  StructureShell,\n  Symbol,\n  SymbolMeta,\n} from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming, toCase } from '@hey-api/shared';\n\nimport { getTypedConfig } from '../../../../config/utils';\nimport { getClientPlugin } from '../../../../plugins/@hey-api/client-core/utils';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '../../../../plugins/shared/utils/operation';\nimport { $, ctx } from '../../../../ts-dsl';\nimport { createClientClass, createRegistryClass } from '../shared/class';\nimport { nuxtTypeComposable, nuxtTypeDefault } from '../shared/constants';\nimport { operationParameters, operationStatements } from '../shared/operation';\nimport type { HeyApiSdkPlugin } from '../types';\n\nexport interface OperationItem {\n  operation: IR.OperationObject;\n  path: ReadonlyArray<string | number>;\n  tags: ReadonlyArray<string> | undefined;\n}\n\nexport const source = globalThis.Symbol('@hey-api/sdk');\n\nexport function isInstance(plugin: HeyApiSdkPlugin['Instance']): boolean {\n  const config = plugin.config.operations;\n  return (\n    config.container === 'class' && config.methods === 'instance' && config.strategy !== 'flat'\n  );\n}\n\nfunction attachComment<T extends ReturnType<typeof $.var | typeof $.method>>(args: {\n  node: T;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): T {\n  const { node, operation, plugin } = args;\n  return node.$if(plugin.config.comments && createOperationComment(operation), (n, v) =>\n    n.doc(v),\n  ) as T;\n}\n\nfunction createShellMeta(node: StructureNode): SymbolMeta {\n  return {\n    category: 'utility',\n    resource: 'class',\n    resourceId: node.getPath().join('.'),\n    tool: 'sdk',\n  };\n}\n\nfunction createFnSymbol(\n  plugin: HeyApiSdkPlugin['Instance'],\n  item: StructureItem & { data: OperationItem },\n): Symbol {\n  const { operation, path, tags } = item.data;\n  const name = item.location[item.location.length - 1]!;\n  return plugin.symbol(applyNaming(name, plugin.config.operations.methodName), {\n    meta: {\n      category: 'sdk',\n      path,\n      resource: 'operation',\n      resourceId: operation.id,\n      tags,\n      tool: 'sdk',\n    },\n  });\n}\n\nfunction childToNode(\n  resource: StructureNode,\n  plugin: HeyApiSdkPlugin['Instance'],\n): ReadonlyArray<ReturnType<typeof $.field | typeof $.getter>> {\n  const refChild = plugin.referenceSymbol(createShellMeta(resource));\n  const memberNameStr = toCase(\n    refChild.name,\n    plugin.config.operations.methodName.casing ?? 'camelCase',\n  );\n  const memberName = plugin.symbol(memberNameStr);\n  if (isInstance(plugin)) {\n    const privateName = plugin.symbol(`_${memberNameStr}`);\n    return [\n      $.field(privateName, (f) => f.private().optional().type(refChild)),\n      $.getter(memberName, (g) =>\n        g.returns(refChild).do(\n          $('this')\n            .attr(privateName)\n            .nullishAssign(\n              $.new(refChild).args($.object().prop('client', $('this').attr('client'))),\n            )\n            .return(),\n        ),\n      ),\n    ];\n  }\n  if (plugin.isSymbolRegistered(refChild.id)) {\n    return [$.field(memberName, (f) => f.static().assign($(refChild)))];\n  }\n  return [$.getter(memberName, (g) => g.public().static().do($.return(refChild)))];\n}\n\nexport function createShell(plugin: HeyApiSdkPlugin['Instance']): StructureShell {\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isAngularClient = client.name === '@hey-api/client-angular';\n  return {\n    define: (node) => {\n      const symbol = plugin.symbol(\n        applyNaming(\n          node.name,\n          node.isRoot\n            ? plugin.config.operations.containerName\n            : plugin.config.operations.segmentName,\n        ),\n        {\n          meta: createShellMeta(node),\n        },\n      );\n\n      // if (plugin.config.operations.container === 'object') {\n      //   const o = $.const(symbol).export().assign($.object());\n      //   return { dependencies: [], node: o };\n      // }\n\n      const c = $.class(symbol)\n        .export()\n        .$if(isInstance(plugin), (c) =>\n          c.extends(\n            plugin.referenceSymbol({\n              category: 'utility',\n              resource: 'class',\n              resourceId: 'HeyApiClient',\n              tool: 'sdk',\n            }),\n          ),\n        )\n        .$if(isAngularClient && node.isRoot, (c) =>\n          c.decorator(\n            plugin.external('@angular/core.Injectable'),\n            $.object().prop('providedIn', $.literal('root')),\n          ),\n        );\n\n      const dependencies: Array<ReturnType<typeof $.class>> = [];\n\n      if (node.isRoot && isInstance(plugin)) {\n        enrichRootClass({\n          dependencies,\n          node: c,\n          plugin,\n          symbol,\n        });\n      }\n\n      return { dependencies, node: c };\n    },\n  };\n}\n\nfunction enrichRootClass(args: {\n  dependencies: Array<ReturnType<typeof $.class>>;\n  node: ReturnType<typeof $.class>;\n  plugin: HeyApiSdkPlugin['Instance'];\n  symbol: Symbol;\n}): void {\n  const { dependencies, node, plugin, symbol } = args;\n  const symbolClient = plugin.symbol('HeyApiClient', {\n    meta: {\n      category: 'utility',\n      resource: 'class',\n      resourceId: 'HeyApiClient',\n      tool: 'sdk',\n    },\n  });\n  dependencies.push(createClientClass({ plugin, symbol: symbolClient }));\n  const symbolRegistry = plugin.symbol('HeyApiRegistry', {\n    meta: {\n      category: 'utility',\n      resource: 'class',\n      resourceId: 'HeyApiRegistry',\n      tool: 'sdk',\n    },\n  });\n  dependencies.push(\n    createRegistryClass({\n      plugin,\n      sdkSymbol: symbol,\n      symbol: symbolRegistry,\n    }),\n  );\n  const isClientRequired = !plugin.config.client || !plugin.getSymbol({ category: 'client' });\n  const registry = plugin.symbol('__registry');\n  node.toAccessNode = (node, options) => {\n    if (options.context) return;\n    return $(node.name).attr(registry).attr('get').call();\n  };\n  node.do(\n    $.field(registry, (f) =>\n      f.public().static().readonly().assign($.new(symbolRegistry).generic(symbol)),\n    ),\n    $.newline(),\n    $.init((i) =>\n      i\n        .param('args', (p) =>\n          p.required(isClientRequired).type(\n            $.type\n              .object()\n              .prop('client', (p) =>\n                p.required(isClientRequired).type(plugin.external('client.Client')),\n              )\n              .prop('key', (p) => p.optional().type('string')),\n          ),\n        )\n        .do(\n          $('super').call('args'),\n          $(symbol)\n            .attr(registry)\n            .attr('set')\n            .call('this', $('args').attr('key').required(isClientRequired)),\n        ),\n    ),\n  );\n}\n\nfunction exampleIntent(\n  node: ReturnType<typeof $.method | typeof $.var>,\n  operation: IR.OperationObject,\n  plugin: HeyApiSdkPlugin['Instance'],\n): void {\n  const config = plugin.config.examples;\n  if (!config.enabled) return;\n  plugin.intent({\n    async run(context) {\n      const { payload } = config;\n      let example = ctx.example(node, {\n        ...config,\n        payload: (ctx) => (typeof payload === 'function' ? payload(operation, ctx) : payload),\n      });\n      if (config.transform) {\n        example = await config.transform(example, operation);\n      }\n      if (example) {\n        context.setExample(operation, {\n          lang: config.language,\n          source: example,\n        });\n      }\n    },\n  });\n}\n\nfunction implementFn<T extends ReturnType<typeof $.func | typeof $.method>>(args: {\n  node: T;\n  operation: IR.OperationObject;\n  plugin: HeyApiSdkPlugin['Instance'];\n}): T {\n  const { node, operation, plugin } = args;\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n  const opParameters = operationParameters({\n    isRequiredOptions,\n    operation,\n    plugin,\n  });\n  const statements = operationStatements({\n    isRequiredOptions,\n    opParameters,\n    operation,\n    plugin,\n  });\n  return node\n    .$if(\n      isNuxtClient,\n      (m) =>\n        m\n          .generic(nuxtTypeComposable, (t) =>\n            t.extends(plugin.external('client.Composable')).default($.type.literal('$fetch')),\n          )\n          .generic(nuxtTypeDefault, (t) =>\n            t.$if(\n              plugin.querySymbol({\n                category: 'type',\n                resource: 'operation',\n                resourceId: operation.id,\n                role: 'response',\n              }),\n              (t, s) => t.extends(s).default(s),\n              (t) => t.default('undefined'),\n            ),\n          ),\n      (m) =>\n        m.generic('ThrowOnError', (t) =>\n          t\n            .extends('boolean')\n            .default(\n              ('throwOnError' in client.config ? client.config.throwOnError : false) ?? false,\n            ),\n        ),\n    )\n    .params(...opParameters.parameters)\n    .do(...statements) as T;\n}\n\nexport function toNode(\n  model: StructureNode,\n  plugin: HeyApiSdkPlugin['Instance'],\n): {\n  dependencies?: Array<ReturnType<typeof $.class | typeof $.var>>;\n  nodes: ReadonlyArray<ReturnType<typeof $.class | typeof $.var>>;\n} {\n  if (model.virtual) {\n    const nodes: Array<ReturnType<typeof $.var>> = [];\n    for (const item of model.itemsFrom<OperationItem>(source)) {\n      const { operation } = item.data;\n      let node = $.const(createFnSymbol(plugin, item))\n        .export()\n        .assign(\n          implementFn({\n            node: $.func(),\n            operation,\n            plugin,\n          }),\n        );\n      node = attachComment({ node, operation, plugin });\n      nodes.push(node);\n      exampleIntent(node, operation, plugin);\n    }\n    return { nodes };\n  }\n\n  if (!model.shell) {\n    return { nodes: [] };\n  }\n\n  const nodes: Array<ReturnType<typeof $.class | typeof $.var>> = [];\n\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isAngularClient = client.name === '@hey-api/client-angular';\n\n  const shell = model.shell.define(model);\n  const node = shell.node as ReturnType<typeof $.class | typeof $.var>;\n\n  let index = 0;\n  for (const item of model.itemsFrom<OperationItem>(source)) {\n    const { operation } = item.data;\n    if (node['~dsl'] === 'VarTsDsl') {\n      // TODO: object\n    } else {\n      if (index > 0 || node.hasBody) node.newline();\n      const method = implementFn({\n        node: $.method(createFnSymbol(plugin, item), (m) =>\n          attachComment({\n            node: m,\n            operation,\n            plugin,\n          })\n            .public()\n            .static(!isAngularClient && !isInstance(plugin)),\n        ),\n        operation,\n        plugin,\n      });\n      node.do(method);\n      exampleIntent(method, operation, plugin);\n    }\n    index += 1;\n  }\n\n  for (const child of model.children.values()) {\n    if (node['~dsl'] === 'VarTsDsl') {\n      // TODO: object\n    } else {\n      if (node.hasBody) node.newline();\n      node.do(...childToNode(child, plugin));\n    }\n  }\n\n  nodes.push(node);\n\n  return {\n    dependencies: shell.dependencies as Array<ReturnType<typeof $.class | typeof $.var>>,\n    nodes,\n  };\n}\n","import type { Context, IR } from '@hey-api/shared';\nimport { escapeComment, hasOperationDataRequired } from '@hey-api/shared';\n\nimport { getTypedConfig } from '../../../config/utils';\nimport { getClientPlugin } from '../../../plugins/@hey-api/client-core/utils';\nimport type { HeyApiSdkPlugin } from '../../../plugins/@hey-api/sdk';\nimport { isInstance } from '../../../plugins/@hey-api/sdk/v1/node';\n\nexport function createOperationComment(\n  operation: IR.OperationObject,\n): ReadonlyArray<string> | undefined {\n  const comments: Array<string> = [];\n\n  if (operation.summary) {\n    comments.push(escapeComment(operation.summary));\n  }\n\n  if (operation.description) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line between summary and description\n    }\n\n    comments.push(escapeComment(operation.description));\n  }\n\n  if (operation.deprecated) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line before deprecated\n    }\n\n    comments.push('@deprecated');\n  }\n\n  return comments.length ? comments : undefined;\n}\n\n/**\n * TODO: replace with plugin logic...\n *\n * @deprecated this needs to be refactored\n */\nexport function isOperationOptionsRequired({\n  context,\n  operation,\n}: {\n  context: Context;\n  operation: IR.OperationObject;\n}): boolean {\n  const config = getTypedConfig(context);\n  const client = getClientPlugin(config);\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const plugin = config.plugins['@hey-api/sdk'];\n  if (plugin) {\n    if (!plugin.config.client && !isInstance(plugin as unknown as HeyApiSdkPlugin['Instance'])) {\n      return true;\n    }\n    if (plugin.config.paramsStructure === 'flat') {\n      return false;\n    }\n  }\n  return isNuxtClient || hasOperationDataRequired(operation);\n}\n\nexport function hasOperationSse({ operation }: { operation: IR.OperationObject }): boolean {\n  for (const statusCode in operation.responses) {\n    const response = operation.responses[statusCode]!;\n    if (response.mediaType === 'text/event-stream') {\n      return true;\n    }\n  }\n  return false;\n}\n","import type {\n  StructureItem,\n  StructureNode,\n  StructureShell,\n  Symbol,\n  SymbolMeta,\n} from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming, toCase } from '@hey-api/shared';\n\nimport { getTypedConfig } from '../../../../config/utils';\nimport { getClientPlugin } from '../../../../plugins/@hey-api/client-core/utils';\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '../../../../plugins/shared/utils/operation';\nimport { $ } from '../../../../ts-dsl';\nimport type { AngularCommonPlugin } from '../types';\n\nexport interface OperationItem {\n  operation: IR.OperationObject;\n}\n\nexport const source = globalThis.Symbol('@angular/common');\n\nfunction attachComment<T extends ReturnType<typeof $.var | typeof $.method>>(args: {\n  node: T;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}): T {\n  const { node, operation, plugin } = args;\n  return node.$if(plugin.config.comments && createOperationComment(operation), (n, v) =>\n    n.doc(v),\n  ) as T;\n}\n\nfunction createHttpRequestFnMeta(operation: IR.OperationObject): SymbolMeta {\n  return {\n    category: 'utility',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'request',\n    tool: 'angular',\n  };\n}\n\nfunction createHttpRequestShellMeta(node: StructureNode): SymbolMeta {\n  return {\n    category: 'utility',\n    resource: 'shell',\n    resourceId: node.getPath().join('.'),\n    role: 'request',\n    tool: 'angular',\n  };\n}\n\nfunction createHttpResourceFnMeta(operation: IR.OperationObject): SymbolMeta {\n  return {\n    category: 'utility',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'resource',\n    tool: 'angular',\n  };\n}\n\nfunction createHttpResourceShellMeta(node: StructureNode): SymbolMeta {\n  return {\n    category: 'utility',\n    resource: 'shell',\n    resourceId: node.getPath().join('.'),\n    role: 'resource',\n    tool: 'angular',\n  };\n}\n\nfunction createHttpRequestFnSymbol(\n  plugin: AngularCommonPlugin['Instance'],\n  item: StructureItem & { data: OperationItem },\n): Symbol {\n  const { operation } = item.data;\n  const name = item.location[item.location.length - 1]!;\n  return plugin.symbol(applyNaming(name, plugin.config.httpRequests.methodName), {\n    meta: createHttpRequestFnMeta(operation),\n  });\n}\n\nfunction createHttpResourceFnSymbol(\n  plugin: AngularCommonPlugin['Instance'],\n  item: StructureItem & { data: OperationItem },\n): Symbol {\n  const { operation } = item.data;\n  const name = item.location[item.location.length - 1]!;\n  return plugin.symbol(applyNaming(name, plugin.config.httpResources.methodName), {\n    meta: createHttpResourceFnMeta(operation),\n  });\n}\n\nfunction childToHttpRequestNode(\n  resource: StructureNode,\n  plugin: AngularCommonPlugin['Instance'],\n): ReadonlyArray<ReturnType<typeof $.field | typeof $.getter>> {\n  const refChild = plugin.referenceSymbol(createHttpRequestShellMeta(resource));\n  const memberNameStr = toCase(refChild.name, 'camelCase');\n  const memberName = plugin.symbol(memberNameStr);\n  const privateName = plugin.symbol(`_${memberNameStr}`);\n  return [\n    $.field(privateName, (f) => f.private().optional().type(refChild)),\n    $.getter(memberName, (g) =>\n      g\n        .returns(refChild)\n        .do($('this').attr(privateName).nullishAssign($.new(refChild).args()).return()),\n    ),\n  ];\n}\n\nfunction childToHttpResourceNode(\n  resource: StructureNode,\n  plugin: AngularCommonPlugin['Instance'],\n): ReadonlyArray<ReturnType<typeof $.field | typeof $.getter>> {\n  const refChild = plugin.referenceSymbol(createHttpResourceShellMeta(resource));\n  const memberNameStr = toCase(refChild.name, 'camelCase');\n  const memberName = plugin.symbol(memberNameStr);\n  const privateName = plugin.symbol(`_${memberNameStr}`);\n  return [\n    $.field(privateName, (f) => f.private().optional().type(refChild)),\n    $.getter(memberName, (g) =>\n      g\n        .returns(refChild)\n        .do($('this').attr(privateName).nullishAssign($.new(refChild).args()).return()),\n    ),\n  ];\n}\n\nexport function createHttpRequestShell(plugin: AngularCommonPlugin['Instance']): StructureShell {\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isAngularClient = client.name === '@hey-api/client-angular';\n\n  const symbolInjectable = plugin.external('@angular/core.Injectable');\n\n  return {\n    define: (node) => {\n      const symbol = plugin.symbol(\n        applyNaming(\n          node.name,\n          node.isRoot\n            ? plugin.config.httpRequests.containerName\n            : plugin.config.httpRequests.segmentName,\n        ),\n        {\n          meta: createHttpRequestShellMeta(node),\n        },\n      );\n\n      const c = $.class(symbol)\n        .export()\n        .$if(isAngularClient && node.isRoot, (c) =>\n          c.decorator(symbolInjectable, $.object().prop('providedIn', $.literal('root'))),\n        );\n\n      return { dependencies: [], node: c };\n    },\n  };\n}\n\nexport function createHttpResourceShell(plugin: AngularCommonPlugin['Instance']): StructureShell {\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isAngularClient = client.name === '@hey-api/client-angular';\n\n  const symbolInjectable = plugin.external('@angular/core.Injectable');\n\n  return {\n    define: (node) => {\n      const symbol = plugin.symbol(\n        applyNaming(\n          node.name,\n          node.isRoot\n            ? plugin.config.httpResources.containerName\n            : plugin.config.httpResources.segmentName,\n        ),\n        {\n          meta: createHttpResourceShellMeta(node),\n        },\n      );\n\n      const c = $.class(symbol)\n        .export()\n        .$if(isAngularClient && node.isRoot, (c) =>\n          c.decorator(symbolInjectable, $.object().prop('providedIn', $.literal('root'))),\n        );\n\n      return { dependencies: [], node: c };\n    },\n  };\n}\n\nfunction implementHttpRequestFn<T extends ReturnType<typeof $.func | typeof $.method>>(args: {\n  node: T;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}): T {\n  const { node, operation, plugin } = args;\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  const symbolHttpRequest = plugin.external('@angular/common/http.HttpRequest');\n  const symbolClient = plugin.getSymbol({ category: 'client' });\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolDataType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'typescript',\n  });\n\n  return node\n    .param('options', (p) =>\n      p.required(isRequiredOptions).type(\n        $.type(symbolOptions)\n          .generic(symbolDataType ?? 'unknown')\n          .generic('ThrowOnError'),\n      ),\n    )\n    .generic('ThrowOnError', (g) => g.extends('boolean').default(false))\n    .returns($.type(symbolHttpRequest).generic('unknown'))\n    .do(\n      $.return(\n        $('options')\n          .attr('client')\n          .optional()\n          .$if(symbolClient, (c, s) => c.coalesce(s))\n          .attr('requestOptions')\n          .call(\n            $.object()\n              .prop('responseStyle', $.literal('data'))\n              .prop('method', $.literal(operation.method.toUpperCase()))\n              .prop('url', $.literal(operation.path))\n              .spread('options'),\n          ),\n      ),\n    ) as T;\n}\n\nfunction implementHttpResourceFn<T extends ReturnType<typeof $.func | typeof $.method>>(args: {\n  node: T;\n  operation: IR.OperationObject;\n  plugin: AngularCommonPlugin['Instance'];\n}): T {\n  const { node, operation, plugin } = args;\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  const symbolHttpResource = plugin.external('@angular/common/http.httpResource');\n  const symbolInject = plugin.external('@angular/core.inject');\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolDataType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'typescript',\n  });\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'response',\n  });\n\n  return node\n    .param('options', (p) =>\n      p.required(isRequiredOptions).type(\n        $.type.func().returns(\n          $.type.or(\n            $.type(symbolOptions)\n              .generic(symbolDataType ?? 'unknown')\n              .generic('ThrowOnError'),\n            $.type('undefined'),\n          ),\n        ),\n      ),\n    )\n    .generic('ThrowOnError', (g) => g.extends('boolean').default(false))\n    .do(\n      $.return(\n        $(symbolHttpResource)\n          .call(\n            $.func().do(\n              $.const('opts').assign(\n                $.ternary('options').do($('options').call()).otherwise($.id('undefined')),\n              ),\n              $.return(\n                $.ternary('opts')\n                  .do(\n                    $.lazy((ctx) =>\n                      ctx\n                        .access(plugin.referenceSymbol(createHttpRequestFnMeta(operation)), {\n                          transform: (node, index) =>\n                            index === 0\n                              ? node['~dsl'] === 'ClassTsDsl'\n                                ? $(symbolInject).call($(node.name))\n                                : $(node.name)\n                              : node,\n                        })\n                        .call('opts'),\n                    ),\n                  )\n                  .otherwise($.id('undefined')),\n              ),\n            ),\n          )\n          .generic(symbolResponseType ?? 'unknown'),\n      ),\n    ) as T;\n}\n\nexport function toHttpRequestNode(\n  model: StructureNode,\n  plugin: AngularCommonPlugin['Instance'],\n): {\n  dependencies?: Array<ReturnType<typeof $.class | typeof $.var>>;\n  nodes: ReadonlyArray<ReturnType<typeof $.class | typeof $.var>>;\n} {\n  if (model.virtual) {\n    const nodes: Array<ReturnType<typeof $.var>> = [];\n    for (const item of model.itemsFrom<OperationItem>(source)) {\n      const { operation } = item.data;\n      let node = $.const(createHttpRequestFnSymbol(plugin, item))\n        .export()\n        .assign(\n          implementHttpRequestFn({\n            node: $.func(),\n            operation,\n            plugin,\n          }),\n        );\n      node = attachComment({ node, operation, plugin });\n      nodes.push(node);\n    }\n    return { nodes };\n  }\n\n  if (!model.shell) {\n    return { nodes: [] };\n  }\n\n  const nodes: Array<ReturnType<typeof $.class>> = [];\n\n  const shell = model.shell.define(model);\n  const node = shell.node as ReturnType<typeof $.class>;\n\n  let index = 0;\n  for (const item of model.itemsFrom<OperationItem>(source)) {\n    const { operation } = item.data;\n    if (index > 0 || node.hasBody) node.newline();\n    node.do(\n      implementHttpRequestFn({\n        node: $.method(createHttpRequestFnSymbol(plugin, item), (m) =>\n          attachComment({\n            node: m,\n            operation,\n            plugin,\n          }).public(),\n        ),\n        operation,\n        plugin,\n      }),\n    );\n    index += 1;\n  }\n\n  for (const child of model.children.values()) {\n    if (node.hasBody) node.newline();\n    node.do(...childToHttpRequestNode(child, plugin));\n  }\n\n  nodes.push(node);\n\n  return {\n    dependencies: shell.dependencies as Array<ReturnType<typeof $.class>>,\n    nodes,\n  };\n}\n\nexport function toHttpResourceNode(\n  model: StructureNode,\n  plugin: AngularCommonPlugin['Instance'],\n): {\n  dependencies?: Array<ReturnType<typeof $.class | typeof $.var>>;\n  nodes: ReadonlyArray<ReturnType<typeof $.class | typeof $.var>>;\n} {\n  if (model.virtual) {\n    const nodes: Array<ReturnType<typeof $.var>> = [];\n    for (const item of model.itemsFrom<OperationItem>(source)) {\n      const { operation } = item.data;\n      let node = $.const(createHttpResourceFnSymbol(plugin, item))\n        .export()\n        .assign(\n          implementHttpResourceFn({\n            node: $.func(),\n            operation,\n            plugin,\n          }),\n        );\n      node = attachComment({ node, operation, plugin });\n      nodes.push(node);\n    }\n    return { nodes };\n  }\n\n  if (!model.shell) {\n    return { nodes: [] };\n  }\n\n  const nodes: Array<ReturnType<typeof $.class>> = [];\n\n  const shell = model.shell.define(model);\n  const node = shell.node as ReturnType<typeof $.class>;\n\n  let index = 0;\n  for (const item of model.itemsFrom<OperationItem>(source)) {\n    const { operation } = item.data;\n    if (index > 0 || node.hasBody) node.newline();\n    node.do(\n      implementHttpResourceFn({\n        node: $.method(createHttpResourceFnSymbol(plugin, item), (m) =>\n          attachComment({\n            node: m,\n            operation,\n            plugin,\n          }).public(),\n        ),\n        operation,\n        plugin,\n      }),\n    );\n    index += 1;\n  }\n\n  for (const child of model.children.values()) {\n    if (node.hasBody) node.newline();\n    node.do(...childToHttpResourceNode(child, plugin));\n  }\n\n  nodes.push(node);\n\n  return {\n    dependencies: shell.dependencies as Array<ReturnType<typeof $.class>>,\n    nodes,\n  };\n}\n","import { StructureModel } from '@hey-api/codegen-core';\n\nimport type { $ } from '../../../ts-dsl';\nimport { resolveHttpRequestsStrategy } from './httpRequests';\nimport { resolveHttpResourcesStrategy } from './httpResources';\nimport type { OperationItem } from './shared/node';\nimport {\n  createHttpRequestShell,\n  createHttpResourceShell,\n  source,\n  toHttpRequestNode,\n  toHttpResourceNode,\n} from './shared/node';\nimport type { AngularCommonPlugin } from './types';\n\nexport const handler: AngularCommonPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('HttpRequest', {\n    external: '@angular/common/http',\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: '@angular/common/http.HttpRequest',\n    },\n  });\n  plugin.symbol('inject', {\n    external: '@angular/core',\n    meta: {\n      category: 'external',\n      resource: '@angular/core.inject',\n    },\n  });\n  plugin.symbol('Injectable', {\n    external: '@angular/core',\n    meta: {\n      category: 'external',\n      resource: '@angular/core.Injectable',\n    },\n  });\n  plugin.symbol('httpResource', {\n    external: '@angular/common/http',\n    meta: {\n      category: 'external',\n      resource: '@angular/common/http.httpResource',\n    },\n  });\n\n  const httpRequestStructure = new StructureModel();\n  const httpResourceStructure = new StructureModel();\n\n  if (plugin.config.httpRequests.enabled) {\n    const shell = createHttpRequestShell(plugin);\n    const strategy = resolveHttpRequestsStrategy(plugin);\n\n    plugin.forEach(\n      'operation',\n      ({ operation }) => {\n        httpRequestStructure.insert({\n          data: {\n            operation,\n          } satisfies OperationItem,\n          locations: strategy(operation).map((path) => ({ path, shell })),\n          source,\n        });\n      },\n      { order: 'declarations' },\n    );\n  }\n\n  if (plugin.config.httpResources.enabled) {\n    const shell = createHttpResourceShell(plugin);\n    const strategy = resolveHttpResourcesStrategy(plugin);\n\n    plugin.forEach(\n      'operation',\n      ({ operation }) => {\n        httpResourceStructure.insert({\n          data: {\n            operation,\n          } satisfies OperationItem,\n          locations: strategy(operation).map((path) => ({ path, shell })),\n          source,\n        });\n      },\n      { order: 'declarations' },\n    );\n  }\n\n  const allDependencies: Array<ReturnType<typeof $.class | typeof $.var>> = [];\n  const allNodes: Array<ReturnType<typeof $.class | typeof $.var>> = [];\n\n  for (const node of httpRequestStructure.walk()) {\n    const { dependencies, nodes } = toHttpRequestNode(node, plugin);\n    allDependencies.push(...(dependencies ?? []));\n    allNodes.push(...nodes);\n  }\n  for (const node of httpResourceStructure.walk()) {\n    const { dependencies, nodes } = toHttpResourceNode(node, plugin);\n    allDependencies.push(...(dependencies ?? []));\n    allNodes.push(...nodes);\n  }\n\n  const uniqueDependencies = new Map<number, ReturnType<typeof $.class | typeof $.var>>();\n  for (const dep of allDependencies) {\n    if (dep.symbol) uniqueDependencies.set(dep.symbol.id, dep);\n  }\n  for (const dep of uniqueDependencies.values()) {\n    plugin.node(dep);\n  }\n\n  for (const node of allNodes) {\n    plugin.node(node);\n  }\n};\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport { resolveHttpRequests } from './httpRequests';\nimport { resolveHttpResources } from './httpResources';\nimport { handler } from './plugin';\nimport type { AngularCommonPlugin } from './types';\n\nexport const defaultConfig: AngularCommonPlugin['Config'] = {\n  config: {\n    comments: true,\n    includeInEntry: false,\n  },\n  dependencies: ['@hey-api/client-angular', '@hey-api/sdk'],\n  handler,\n  name: '@angular/common',\n  resolveConfig: (plugin, context) => {\n    plugin.config.httpRequests = resolveHttpRequests(plugin.config, context);\n    plugin.config.httpResources = resolveHttpResources(plugin.config, context);\n  },\n};\n\n/**\n * Type helper for `@angular/common` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '@hey-api/shared';\n\nimport type { $ } from '../../../ts-dsl';\n\ntype Expression = ReturnType<typeof $.expr>;\n\nexport type IApi = {\n  /**\n   * Generate a Faker expression for a schema.\n   *\n   * Returns an expression that produces a valid instance when executed.\n   * Use when you need one-off generation without referencing shared artifacts.\n   *\n   * @example\n   * ```ts\n   * {\n   *   name: faker.person.fullName(),\n   *   email: faker.internet.email()\n   * }\n   * ```\n   */\n  toNode(schema: IR.SchemaObject): Expression;\n  /**\n   * Get a reference to a generated Faker expression for a schema.\n   *\n   * Returns a call expression referencing the shared artifact.\n   * If the artifact doesn't exist, it will be created.\n   *\n   * @example\n   * // Returns: fakeUser()\n   */\n  toNodeRef(schema: IR.SchemaObject): Expression;\n};\n\nexport class Api implements IApi {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  toNode(_schema: IR.SchemaObject): Expression {\n    return undefined as any;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  toNodeRef(_schema: IR.SchemaObject): Expression {\n    return undefined as any;\n  }\n}\n","import { definePluginConfig, mappers } from '@hey-api/shared';\n\nimport { Api } from './api';\n// import { handler } from './plugin';\nimport type { FakerJsFakerPlugin } from './types';\n\nexport const defaultConfig: FakerJsFakerPlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'camelCase',\n    includeInEntry: false,\n  },\n  // handler,\n  handler: () => {},\n  name: '@faker-js/faker',\n  resolveConfig: (plugin, context) => {\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}',\n      },\n      mappers,\n      value: plugin.config.definitions,\n    });\n  },\n  tags: ['mocker'],\n};\n\n/**\n * Type helper for Faker plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","export const clientDefaultConfig = {\n  baseUrl: true,\n  bundle: true,\n  includeInEntry: false,\n} as const;\n\nexport const clientDefaultMeta = {\n  dependencies: ['@hey-api/typescript'],\n  tags: ['client'],\n} as const;\n","import fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nimport type { IProject, ProjectRenderMeta } from '@hey-api/codegen-core';\nimport type { DefinePlugin } from '@hey-api/shared';\nimport { ensureDirSync } from '@hey-api/shared';\n\nimport type { Config } from '../config/types';\nimport type { Client } from '../plugins/@hey-api/client-core/types';\nimport { getClientPlugin } from '../plugins/@hey-api/client-core/utils';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n/**\n * Dev mode: 'src' appears after 'dist' (or dist doesn't exist), and 'generate' follows 'src'\n */\nfunction isDevMode(): boolean {\n  const normalized = __dirname.split(path.sep);\n  const srcIndex = normalized.lastIndexOf('src');\n  const distIndex = normalized.lastIndexOf('dist');\n  return (\n    srcIndex !== -1 &&\n    srcIndex > distIndex &&\n    srcIndex === normalized.length - 2 &&\n    normalized[srcIndex + 1] === 'generate'\n  );\n}\n\n/**\n * Returns paths to client bundle files based on execution context\n */\nfunction getClientBundlePaths(pluginName: string): {\n  clientPath: string;\n  corePath: string;\n} {\n  const clientName = pluginName.slice('@hey-api/client-'.length);\n\n  if (isDevMode()) {\n    // Dev: source bundle folders at src/plugins/@hey-api/{client}/bundle\n    const pluginsDir = path.resolve(__dirname, '..', 'plugins', '@hey-api');\n    return {\n      clientPath: path.resolve(pluginsDir, `client-${clientName}`, 'bundle'),\n      corePath: path.resolve(pluginsDir, 'client-core', 'bundle'),\n    };\n  }\n\n  // Prod: copied to dist/clients/{clientName}\n  return {\n    clientPath: path.resolve(__dirname, 'clients', clientName),\n    corePath: path.resolve(__dirname, 'clients', 'core'),\n  };\n}\n\n/**\n * Returns absolute path to the client folder. This is hard-coded for now.\n */\nexport function clientFolderAbsolutePath(config: Config): string {\n  const client = getClientPlugin(config);\n\n  if ('bundle' in client.config && client.config.bundle) {\n    // not proud of this one\n    const renamed: Map<string, string> | undefined =\n      // @ts-expect-error\n      config._FRAGILE_CLIENT_BUNDLE_RENAMED;\n    return path.resolve(config.output.path, 'client', `${renamed?.get('index') ?? 'index'}.ts`);\n  }\n\n  return client.name;\n}\n\n/**\n * Recursively copies files and directories.\n * This is a PnP-compatible alternative to fs.cpSync that works with Yarn PnP's\n * virtualized filesystem.\n */\nfunction copyRecursivePnP(src: string, dest: string): void {\n  const stat = fs.statSync(src);\n\n  if (stat.isDirectory()) {\n    if (!fs.existsSync(dest)) {\n      fs.mkdirSync(dest, { recursive: true });\n    }\n\n    const files = fs.readdirSync(src);\n    for (const file of files) {\n      copyRecursivePnP(path.join(src, file), path.join(dest, file));\n    }\n  } else {\n    const content = fs.readFileSync(src);\n    fs.writeFileSync(dest, content);\n  }\n}\n\nfunction renameFile({\n  filePath,\n  project,\n  renamed,\n}: {\n  filePath: string;\n  project: IProject;\n  renamed: Map<string, string>;\n}): void {\n  const extension = path.extname(filePath);\n  const name = path.basename(filePath, extension);\n  const renamedName = project.fileName?.(name) || name;\n  if (renamedName !== name) {\n    const outputPath = path.dirname(filePath);\n    fs.renameSync(filePath, path.resolve(outputPath, `${renamedName}${extension}`));\n    renamed.set(name, renamedName);\n  }\n}\n\nfunction replaceImports({\n  filePath,\n  isDevMode,\n  meta,\n  renamed,\n}: {\n  filePath: string;\n  isDevMode?: boolean;\n  meta: ProjectRenderMeta;\n  renamed: Map<string, string>;\n}): void {\n  let content = fs.readFileSync(filePath, 'utf8');\n\n  // Dev mode: rewrite source bundle imports to match output structure\n  if (isDevMode) {\n    // ../../client-core/bundle/foo -> ../core/foo\n    content = content.replace(/from\\s+['\"]\\.\\.\\/\\.\\.\\/client-core\\/bundle\\//g, \"from '../core/\");\n    // ../../client-core/bundle' (index import)\n    content = content.replace(/from\\s+['\"]\\.\\.\\/\\.\\.\\/client-core\\/bundle['\"]/g, \"from '../core'\");\n  }\n\n  content = content.replace(/from\\s+['\"](\\.\\.?\\/[^'\"]*?)['\"]/g, (match, importPath) => {\n    const importIndex = match.indexOf(importPath);\n    const extension = path.extname(importPath);\n    const fileName = path.basename(importPath, extension);\n    const importDir = path.dirname(importPath);\n    const replacedName =\n      (renamed.get(fileName) ?? fileName) +\n      (meta.importFileExtension ? meta.importFileExtension : extension);\n    const replacedMatch =\n      match.slice(0, importIndex) +\n      [importDir, replacedName].filter(Boolean).join('/') +\n      match.slice(importIndex + importPath.length);\n    return replacedMatch;\n  });\n\n  const header = '// This file is auto-generated by @hey-api/openapi-ts\\n\\n';\n\n  content = `${header}${content}`;\n\n  fs.writeFileSync(filePath, content, 'utf8');\n}\n\n/**\n * Creates a `client` folder containing the same modules as the client package.\n */\nexport function generateClientBundle({\n  meta,\n  outputPath,\n  plugin,\n  project,\n}: {\n  meta: ProjectRenderMeta;\n  outputPath: string;\n  plugin: DefinePlugin<Client.Config & { name: string }>['Config'];\n  project?: IProject;\n}): Map<string, string> | undefined {\n  const renamed = new Map<string, string>();\n  const devMode = isDevMode();\n\n  // copy Hey API clients to output\n  const isHeyApiClientPlugin = plugin.name.startsWith('@hey-api/client-');\n  if (isHeyApiClientPlugin) {\n    const { clientPath, corePath } = getClientBundlePaths(plugin.name);\n\n    // copy client core\n    const coreOutputPath = path.resolve(outputPath, 'core');\n    ensureDirSync(coreOutputPath);\n    copyRecursivePnP(corePath, coreOutputPath);\n\n    // copy client bundle\n    const clientOutputPath = path.resolve(outputPath, 'client');\n    ensureDirSync(clientOutputPath);\n    copyRecursivePnP(clientPath, clientOutputPath);\n\n    if (project) {\n      const copiedCoreFiles = fs.readdirSync(coreOutputPath);\n      for (const file of copiedCoreFiles) {\n        renameFile({\n          filePath: path.resolve(coreOutputPath, file),\n          project,\n          renamed,\n        });\n      }\n\n      const copiedClientFiles = fs.readdirSync(clientOutputPath);\n      for (const file of copiedClientFiles) {\n        renameFile({\n          filePath: path.resolve(clientOutputPath, file),\n          project,\n          renamed,\n        });\n      }\n    }\n\n    const coreFiles = fs.readdirSync(coreOutputPath);\n    for (const file of coreFiles) {\n      replaceImports({\n        filePath: path.resolve(coreOutputPath, file),\n        isDevMode: devMode,\n        meta,\n        renamed,\n      });\n    }\n\n    const clientFiles = fs.readdirSync(clientOutputPath);\n    for (const file of clientFiles) {\n      replaceImports({\n        filePath: path.resolve(clientOutputPath, file),\n        isDevMode: devMode,\n        meta,\n        renamed,\n      });\n    }\n    return renamed;\n  }\n\n  const clientSrcPath = path.isAbsolute(plugin.name) ? path.dirname(plugin.name) : undefined;\n\n  // copy custom local client to output\n  if (clientSrcPath) {\n    const dirPath = path.resolve(outputPath, 'client');\n    ensureDirSync(dirPath);\n    copyRecursivePnP(clientSrcPath, dirPath);\n    return;\n  }\n\n  // copy third-party client to output\n  const clientModulePath = path.normalize(require.resolve(plugin.name));\n  const clientModulePathComponents = clientModulePath.split(path.sep);\n  const clientDistPath = clientModulePathComponents\n    .slice(0, clientModulePathComponents.indexOf('dist') + 1)\n    .join(path.sep);\n\n  const indexJsFile = clientModulePathComponents[clientModulePathComponents.length - 1];\n  const distFiles = [indexJsFile!, 'index.d.mts', 'index.d.cts'];\n  const dirPath = path.resolve(outputPath, 'client');\n  ensureDirSync(dirPath);\n  for (const file of distFiles) {\n    fs.copyFileSync(path.resolve(clientDistPath, file), path.resolve(dirPath, file));\n  }\n\n  return;\n}\n","import { parseUrl } from '@hey-api/shared';\n\nimport { getTypedConfig } from '../../../config/utils';\nimport { clientFolderAbsolutePath } from '../../../generate/client';\nimport { $ } from '../../../ts-dsl';\nimport type { PluginHandler } from './types';\nimport { getClientBaseUrlKey } from './utils';\n\nconst resolveBaseUrlString = ({ plugin }: Parameters<PluginHandler>[0]): string | undefined => {\n  const { baseUrl } = plugin.config;\n\n  if (baseUrl === false) {\n    return;\n  }\n\n  if (typeof baseUrl === 'string') {\n    return baseUrl;\n  }\n\n  const { servers } = plugin.context.ir;\n\n  if (!servers) {\n    return;\n  }\n\n  return servers[typeof baseUrl === 'number' ? baseUrl : 0]?.url;\n};\n\nexport const createClient: PluginHandler = ({ plugin }) => {\n  const clientModule = clientFolderAbsolutePath(getTypedConfig(plugin));\n  const symbolCreateClient = plugin.symbol('createClient', {\n    external: clientModule,\n  });\n  const symbolCreateConfig = plugin.symbol('createConfig', {\n    external: clientModule,\n  });\n  const symbolClientOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client',\n    role: 'options',\n  });\n\n  const { runtimeConfigPath } = plugin.config;\n  const symbolCreateClientConfig = runtimeConfigPath\n    ? plugin.symbol('createClientConfig', {\n        external: runtimeConfigPath,\n      })\n    : undefined;\n\n  const defaultVals = $.object();\n\n  const resolvedBaseUrl = resolveBaseUrlString({\n    plugin: plugin as any,\n  });\n  if (resolvedBaseUrl) {\n    const url = parseUrl(resolvedBaseUrl);\n    if (url.protocol && url.host && !resolvedBaseUrl.includes('{')) {\n      defaultVals.prop(getClientBaseUrlKey(getTypedConfig(plugin)), $.literal(resolvedBaseUrl));\n    } else if (resolvedBaseUrl !== '/' && resolvedBaseUrl.startsWith('/')) {\n      const baseUrl = resolvedBaseUrl.endsWith('/')\n        ? resolvedBaseUrl.slice(0, -1)\n        : resolvedBaseUrl;\n      defaultVals.prop(getClientBaseUrlKey(getTypedConfig(plugin)), $.literal(baseUrl));\n    }\n  }\n\n  if ('throwOnError' in plugin.config && plugin.config.throwOnError) {\n    defaultVals.prop('throwOnError', $.literal(true));\n  }\n\n  const createConfigParameters = [\n    $(symbolCreateConfig)\n      .call(defaultVals.hasProps() ? defaultVals : undefined)\n      .generic(symbolClientOptions),\n  ];\n\n  const symbolClient = plugin.symbol('client', {\n    meta: {\n      category: 'client',\n    },\n  });\n  const statement = $.const(symbolClient)\n    .export()\n    .assign(\n      $(symbolCreateClient).$if(\n        symbolCreateClientConfig,\n        (c, s) => c.call($(s).call(...createConfigParameters)),\n        (c) => c.call(...createConfigParameters),\n      ),\n    );\n  plugin.node(statement);\n};\n","import { getTypedConfig } from '../../../config/utils';\nimport { clientFolderAbsolutePath } from '../../../generate/client';\nimport { $ } from '../../../ts-dsl';\nimport type { PluginHandler } from './types';\n\nexport const createClientConfigType = ({ plugin }: Parameters<PluginHandler>[0]) => {\n  const clientModule = clientFolderAbsolutePath(getTypedConfig(plugin));\n  const symbolClientOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client',\n    role: 'options',\n  });\n  const symbolConfig = plugin.symbol('Config', {\n    external: clientModule,\n    kind: 'type',\n  });\n  const symbolDefaultClientOptions = plugin.symbol('ClientOptions', {\n    external: clientModule,\n    kind: 'type',\n  });\n  const symbolCreateClientConfig = plugin.symbol('CreateClientConfig');\n\n  const typeCreateClientConfig = $.type\n    .alias(symbolCreateClientConfig)\n    .export()\n    .doc([\n      'The `createClientConfig()` function will be called on client initialization',\n      \"and the returned object will become the client's initial configuration.\",\n      '',\n      'You may want to initialize your client this way instead of calling',\n      \"`setConfig()`. This is useful for example if you're using Next.js\",\n      'to ensure your client always has the correct values.',\n    ])\n    .generic('T', (g) => g.extends(symbolDefaultClientOptions).default(symbolClientOptions))\n    .type(\n      $.type\n        .func()\n        .param('override', (p) =>\n          p\n            .optional()\n            .type($.type(symbolConfig).generic($.type.and(symbolDefaultClientOptions, 'T'))),\n        )\n        .returns(\n          $.type(symbolConfig).generic(\n            $.type.and($.type('Required').generic(symbolDefaultClientOptions), 'T'),\n          ),\n        ),\n    );\n  plugin.node(typeCreateClientConfig);\n};\n","import { createClient } from './client';\nimport { createClientConfigType } from './createClientConfig';\nimport type { PluginHandler } from './types';\n\nexport const clientPluginHandler = ({ plugin }: Parameters<PluginHandler>[0]) => {\n  createClientConfigType({ plugin });\n  createClient({ plugin });\n};\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '../../../plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '../../../plugins/@hey-api/client-core/plugin';\nimport type { HeyApiClientAngularPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientAngularPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler as unknown as HeyApiClientAngularPlugin['Handler'],\n  name: '@hey-api/client-angular',\n};\n\n/**\n * Type helper for `@hey-api/client-angular` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '../../../plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '../../../plugins/@hey-api/client-core/plugin';\nimport type { HeyApiClientAxiosPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientAxiosPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler as unknown as HeyApiClientAxiosPlugin['Handler'],\n  name: '@hey-api/client-axios',\n};\n\n/**\n * Type helper for `@hey-api/client-axios` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '../../../plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '../../../plugins/@hey-api/client-core/plugin';\nimport type { HeyApiClientFetchPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientFetchPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler as unknown as HeyApiClientFetchPlugin['Handler'],\n  name: '@hey-api/client-fetch',\n};\n\n/**\n * Type helper for `@hey-api/client-fetch` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '../../../plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '../../../plugins/@hey-api/client-core/plugin';\nimport type { HeyApiClientKyPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientKyPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler as unknown as HeyApiClientKyPlugin['Handler'],\n  name: '@hey-api/client-ky',\n};\n\n/**\n * Type helper for `@hey-api/client-ky` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '../../../plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '../../../plugins/@hey-api/client-core/plugin';\nimport type { HeyApiClientNextPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientNextPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler as unknown as HeyApiClientNextPlugin['Handler'],\n  name: '@hey-api/client-next',\n};\n\n/**\n * Type helper for `@hey-api/client-next` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '../../../plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '../../../plugins/@hey-api/client-core/plugin';\nimport type { HeyApiClientNuxtPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientNuxtPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: clientDefaultConfig,\n  handler: clientPluginHandler as unknown as HeyApiClientNuxtPlugin['Handler'],\n  name: '@hey-api/client-nuxt',\n};\n\n/**\n * Type helper for `@hey-api/client-nuxt` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport {\n  clientDefaultConfig,\n  clientDefaultMeta,\n} from '../../../plugins/@hey-api/client-core/config';\nimport { clientPluginHandler } from '../../../plugins/@hey-api/client-core/plugin';\nimport type { HeyApiClientOfetchPlugin } from './types';\n\nexport const defaultConfig: HeyApiClientOfetchPlugin['Config'] = {\n  ...clientDefaultMeta,\n  config: {\n    ...clientDefaultConfig,\n    throwOnError: false,\n  },\n  handler: clientPluginHandler,\n  name: '@hey-api/client-ofetch',\n};\n\n/**\n * Type helper for `@hey-api/client-ofetch` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type {\n  Context,\n  OpenApi,\n  OpenApiV2_0_XTypes,\n  OpenApiV3_0_XTypes,\n  OpenApiV3_1_XTypes,\n} from '@hey-api/shared';\nimport { satisfies } from '@hey-api/shared';\n\nimport { $ } from '../../../ts-dsl';\nimport type { HeyApiSchemasPlugin } from './types';\n\nconst stripSchema = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema:\n    | OpenApiV2_0_XTypes['SchemaObject']\n    | OpenApiV3_0_XTypes['SchemaObject']\n    | OpenApiV3_1_XTypes['SchemaObject'];\n}) => {\n  if (plugin.config.type === 'form') {\n    if (schema.description) {\n      delete schema.description;\n    }\n\n    if (schema['x-enum-descriptions']) {\n      delete schema['x-enum-descriptions'];\n    }\n\n    if (schema['x-enum-varnames']) {\n      delete schema['x-enum-varnames'];\n    }\n\n    if (schema['x-enumNames']) {\n      delete schema['x-enumNames'];\n    }\n\n    if (schema.title) {\n      delete schema.title;\n    }\n  }\n};\n\nconst schemaToJsonSchemaDraft_04 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema: OpenApiV2_0_XTypes['SchemaObject'];\n}): OpenApiV2_0_XTypes['SchemaObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchemaDraft_04({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as unknown as OpenApiV2_0_XTypes['SchemaObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  if (schema.$ref) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n    return schema;\n  }\n\n  stripSchema({ plugin, schema });\n\n  if (schema.additionalProperties && typeof schema.additionalProperties !== 'boolean') {\n    schema.additionalProperties = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchemaDraft_04({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema: schema.items as OpenApiV2_0_XTypes['SchemaObject'],\n    });\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchemaDraft_04({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaToJsonSchemaDraft_05 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema: OpenApiV3_0_XTypes['SchemaObject'] | OpenApiV3_0_XTypes['ReferenceObject'];\n}): OpenApiV3_0_XTypes['SchemaObject'] | OpenApiV3_0_XTypes['ReferenceObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as unknown as OpenApiV3_0_XTypes['SchemaObject'] | OpenApiV3_0_XTypes['ReferenceObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  if ('$ref' in schema) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n    return schema;\n  }\n\n  stripSchema({ plugin, schema });\n\n  if (schema.additionalProperties && typeof schema.additionalProperties !== 'boolean') {\n    schema.additionalProperties = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.anyOf) {\n    schema.anyOf = schema.anyOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema: schema.items,\n    });\n  }\n\n  if (schema.oneOf) {\n    schema.oneOf = schema.oneOf.map((item) =>\n      schemaToJsonSchemaDraft_05({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchemaDraft_05({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaToJsonSchema2020_12 = ({\n  context,\n  plugin,\n  schema: _schema,\n}: {\n  context: Context;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema: OpenApiV3_1_XTypes['SchemaObject'];\n}): OpenApiV3_1_XTypes['SchemaObject'] => {\n  if (Array.isArray(_schema)) {\n    return _schema.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    ) as unknown as OpenApiV3_1_XTypes['SchemaObject'];\n  }\n\n  const schema = structuredClone(_schema);\n\n  stripSchema({ plugin, schema });\n\n  if (schema.$ref) {\n    // refs using unicode characters become encoded, didn't investigate why\n    // but the suspicion is this comes from `@hey-api/json-schema-ref-parser`\n    schema.$ref = decodeURI(schema.$ref);\n  }\n\n  if (schema.additionalProperties && typeof schema.additionalProperties !== 'boolean') {\n    schema.additionalProperties = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema: schema.additionalProperties,\n    });\n  }\n\n  if (schema.allOf) {\n    schema.allOf = schema.allOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.anyOf) {\n    schema.anyOf = schema.anyOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.items) {\n    schema.items = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema: schema.items,\n    });\n  }\n\n  if (schema.oneOf) {\n    schema.oneOf = schema.oneOf.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.prefixItems) {\n    schema.prefixItems = schema.prefixItems.map((item) =>\n      schemaToJsonSchema2020_12({\n        context,\n        plugin,\n        schema: item,\n      }),\n    );\n  }\n\n  if (schema.properties) {\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n\n      if (typeof property !== 'boolean') {\n        schema.properties[name] = schemaToJsonSchema2020_12({\n          context,\n          plugin,\n          schema: property,\n        });\n      }\n    }\n  }\n\n  return schema;\n};\n\nconst schemaName = ({\n  name,\n  plugin,\n  schema,\n}: {\n  name: string;\n  plugin: HeyApiSchemasPlugin['Instance'];\n  schema:\n    | OpenApiV2_0_XTypes['SchemaObject']\n    | OpenApiV3_0_XTypes['ReferenceObject']\n    | OpenApiV3_0_XTypes['SchemaObject']\n    | OpenApiV3_1_XTypes['SchemaObject'];\n}): string => {\n  let customName = '';\n\n  if (plugin.config.nameBuilder) {\n    if (typeof plugin.config.nameBuilder === 'function') {\n      customName = plugin.config.nameBuilder(name, schema);\n    } else {\n      customName = plugin.config.nameBuilder.replace('{{name}}', name);\n    }\n  }\n\n  if (!customName) {\n    customName = `${name}Schema`;\n  }\n\n  return customName;\n};\n\nconst schemasV2_0_X = ({\n  context,\n  plugin,\n}: {\n  context: Context<OpenApi.V2_0_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.definitions) {\n    return;\n  }\n\n  for (const name in context.spec.definitions) {\n    const schema = context.spec.definitions[name]!;\n    const symbol = plugin.symbol(schemaName({ name, plugin, schema }), {\n      meta: {\n        category: 'schema',\n        resource: 'definition',\n        resourceId: name,\n        tool: 'json-schema',\n      },\n    });\n    const obj = schemaToJsonSchemaDraft_04({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = $.const(symbol)\n      .export()\n      .assign(\n        $(\n          $.fromValue(obj, {\n            layout: 'pretty',\n          }),\n        ).as('const'),\n      );\n    plugin.node(statement);\n  }\n};\n\nconst schemasV3_0_X = ({\n  context,\n  plugin,\n}: {\n  context: Context<OpenApi.V3_0_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.components) {\n    return;\n  }\n\n  for (const name in context.spec.components.schemas) {\n    const schema = context.spec.components.schemas[name]!;\n    const symbol = plugin.symbol(schemaName({ name, plugin, schema }), {\n      meta: {\n        category: 'schema',\n        resource: 'definition',\n        resourceId: name,\n        tool: 'json-schema',\n      },\n    });\n    const obj = schemaToJsonSchemaDraft_05({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = $.const(symbol)\n      .export()\n      .assign(\n        $(\n          $.fromValue(obj, {\n            layout: 'pretty',\n          }),\n        ).as('const'),\n      );\n    plugin.node(statement);\n  }\n};\n\nconst schemasV3_1_X = ({\n  context,\n  plugin,\n}: {\n  context: Context<OpenApi.V3_1_X>;\n  plugin: HeyApiSchemasPlugin['Instance'];\n}) => {\n  if (!context.spec.components) {\n    return;\n  }\n\n  for (const name in context.spec.components.schemas) {\n    const schema = context.spec.components.schemas[name]!;\n    const symbol = plugin.symbol(schemaName({ name, plugin, schema }), {\n      meta: {\n        category: 'schema',\n        resource: 'definition',\n        resourceId: name,\n        tool: 'json-schema',\n      },\n    });\n    const obj = schemaToJsonSchema2020_12({\n      context,\n      plugin,\n      schema,\n    });\n    const statement = $.const(symbol)\n      .export()\n      .assign(\n        $(\n          $.fromValue(obj, {\n            layout: 'pretty',\n          }),\n        ).as('const'),\n      );\n    plugin.node(statement);\n  }\n};\n\nexport const handler: HeyApiSchemasPlugin['Handler'] = ({ plugin }) => {\n  if ('swagger' in plugin.context.spec) {\n    schemasV2_0_X({\n      context: plugin.context as Context<OpenApi.V2_0_X>,\n      plugin,\n    });\n    return;\n  }\n\n  if (satisfies(plugin.context.spec.openapi, '>=3.0.0 <3.1.0')) {\n    schemasV3_0_X({\n      context: plugin.context as Context<OpenApi.V3_0_X>,\n      plugin,\n    });\n    return;\n  }\n\n  if (satisfies(plugin.context.spec.openapi, '>=3.1.0')) {\n    schemasV3_1_X({\n      context: plugin.context as Context<OpenApi.V3_1_X>,\n      plugin,\n    });\n    return;\n  }\n\n  throw new Error('Unsupported OpenAPI specification');\n};\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport { handler } from './plugin';\nimport type { HeyApiSchemasPlugin } from './types';\n\nexport const defaultConfig: HeyApiSchemasPlugin['Config'] = {\n  config: {\n    includeInEntry: false,\n    nameBuilder: (name) => `${name}Schema`,\n    type: 'json',\n  },\n  handler,\n  name: '@hey-api/schemas',\n};\n\n/**\n * Type helper for `@hey-api/schemas` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { PluginContext } from '@hey-api/shared';\n\nimport type { UserConfig } from '../types';\nimport type { ExamplesConfig } from './types';\n\ntype Config = Omit<UserConfig, 'name'>;\n\nexport function resolveExamples(config: Config, context: PluginContext): ExamplesConfig {\n  return context.valueToObject({\n    defaultValue: {\n      enabled: Boolean(config.examples),\n      language: 'JavaScript',\n    },\n    mappers: {\n      boolean: (enabled) => ({ enabled }),\n    },\n    value: config.examples,\n  }) as ExamplesConfig;\n}\n","import { log } from '@hey-api/codegen-core';\nimport type { OperationsStrategy, PluginContext } from '@hey-api/shared';\n\nimport type { UserConfig } from '../types';\nimport type { OperationsConfig, UserOperationsConfig } from './types';\n\ntype Config = Omit<UserConfig, 'name'>;\n\nexport function resolveOperations(config: Config, context: PluginContext): OperationsConfig {\n  if (config.asClass !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'asClass',\n      replacement: ['operations: { strategy: \"byTags\" }', 'operations: { strategy: \"single\" }'],\n    });\n  }\n\n  if (config.classNameBuilder !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'classNameBuilder',\n      replacement: 'operations: { containerName: \"...\" }',\n    });\n  }\n\n  if (config.classStructure !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'classStructure',\n      replacement: ['operations: { nesting: \"operationId\" }', 'operations: { nesting: \"id\" }'],\n    });\n  }\n\n  if (config.instance !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'instance',\n      replacement: `operations: { strategy: \"single\", containerName: \"${config.instance || 'Name'}\", methods: \"instance\" }`,\n    });\n  }\n\n  if (config.methodNameBuilder !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'methodNameBuilder',\n      replacement: 'operations: { methodName: \"...\" }',\n    });\n  }\n\n  if (config.operationId !== undefined) {\n    log.warnDeprecated({\n      context: '@hey-api/sdk',\n      field: 'operationId',\n      replacement: ['operations: { nesting: \"operationId\" }', 'operations: { nesting: \"id\" }'],\n    });\n  }\n\n  const legacy = mapLegacyToConfig(config);\n  return normalizeConfig(config.operations, legacy, context);\n}\n\nfunction normalizeConfig(\n  input: OperationsStrategy | UserOperationsConfig | undefined,\n  legacy: Partial<OperationsConfig>,\n  context: PluginContext,\n): OperationsConfig {\n  if (!input || typeof input === 'string' || typeof input === 'function') {\n    input = { strategy: input };\n  }\n\n  const strategy = legacy.strategy ?? input.strategy ?? 'flat';\n  const methods: OperationsConfig['methods'] = strategy === 'single' ? 'instance' : 'static';\n\n  return context.valueToObject({\n    defaultValue: {\n      container: 'class',\n      methods,\n      nesting: 'operationId',\n      nestingDelimiters: /[./]/,\n      strategy,\n      strategyDefaultTag: 'default',\n    },\n    mappers: {\n      object(value) {\n        value.containerName = context.valueToObject({\n          defaultValue:\n            strategy === 'single'\n              ? { casing: 'PascalCase', name: 'Sdk' }\n              : { casing: 'PascalCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.containerName,\n        });\n        value.methodName = context.valueToObject({\n          defaultValue: { casing: 'camelCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.methodName,\n        });\n        value.segmentName = context.valueToObject({\n          defaultValue: { casing: 'PascalCase' },\n          mappers: {\n            function: (name) => ({ name }),\n            string: (name) => ({ name }),\n          },\n          value: value.segmentName,\n        });\n        return value;\n      },\n    },\n    value: {\n      ...legacy,\n      ...input,\n    } as UserOperationsConfig,\n  }) as OperationsConfig;\n}\n\nfunction mapLegacyToConfig(config: Config): Partial<OperationsConfig> {\n  let strategy: OperationsConfig['strategy'] | undefined;\n  if (config.instance) {\n    strategy = 'single';\n  } else if (config.asClass) {\n    strategy = 'byTags';\n  } else if (config.instance === false || config.asClass === false) {\n    strategy = 'flat';\n  }\n\n  let containerName: OperationsConfig['containerName'] | undefined;\n  let segmentName: OperationsConfig['segmentName'] | undefined;\n  if (config.instance) {\n    let name = typeof config.instance === 'string' ? config.instance : 'Sdk';\n    segmentName = { casing: 'PascalCase' };\n    if (config.classNameBuilder) {\n      segmentName.name = config.classNameBuilder;\n      if (typeof config.classNameBuilder === 'string') {\n        name = config.classNameBuilder.replace('{{name}}', name);\n      } else {\n        name = config.classNameBuilder(name);\n      }\n    }\n    containerName = { casing: 'PascalCase', name };\n  } else if (config.classNameBuilder) {\n    containerName = {\n      casing: 'PascalCase',\n      name: config.classNameBuilder,\n    };\n    segmentName = { ...containerName };\n  } else if (config.asClass) {\n    containerName = { casing: 'PascalCase' };\n    segmentName = { ...containerName };\n  }\n\n  let methods: OperationsConfig['methods'] | undefined;\n  if (config.instance) {\n    methods = 'instance';\n  } else if (config.asClass) {\n    methods = 'static';\n  }\n\n  let nesting: OperationsConfig['nesting'] | undefined;\n  if (config.classStructure === 'off' || config.operationId === false) {\n    nesting = 'id';\n  } else if (config.classStructure === 'auto') {\n    nesting = 'operationId';\n  }\n\n  let methodName: OperationsConfig['methodName'] | undefined;\n  if (config.methodNameBuilder) {\n    methodName = {\n      casing: 'camelCase',\n      name: config.methodNameBuilder,\n    };\n  }\n\n  return {\n    containerName,\n    methodName,\n    methods,\n    nesting,\n    segmentName,\n    strategy,\n  };\n}\n","import type { OperationPathStrategy, OperationStructureStrategy } from '@hey-api/shared';\nimport { OperationPath, OperationStrategy } from '@hey-api/shared';\n\nimport type { HeyApiSdkPlugin } from '../types';\n\nfunction resolvePath(plugin: HeyApiSdkPlugin['Instance']): OperationPathStrategy {\n  if (plugin.config.operations.nesting === 'id') {\n    return OperationPath.id();\n  }\n\n  if (plugin.config.operations.nesting === 'operationId') {\n    return OperationPath.fromOperationId({\n      delimiters: plugin.config.operations.nestingDelimiters,\n      fallback: OperationPath.id(),\n    });\n  }\n\n  return plugin.config.operations.nesting;\n}\n\nexport function resolveStrategy(plugin: HeyApiSdkPlugin['Instance']): OperationStructureStrategy {\n  if (plugin.config.operations.strategy === 'flat') {\n    return OperationStrategy.flat({\n      path: (operation) => [resolvePath(plugin)(operation).join('.')],\n    });\n  }\n\n  if (plugin.config.operations.strategy === 'single') {\n    const root = plugin.config.operations.containerName;\n    return OperationStrategy.single({\n      path: resolvePath(plugin),\n      root: typeof root.name === 'string' ? root.name : (root.name?.('') ?? ''),\n    });\n  }\n\n  if (plugin.config.operations.strategy === 'byTags') {\n    return OperationStrategy.byTags({\n      fallback: plugin.config.operations.strategyDefaultTag,\n      path: resolvePath(plugin),\n    });\n  }\n\n  return plugin.config.operations.strategy;\n}\n","import { getTypedConfig } from '../../../../config/utils';\nimport { clientFolderAbsolutePath } from '../../../../generate/client';\nimport { getClientPlugin } from '../../../../plugins/@hey-api/client-core/utils';\nimport { $ } from '../../../../ts-dsl';\nimport type { HeyApiSdkPlugin } from '../types';\nimport { isInstance } from '../v1/node';\nimport { nuxtTypeDefault, nuxtTypeResponse } from './constants';\n\nexport const createTypeOptions = ({ plugin }: { plugin: HeyApiSdkPlugin['Instance'] }) => {\n  const clientModule = clientFolderAbsolutePath(getTypedConfig(plugin));\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const symbolTDataShape = plugin.symbol('TDataShape', {\n    external: clientModule,\n    kind: 'type',\n  });\n  const symbolClient = plugin.symbol('Client', {\n    external: clientModule,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: 'client.Client',\n      tool: client.name,\n    },\n  });\n  const symbolClientOptions = plugin.symbol('Options', {\n    external: clientModule,\n    kind: 'type',\n  });\n  const symbolOptions = plugin.symbol('Options', {\n    meta: {\n      category: 'type',\n      resource: 'client-options',\n      tool: 'sdk',\n    },\n  });\n\n  const typeOptions = $.type\n    .alias(symbolOptions)\n    .export()\n    .$if(\n      isNuxtClient,\n      (t) =>\n        t\n          .generic('TComposable', (g) =>\n            g.extends(plugin.external('client.Composable')).default($.type.literal('$fetch')),\n          )\n          .generic('TData', (g) => g.extends(symbolTDataShape).default(symbolTDataShape))\n          .generic(nuxtTypeResponse, (g) => g.default('unknown'))\n          .generic(nuxtTypeDefault, (g) => g.default('undefined')),\n      (t) =>\n        t\n          .generic('TData', (g) => g.extends(symbolTDataShape).default(symbolTDataShape))\n          .generic('ThrowOnError', (g) => g.extends('boolean').default('boolean')),\n    )\n    .type(\n      $.type.and(\n        $.type(symbolClientOptions).$if(\n          isNuxtClient,\n          (t) =>\n            t\n              .generic('TComposable')\n              .generic('TData')\n              .generic(nuxtTypeResponse)\n              .generic(nuxtTypeDefault),\n          (t) => t.generic('TData').generic('ThrowOnError'),\n        ),\n        $.type\n          .object()\n          .prop('client', (p) =>\n            p\n              .doc([\n                'You can provide a client instance returned by `createClient()` instead of',\n                'individual options. This might be also useful if you want to implement a',\n                'custom client.',\n              ])\n              .required(!plugin.config.client && !isInstance(plugin))\n              .type(symbolClient),\n          )\n          .prop('meta', (p) =>\n            p\n              .doc([\n                'You can pass arbitrary values through the `meta` object. This can be',\n                \"used to access values that aren't defined as part of the SDK function.\",\n              ])\n              .optional()\n              .type($.type('Record').generics('string', 'unknown')),\n          ),\n      ),\n    );\n  plugin.node(typeOptions);\n};\n","import { StructureModel } from '@hey-api/codegen-core';\n\nimport { getTypedConfig } from '../../../../config/utils';\nimport { clientFolderAbsolutePath } from '../../../../generate/client';\nimport { getClientPlugin } from '../../../../plugins/@hey-api/client-core/utils';\nimport type { $ } from '../../../../ts-dsl';\nimport { resolveStrategy } from '../operations';\nimport { createTypeOptions } from '../shared/typeOptions';\nimport type { HeyApiSdkPlugin } from '../types';\nimport type { OperationItem } from './node';\nimport { createShell, source, toNode } from './node';\n\nexport const handlerV1: HeyApiSdkPlugin['Handler'] = ({ plugin }) => {\n  const clientModule = clientFolderAbsolutePath(getTypedConfig(plugin));\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isAngularClient = client.name === '@hey-api/client-angular';\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  plugin.symbol('formDataBodySerializer', {\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: 'client.formDataBodySerializer',\n      tool: client.name,\n    },\n  });\n  plugin.symbol('urlSearchParamsBodySerializer', {\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: 'client.urlSearchParamsBodySerializer',\n      tool: client.name,\n    },\n  });\n  plugin.symbol('buildClientParams', {\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: 'client.buildClientParams',\n      tool: client.name,\n    },\n  });\n  if (isNuxtClient) {\n    plugin.symbol('Composable', {\n      external: clientModule,\n      kind: 'type',\n      meta: {\n        category: 'external',\n        resource: 'client.Composable',\n        tool: client.name,\n      },\n    });\n  }\n  if (isAngularClient) {\n    plugin.symbol('Injectable', {\n      external: '@angular/core',\n      meta: {\n        category: 'external',\n        resource: '@angular/core.Injectable',\n      },\n    });\n  }\n\n  createTypeOptions({ plugin });\n\n  const structure = new StructureModel();\n  const shell = createShell(plugin);\n  const strategy = resolveStrategy(plugin);\n\n  plugin.forEach(\n    'operation',\n    (event) => {\n      structure.insert({\n        data: {\n          operation: event.operation,\n          path: event._path,\n          tags: event.tags,\n        } satisfies OperationItem,\n        locations: strategy(event.operation).map((path) => ({ path, shell })),\n        source,\n      });\n    },\n    { order: 'declarations' },\n  );\n\n  const allDependencies: Array<ReturnType<typeof $.class | typeof $.var>> = [];\n  const allNodes: Array<ReturnType<typeof $.class | typeof $.var>> = [];\n\n  for (const node of structure.walk()) {\n    const { dependencies, nodes } = toNode(node, plugin);\n    allDependencies.push(...(dependencies ?? []));\n    allNodes.push(...nodes);\n  }\n\n  const uniqueDependencies = new Map<number, ReturnType<typeof $.class | typeof $.var>>();\n  for (const dep of allDependencies) {\n    if (dep.symbol) uniqueDependencies.set(dep.symbol.id, dep);\n  }\n  for (const dep of uniqueDependencies.values()) {\n    plugin.node(dep);\n  }\n\n  for (const node of allNodes) {\n    plugin.node(node);\n  }\n};\n","import type { HeyApiSdkPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: HeyApiSdkPlugin['Handler'] = (args) => handlerV1(args);\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport { resolveExamples } from './examples';\nimport { resolveOperations } from './operations';\nimport { handler } from './plugin';\nimport type { HeyApiSdkPlugin } from './types';\n\nexport const defaultConfig: HeyApiSdkPlugin['Config'] = {\n  config: {\n    auth: true,\n    client: true,\n    comments: true,\n    includeInEntry: true,\n    paramsStructure: 'grouped',\n    responseStyle: 'fields',\n    transformer: false,\n    validator: false,\n\n    // Deprecated - kept for backward compatibility\n    // eslint-disable-next-line sort-keys-fix/sort-keys-fix\n    response: 'body',\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  name: '@hey-api/sdk',\n  resolveConfig: (plugin, context) => {\n    if (plugin.config.client) {\n      if (typeof plugin.config.client === 'boolean') {\n        plugin.config.client = context.pluginByTag('client', {\n          defaultPlugin: '@hey-api/client-fetch',\n        });\n      }\n\n      plugin.dependencies.add(plugin.config.client!);\n    } else {\n      plugin.config.client = false;\n    }\n\n    if (plugin.config.transformer) {\n      if (typeof plugin.config.transformer === 'boolean') {\n        plugin.config.transformer = context.pluginByTag('transformer');\n      }\n\n      plugin.dependencies.add(plugin.config.transformer!);\n    } else {\n      plugin.config.transformer = false;\n    }\n\n    if (typeof plugin.config.validator !== 'object') {\n      plugin.config.validator = {\n        request: plugin.config.validator,\n        response: plugin.config.validator,\n      };\n    }\n\n    if (plugin.config.validator.request) {\n      if (typeof plugin.config.validator.request === 'boolean') {\n        plugin.config.validator.request = context.pluginByTag('validator');\n      }\n\n      plugin.dependencies.add(plugin.config.validator.request!);\n    } else {\n      plugin.config.validator.request = false;\n    }\n\n    if (plugin.config.validator.response) {\n      if (typeof plugin.config.validator.response === 'boolean') {\n        plugin.config.validator.response = context.pluginByTag('validator');\n      }\n\n      plugin.dependencies.add(plugin.config.validator.response!);\n    } else {\n      plugin.config.validator.response = false;\n    }\n\n    plugin.config.examples = resolveExamples(plugin.config, context);\n    plugin.config.operations = resolveOperations(plugin.config, context);\n  },\n};\n\n/**\n * Type helper for `@hey-api/sdk` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '@hey-api/shared';\nimport type ts from 'typescript';\n\nimport { $ } from '../../../ts-dsl';\nimport type { UserConfig } from './types';\n\nexport type ExpressionTransformer = ({\n  config,\n  dataExpression,\n  schema,\n}: {\n  config: Omit<UserConfig, 'name'>;\n  dataExpression?: ts.Expression | ReturnType<typeof $.expr | typeof $.attr> | string;\n  schema: IR.SchemaObject;\n}) => Array<ReturnType<typeof $.fromValue>> | undefined;\n\nexport const bigIntExpressions: ExpressionTransformer = ({ dataExpression, schema }) => {\n  if (schema.type !== 'integer' || schema.format !== 'int64') {\n    return;\n  }\n\n  const bigIntCallExpression =\n    dataExpression !== undefined\n      ? $('BigInt').call($.expr(dataExpression).attr('toString').call())\n      : undefined;\n\n  if (bigIntCallExpression) {\n    if (typeof dataExpression === 'string') {\n      return [bigIntCallExpression];\n    }\n\n    if (dataExpression) {\n      return [$.expr(dataExpression).assign(bigIntCallExpression)];\n    }\n  }\n\n  return;\n};\n\nexport const dateExpressions: ExpressionTransformer = ({ dataExpression, schema }) => {\n  if (schema.type !== 'string' || !(schema.format === 'date' || schema.format === 'date-time')) {\n    return;\n  }\n\n  if (typeof dataExpression === 'string') {\n    return [$.new('Date').arg(dataExpression)];\n  }\n\n  if (dataExpression) {\n    return [$.expr(dataExpression).assign($.new('Date').arg(dataExpression))];\n  }\n\n  return;\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming, createOperationKey, operationResponsesMap, refToName } from '@hey-api/shared';\nimport type ts from 'typescript';\n\nimport { $ } from '../../../ts-dsl';\nimport type { HeyApiTransformersPlugin } from './types';\n\nconst dataVariableName = 'data';\n\n// Track symbols that are currently being built so recursive references\n// can emit calls to transformers that will be implemented later.\nconst buildingSymbols = new Set<number>();\n\ntype Expr = ReturnType<typeof $.fromValue | typeof $.return | typeof $.if>;\n\nconst isNodeReturnStatement = (node: Expr) => node['~dsl'] === 'ReturnTsDsl';\n\nconst schemaResponseTransformerNodes = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiTransformersPlugin['Instance'];\n  schema: IR.SchemaObject;\n}): Array<ts.Expression | ts.Statement | Expr> => {\n  const nodes = processSchemaType({\n    dataExpression: $(dataVariableName),\n    plugin,\n    schema,\n  });\n  // append return statement if one does not already exist\n  if (nodes.length) {\n    const last = nodes[nodes.length - 1]!;\n    if (!isNodeReturnStatement(last)) {\n      nodes.push($.return(dataVariableName));\n    }\n  }\n  return nodes;\n};\n\nconst processSchemaType = ({\n  dataExpression,\n  plugin,\n  schema,\n}: {\n  dataExpression?: ts.Expression | string | ReturnType<typeof $.attr | typeof $.expr>;\n  plugin: HeyApiTransformersPlugin['Instance'];\n  schema: IR.SchemaObject;\n}): Array<Expr> => {\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'transform',\n      resource: 'definition',\n      resourceId: schema.$ref,\n    };\n    const symbol =\n      plugin.getSymbol(query) ??\n      plugin.symbol(\n        applyNaming(refToName(schema.$ref), {\n          case: 'camelCase',\n          name: '{{name}}SchemaResponseTransformer',\n        }),\n        {\n          meta: query,\n        },\n      );\n\n    // Only compute the implementation if the symbol isn't already being built.\n    // This prevents infinite recursion on self-referential schemas. We still\n    // allow emitting a call when the symbol is currently being built so\n    // parent nodes can reference the transformer that will be emitted later.\n    if (!symbol.node && !buildingSymbols.has(symbol.id)) {\n      buildingSymbols.add(symbol.id);\n      try {\n        const refSchema = plugin.context.resolveIrRef<IR.SchemaObject>(schema.$ref);\n        const nodes = schemaResponseTransformerNodes({\n          plugin,\n          schema: refSchema,\n        });\n\n        if (nodes.length) {\n          const node = $.const(symbol).assign(\n            // TODO: parser - add types, generate types without transforms\n            $.func()\n              .param(dataVariableName, (p) => p.type('any'))\n              .do(...nodes),\n          );\n          plugin.node(node);\n        }\n      } finally {\n        buildingSymbols.delete(symbol.id);\n      }\n    }\n\n    // Only emit a call if the symbol has a value (implementation) OR the\n    // symbol is currently being built (recursive reference) — in the\n    // latter case we allow emitting a call that will be implemented later.\n    if (symbol.node || buildingSymbols.has(symbol.id)) {\n      const ref = plugin.referenceSymbol(query);\n      const callExpression = $(ref).call(dataExpression);\n\n      if (dataExpression) {\n        // In a map callback, the item needs to be returned, not just the transformation result\n        if (typeof dataExpression === 'string' && dataExpression === 'item') {\n          return [$.return(callExpression)];\n        }\n\n        return [\n          typeof dataExpression === 'string'\n            ? callExpression\n            : $(dataExpression).assign(callExpression),\n        ];\n      }\n    }\n\n    return [];\n  }\n\n  if (schema.type === 'array') {\n    if (!dataExpression || typeof dataExpression === 'string') {\n      return [];\n    }\n\n    // TODO: parser - handle tuples and complex arrays\n    const nodes = !schema.items\n      ? []\n      : processSchemaType({\n          dataExpression: 'item',\n          plugin,\n          schema: schema.items?.[0]\n            ? schema.items[0]\n            : {\n                ...schema,\n                type: undefined,\n              },\n        });\n\n    if (!nodes.length) {\n      return [];\n    }\n\n    // TODO: remove\n    // Ensure the map callback has a return statement for the item\n    const mapCallbackStatements: Array<Expr> = nodes;\n    const hasReturnStatement = mapCallbackStatements.some((stmt) => isNodeReturnStatement(stmt));\n\n    if (!hasReturnStatement) {\n      mapCallbackStatements.push($.return('item'));\n    }\n\n    return [\n      $(dataExpression).assign(\n        $(dataExpression)\n          .attr('map')\n          .call(\n            $.func()\n              .param('item', (p) => p.type('any'))\n              .do(...mapCallbackStatements),\n          ),\n      ),\n    ];\n  }\n\n  if (schema.type === 'object') {\n    let nodes: Array<Expr> = [];\n    const required = schema.required ?? [];\n\n    for (const name in schema.properties) {\n      const property = schema.properties[name]!;\n      const propertyAccessExpression = $(dataExpression || dataVariableName).attr(name);\n      const propertyNodes = processSchemaType({\n        dataExpression: propertyAccessExpression,\n        plugin,\n        schema: property,\n      });\n      if (!propertyNodes.length) {\n        continue;\n      }\n      const noNullableTypesInSchema = !property.items?.find((x) => x.type === 'null');\n      const requiredField = required.includes(name);\n      // Cannot fully rely on required fields\n      // Such value has to be present, but it doesn't guarantee that this value is not nullish\n      if (requiredField && noNullableTypesInSchema) {\n        nodes = nodes.concat(propertyNodes);\n      } else {\n        nodes.push(\n          // todo: Probably, it would make more sense to go with if(x !== undefined && x !== null) instead of if(x)\n          // this place influences all underlying transformers, while it's not exactly transformer itself\n          // Keep in mind that !!0 === false, so it already makes output for Bigint undesirable\n          $.if(propertyAccessExpression).do(...propertyNodes),\n        );\n      }\n    }\n\n    return nodes;\n  }\n\n  if (schema.items) {\n    if (schema.items.length === 1) {\n      return processSchemaType({\n        dataExpression: 'item',\n        plugin,\n        schema: schema.items[0]!,\n      });\n    }\n\n    let arrayNodes: Array<Expr> = [];\n    // process 2 items if one of them is null\n    if (\n      schema.logicalOperator === 'and' ||\n      (schema.items.length === 2 &&\n        schema.items.find((item) => item.type === 'null' || item.type === 'void'))\n    ) {\n      for (const item of schema.items) {\n        const nodes = processSchemaType({\n          dataExpression: dataExpression || 'item',\n          plugin,\n          schema: item,\n        });\n        if (nodes.length) {\n          if (dataExpression) {\n            arrayNodes = arrayNodes.concat(nodes);\n          } else {\n            // processed means the item was transformed\n            arrayNodes.push($.if('item').do(...nodes), $.return('item'));\n          }\n        }\n      }\n      return arrayNodes;\n    }\n\n    // assume enums do not contain transformable values\n    if (schema.type !== 'enum') {\n      if (\n        !(schema.items ?? []).every((item) =>\n          (\n            ['boolean', 'integer', 'null', 'number', 'string'] as ReadonlyArray<typeof item.type>\n          ).includes(item.type),\n        )\n      ) {\n        console.warn(\n          `❗️ Transformers warning: schema ${JSON.stringify(schema)} is too complex and won't be currently processed. This will likely produce an incomplete transformer which is not what you want. Please open an issue if you'd like this improved https://github.com/hey-api/openapi-ts/issues`,\n        );\n      }\n    }\n  }\n\n  for (const transformer of plugin.config.transformers) {\n    const t = transformer({\n      config: plugin.config,\n      dataExpression,\n      schema,\n    });\n    if (t) {\n      return t;\n    }\n  }\n\n  return [];\n};\n\n// handles only response transformers for now\nexport const handler: HeyApiTransformersPlugin['Handler'] = ({ plugin }) => {\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const { response } = operationResponsesMap(operation);\n      if (!response) return;\n\n      if (response.items && response.items.length > 1) {\n        if (plugin.context.config.logs.level === 'debug') {\n          console.warn(\n            `❗️ Transformers warning: route ${createOperationKey(operation)} has ${response.items.length} non-void success responses. This is currently not handled and we will not generate a response transformer. Please open an issue if you'd like this feature https://github.com/hey-api/openapi-ts/issues`,\n          );\n        }\n        return;\n      }\n\n      const symbolResponse = plugin.querySymbol({\n        category: 'type',\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'response',\n      });\n      if (!symbolResponse) return;\n\n      // TODO: parser - consider handling simple string response which is also a date\n      const nodes = schemaResponseTransformerNodes({\n        plugin,\n        schema: response,\n      });\n      if (!nodes.length) return;\n      const symbol = plugin.symbol(\n        applyNaming(operation.id, {\n          case: 'camelCase',\n          name: '{{name}}ResponseTransformer',\n        }),\n        {\n          meta: {\n            category: 'transform',\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'response',\n          },\n        },\n      );\n      const value = $.const(symbol)\n        .export()\n        .assign(\n          // TODO: parser - add types, generate types without transforms\n          $.func()\n            .async()\n            .param(dataVariableName, (p) => p.type('any'))\n            .returns($.type('Promise').generic(symbolResponse))\n            .do(...nodes),\n        );\n      plugin.node(value);\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport { bigIntExpressions, dateExpressions } from './expressions';\nimport { handler } from './plugin';\nimport type { HeyApiTransformersPlugin } from './types';\n\nexport const defaultConfig: HeyApiTransformersPlugin['Config'] = {\n  config: {\n    bigInt: true,\n    dates: true,\n    includeInEntry: false,\n    transformers: [],\n    typeTransformers: [],\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  name: '@hey-api/transformers',\n  resolveConfig: (plugin) => {\n    if (!plugin.config.transformers) {\n      plugin.config.transformers = [];\n    }\n\n    if (plugin.config.dates) {\n      plugin.config.transformers = [...plugin.config.transformers, dateExpressions];\n    }\n\n    if (plugin.config.bigInt) {\n      plugin.config.transformers = [...plugin.config.transformers, bigIntExpressions];\n    }\n  },\n  tags: ['transformer'],\n};\n\n/**\n * Type helper for `@hey-api/transformers`, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '@hey-api/shared';\nimport { applyNaming, parseUrl } from '@hey-api/shared';\n\nimport { getTypedConfig } from '../../../../config/utils';\nimport {\n  getClientBaseUrlKey,\n  getClientPlugin,\n} from '../../../../plugins/@hey-api/client-core/utils';\nimport type { TypeTsDsl } from '../../../../ts-dsl';\nimport { $ } from '../../../../ts-dsl';\nimport type { HeyApiTypeScriptPlugin } from '../types';\n\nconst serverToBaseUrlType = ({ server }: { server: IR.ServerObject }) => {\n  const url = parseUrl(server.url);\n\n  if (url.protocol && url.host) {\n    return $.type.literal(server.url);\n  }\n\n  return $.type\n    .template()\n    .add(url.protocol || $.type('string'))\n    .add('://')\n    .add(url.host || $.type('string'))\n    .add(url.port ? `:${url.port}` : '')\n    .add(url.path || '');\n};\n\nexport const createClientOptions = ({\n  nodeIndex,\n  plugin,\n  servers,\n}: {\n  nodeIndex: number;\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  servers: ReadonlyArray<IR.ServerObject>;\n}) => {\n  const client = getClientPlugin(getTypedConfig(plugin));\n\n  const types: Array<TypeTsDsl> = servers.map((server) => serverToBaseUrlType({ server }));\n\n  if (!servers.length) {\n    types.push($.type('string'));\n  } else if (!('strictBaseUrl' in client.config && client.config.strictBaseUrl)) {\n    types.push($.type.and($.type('string'), $.type.object()));\n  }\n\n  const symbol = plugin.symbol(\n    applyNaming('ClientOptions', {\n      case: plugin.config.case,\n    }),\n    {\n      meta: {\n        category: 'type',\n        resource: 'client',\n        role: 'options',\n        tool: 'typescript',\n      },\n    },\n  );\n\n  const node = $.type\n    .alias(symbol)\n    .export()\n    .type(\n      $.type\n        .object()\n        .prop(getClientBaseUrlKey(getTypedConfig(plugin)), (p) => p.type($.type.or(...types))),\n    );\n  plugin.node(node, nodeIndex);\n};\n","import { escapeComment, type IR } from '@hey-api/shared';\n\nexport const createSchemaComment = (schema: IR.SchemaObject): ReadonlyArray<string> | undefined => {\n  const comments: Array<string> = [];\n\n  if (schema.title) {\n    comments.push(escapeComment(schema.title));\n  }\n\n  if (schema.description) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line between title and description\n    }\n    comments.push(escapeComment(schema.description));\n  }\n\n  if (schema.deprecated) {\n    if (comments.length) {\n      comments.push(''); // Add an empty line before deprecated\n    }\n    comments.push('@deprecated');\n  }\n\n  return comments.length ? comments : undefined;\n};\n","import { fromRef } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming, toCase } from '@hey-api/shared';\nimport { pathToJsonPointer, refToName } from '@hey-api/shared';\n\nimport { createSchemaComment } from '../../../../plugins/shared/utils/schema';\nimport type { MaybeTsDsl, TypeTsDsl } from '../../../../ts-dsl';\nimport { $, regexp } from '../../../../ts-dsl';\nimport type { HeyApiTypeScriptPlugin } from '../types';\nimport type { IrSchemaToAstOptions } from './types';\n\nconst schemaToEnumObject = ({\n  plugin,\n  schema,\n}: {\n  plugin: HeyApiTypeScriptPlugin['Instance'];\n  schema: IR.SchemaObject;\n}) => {\n  const keyCounts: Record<string, number> = {};\n  const typeofItems: Array<\n    'bigint' | 'boolean' | 'function' | 'number' | 'object' | 'string' | 'symbol' | 'undefined'\n  > = [];\n\n  const obj = (schema.items ?? []).map((item, index) => {\n    const typeOfItemConst = typeof item.const;\n\n    if (!typeofItems.includes(typeOfItemConst)) {\n      // track types of enum values because some modes support\n      // only enums with string and number types\n      typeofItems.push(typeOfItemConst);\n    }\n\n    let key: string | undefined;\n    if (item.title) {\n      key = item.title;\n    } else if (typeOfItemConst === 'number' || typeOfItemConst === 'string') {\n      key = `${item.const}`;\n    } else if (typeOfItemConst === 'boolean') {\n      key = item.const ? 'true' : 'false';\n    } else if (item.const === null) {\n      key = 'null';\n    } else {\n      key = `${index}`;\n    }\n\n    if (key) {\n      key = toCase(key, plugin.config.enums.case, {\n        stripLeadingSeparators: false,\n      });\n\n      regexp.number.lastIndex = 0;\n      // TypeScript enum keys cannot be numbers\n      if (\n        regexp.number.test(key) &&\n        plugin.config.enums.enabled &&\n        (plugin.config.enums.mode === 'typescript' ||\n          plugin.config.enums.mode === 'typescript-const')\n      ) {\n        key = `_${key}`;\n      }\n\n      const keyCount = (keyCounts[key] ?? 0) + 1;\n      keyCounts[key] = keyCount;\n\n      // avoid collision\n      if (keyCount > 1) {\n        const nameConflictResolver = plugin.context.config.output?.nameConflictResolver;\n        if (nameConflictResolver) {\n          const resolvedName = nameConflictResolver({\n            attempt: keyCount - 1, // 0-based index\n            baseName: key,\n          });\n          if (resolvedName !== null) {\n            key = resolvedName;\n          } else {\n            key = `${key}${keyCount}`;\n          }\n        } else {\n          key = `${key}${keyCount}`;\n        }\n      }\n    }\n    return {\n      key,\n      schema: item,\n    };\n  });\n\n  return {\n    obj,\n    typeofItems,\n  };\n};\n\nexport const exportType = ({\n  plugin,\n  schema,\n  state,\n  type,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n  type: MaybeTsDsl<TypeTsDsl>;\n}) => {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n\n  // root enums have an additional export\n  if (schema.type === 'enum' && plugin.config.enums.enabled) {\n    const enumObject = schemaToEnumObject({ plugin, schema });\n\n    if (plugin.config.enums.mode === 'javascript') {\n      // JavaScript enums might want to ignore null values\n      if (plugin.config.enums.constantsIgnoreNull && enumObject.typeofItems.includes('object')) {\n        enumObject.obj = enumObject.obj.filter((item) => item.schema.const !== null);\n      }\n\n      const symbolObject = plugin.symbol(applyNaming(refToName($ref), plugin.config.definitions), {\n        meta: {\n          category: 'utility',\n          path: fromRef(state.path),\n          resource: 'definition',\n          resourceId: $ref,\n          tags: fromRef(state.tags),\n          tool: 'typescript',\n        },\n      });\n      const objectNode = $.const(symbolObject)\n        .export()\n        .$if(plugin.config.comments && createSchemaComment(schema), (c, v) => c.doc(v))\n        .assign(\n          $.object(\n            ...enumObject.obj.map((item) =>\n              $.prop({ kind: 'prop', name: item.key })\n                .$if(plugin.config.comments && createSchemaComment(item.schema), (p, v) => p.doc(v))\n                .value($.fromValue(item.schema.const)),\n            ),\n          ).as('const'),\n        );\n      plugin.node(objectNode);\n\n      const symbol = plugin.symbol(applyNaming(refToName($ref), plugin.config.definitions), {\n        meta: {\n          category: 'type',\n          path: fromRef(state.path),\n          resource: 'definition',\n          resourceId: $ref,\n          tags: fromRef(state.tags),\n          tool: 'typescript',\n        },\n      });\n      const node = $.type\n        .alias(symbol)\n        .export()\n        .$if(plugin.config.comments && createSchemaComment(schema), (t, v) => t.doc(v))\n        .type($.type(symbol).idx($.type(symbol).typeofType().keyof()).typeofType());\n      plugin.node(node);\n      return;\n    } else if (\n      plugin.config.enums.mode === 'typescript' ||\n      plugin.config.enums.mode === 'typescript-const'\n    ) {\n      // TypeScript enums support only string and number values\n      const shouldCreateTypeScriptEnum = !enumObject.typeofItems.some(\n        (type) => type !== 'number' && type !== 'string',\n      );\n      if (shouldCreateTypeScriptEnum) {\n        const symbol = plugin.symbol(applyNaming(refToName($ref), plugin.config.definitions), {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'definition',\n            resourceId: $ref,\n            tags: fromRef(state.tags),\n            tool: 'typescript',\n          },\n        });\n        const enumNode = $.enum(symbol)\n          .export()\n          .$if(plugin.config.comments && createSchemaComment(schema), (e, v) => e.doc(v))\n          .const(plugin.config.enums.mode === 'typescript-const')\n          .members(\n            ...enumObject.obj.map((item) =>\n              $.member(item.key)\n                .$if(plugin.config.comments && createSchemaComment(item.schema), (m, v) => m.doc(v))\n                .value($.fromValue(item.schema.const)),\n            ),\n          );\n        plugin.node(enumNode);\n        return;\n      }\n    }\n  }\n\n  const symbol = plugin.symbol(applyNaming(refToName($ref), plugin.config.definitions), {\n    meta: {\n      category: 'type',\n      path: fromRef(state.path),\n      resource: 'definition',\n      resourceId: $ref,\n      tags: fromRef(state.tags),\n      tool: 'typescript',\n    },\n  });\n  const node = $.type\n    .alias(symbol)\n    .export()\n    .$if(plugin.config.comments && createSchemaComment(schema), (t, v) => t.doc(v))\n    .type(type);\n  plugin.node(node);\n};\n","import { fromRef } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming } from '@hey-api/shared';\nimport { operationResponsesMap } from '@hey-api/shared';\nimport { deduplicateSchema } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { irSchemaToAst } from '../v1/plugin';\nimport type { IrSchemaToAstOptions } from './types';\n\nconst irParametersToIrSchema = ({\n  parameters,\n}: {\n  parameters: Record<string, IR.ParameterObject>;\n}): IR.SchemaObject => {\n  const irSchema: IR.SchemaObject = {\n    type: 'object',\n  };\n\n  if (parameters) {\n    const properties: Record<string, IR.SchemaObject> = {};\n    const required: Array<string> = [];\n\n    for (const key in parameters) {\n      const parameter = parameters[key]!;\n\n      properties[parameter.name] = deduplicateSchema({\n        detectFormat: false,\n        schema: parameter.schema,\n      });\n\n      if (parameter.required) {\n        required.push(parameter.name);\n      }\n    }\n\n    irSchema.properties = properties;\n\n    if (required.length) {\n      irSchema.required = required;\n    }\n  }\n\n  return irSchema;\n};\n\nconst operationToDataType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}) => {\n  const data: IR.SchemaObject = {\n    type: 'object',\n  };\n  const dataRequired: Array<string> = [];\n\n  if (!data.properties) {\n    data.properties = {};\n  }\n\n  if (operation.body) {\n    data.properties.body = operation.body.schema;\n\n    if (operation.body.required) {\n      dataRequired.push('body');\n    }\n  } else {\n    data.properties.body = {\n      type: 'never',\n    };\n  }\n\n  // TODO: parser - handle cookie parameters\n\n  // do not set headers to never so we can always pass arbitrary values\n  if (operation.parameters?.header) {\n    data.properties.headers = irParametersToIrSchema({\n      parameters: operation.parameters.header,\n    });\n\n    if (data.properties.headers.required) {\n      dataRequired.push('headers');\n    }\n  }\n\n  if (operation.parameters?.path) {\n    data.properties.path = irParametersToIrSchema({\n      parameters: operation.parameters.path,\n    });\n\n    if (data.properties.path.required) {\n      dataRequired.push('path');\n    }\n  } else {\n    data.properties.path = {\n      type: 'never',\n    };\n  }\n\n  if (operation.parameters?.query) {\n    data.properties.query = irParametersToIrSchema({\n      parameters: operation.parameters.query,\n    });\n\n    if (data.properties.query.required) {\n      dataRequired.push('query');\n    }\n  } else {\n    data.properties.query = {\n      type: 'never',\n    };\n  }\n\n  data.properties.url = {\n    const: operation.path,\n    type: 'string',\n  };\n  dataRequired.push('url');\n\n  data.required = dataRequired;\n\n  const symbol = plugin.symbol(applyNaming(operation.id, plugin.config.requests), {\n    meta: {\n      category: 'type',\n      path: fromRef(state.path),\n      resource: 'operation',\n      resourceId: operation.id,\n      role: 'data',\n      tags: fromRef(state.tags),\n      tool: 'typescript',\n    },\n  });\n  const node = $.type\n    .alias(symbol)\n    .export()\n    .type(\n      irSchemaToAst({\n        plugin,\n        schema: data,\n        state,\n      }),\n    );\n  plugin.node(node);\n};\n\nexport const operationToType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}) => {\n  operationToDataType({ operation, plugin, state });\n\n  const { error, errors, response, responses } = operationResponsesMap(operation);\n\n  if (errors) {\n    const symbolErrors = plugin.symbol(applyNaming(operation.id, plugin.config.errors), {\n      meta: {\n        category: 'type',\n        path: fromRef(state.path),\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'errors',\n        tags: fromRef(state.tags),\n        tool: 'typescript',\n      },\n    });\n    const node = $.type\n      .alias(symbolErrors)\n      .export()\n      .type(\n        irSchemaToAst({\n          plugin,\n          schema: errors,\n          state,\n        }),\n      );\n    plugin.node(node);\n\n    if (error) {\n      const symbol = plugin.symbol(\n        applyNaming(operation.id, {\n          case: plugin.config.errors.case,\n          name: plugin.config.errors.error,\n        }),\n        {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'error',\n            tags: fromRef(state.tags),\n            tool: 'typescript',\n          },\n        },\n      );\n      const node = $.type\n        .alias(symbol)\n        .export()\n        .type($.type(symbolErrors).idx($.type(symbolErrors).keyof()));\n      plugin.node(node);\n    }\n  }\n\n  if (responses) {\n    const symbolResponses = plugin.symbol(applyNaming(operation.id, plugin.config.responses), {\n      meta: {\n        category: 'type',\n        path: fromRef(state.path),\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'responses',\n        tags: fromRef(state.tags),\n        tool: 'typescript',\n      },\n    });\n    const node = $.type\n      .alias(symbolResponses)\n      .export()\n      .type(\n        irSchemaToAst({\n          plugin,\n          schema: responses,\n          state,\n        }),\n      );\n    plugin.node(node);\n\n    if (response) {\n      const symbol = plugin.symbol(\n        applyNaming(operation.id, {\n          case: plugin.config.responses.case,\n          name: plugin.config.responses.response,\n        }),\n        {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'response',\n            tags: fromRef(state.tags),\n            tool: 'typescript',\n          },\n        },\n      );\n      const node = $.type\n        .alias(symbol)\n        .export()\n        .type($.type(symbolResponses).idx($.type(symbolResponses).keyof()));\n      plugin.node(node);\n    }\n  }\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport { fromRef } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming } from '@hey-api/shared';\n\nimport { createSchemaComment } from '../../../../plugins/shared/utils/schema';\nimport { $ } from '../../../../ts-dsl';\nimport { irSchemaToAst } from '../v1/plugin';\nimport type { IrSchemaToAstOptions } from './types';\n\nconst operationToDataType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}): Symbol => {\n  const data: IR.SchemaObject = {\n    type: 'object',\n  };\n  const dataRequired: Array<string> = [];\n\n  if (!data.properties) {\n    data.properties = {};\n  }\n\n  if (operation.body) {\n    const symbolWebhookPayload = plugin.symbol(\n      applyNaming(operation.id, {\n        case: plugin.config.webhooks.case,\n        name: plugin.config.webhooks.payload,\n      }),\n      {\n        meta: {\n          category: 'type',\n          path: fromRef(state.path),\n          resource: 'webhook',\n          resourceId: operation.id,\n          role: 'data',\n          tags: fromRef(state.tags),\n          tool: 'typescript',\n        },\n      },\n    );\n    const node = $.type\n      .alias(symbolWebhookPayload)\n      .export()\n      .$if(plugin.config.comments && createSchemaComment(operation.body.schema), (t, v) => t.doc(v))\n      .type(\n        irSchemaToAst({\n          plugin,\n          schema: operation.body.schema,\n          state,\n        }),\n      );\n    plugin.node(node);\n\n    data.properties.body = { symbolRef: symbolWebhookPayload };\n    dataRequired.push('body');\n  } else {\n    data.properties.body = { type: 'never' };\n  }\n\n  data.properties.key = {\n    const: operation.path,\n    type: 'string',\n  };\n  dataRequired.push('key');\n\n  data.properties.path = { type: 'never' };\n  data.properties.query = { type: 'never' };\n\n  data.required = dataRequired;\n\n  const symbolWebhookRequest = plugin.symbol(applyNaming(operation.id, plugin.config.webhooks), {\n    meta: {\n      category: 'type',\n      path: fromRef(state.path),\n      resource: 'webhook',\n      resourceId: operation.id,\n      role: 'data',\n      tags: fromRef(state.tags),\n      tool: 'typescript',\n    },\n  });\n  const node = $.type\n    .alias(symbolWebhookRequest)\n    .export()\n    .type(\n      irSchemaToAst({\n        plugin,\n        schema: data,\n        state,\n      }),\n    );\n  plugin.node(node);\n\n  return symbolWebhookRequest;\n};\n\nexport const webhookToType = ({\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  operation: IR.OperationObject;\n}): Symbol => {\n  const symbol = operationToDataType({ operation, plugin, state });\n  return symbol;\n\n  // don't handle webhook responses for now, users only need requestBody\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\nimport { deduplicateSchema } from '@hey-api/shared';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../../../../../ts-dsl';\nimport { $ } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): TypeTsDsl => {\n  if (!schema.items) {\n    return $.type('Array').generic($.type(plugin.config.topType));\n  }\n\n  schema = deduplicateSchema({ detectFormat: true, schema });\n\n  const itemTypes: Array<MaybeTsDsl<TypeTsDsl>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const type = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      itemTypes.push(type);\n    });\n  }\n\n  if (itemTypes.length === 1) {\n    return $.type('Array').generic(itemTypes[0]!);\n  }\n\n  return schema.logicalOperator === 'and'\n    ? $.type('Array').generic($.type.and(...itemTypes))\n    : $.type('Array').generic($.type.or(...itemTypes));\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport type { TypeTsDsl } from '../../../../../ts-dsl';\nimport { $ } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport function booleanToAst({\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): TypeTsDsl {\n  if (schema.const !== undefined) {\n    return $.type.literal(schema.const as boolean);\n  }\n\n  return $.type('boolean');\n}\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): MaybeTsDsl<TypeTsDsl> => {\n  const type = irSchemaToAst({\n    plugin,\n    schema: {\n      ...schema,\n      type: undefined,\n    },\n    state,\n  });\n  return type;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport type { TypeTsDsl } from '../../../../../ts-dsl';\nimport { $ } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'never'>;\n  },\n): TypeTsDsl => {\n  const node = $.type('never');\n  return node;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport type { TypeTsDsl } from '../../../../../ts-dsl';\nimport { $ } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'null'>;\n  },\n): TypeTsDsl => {\n  const node = $.type.literal(null);\n  return node;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport type { TypeTsDsl } from '../../../../../ts-dsl';\nimport { $ } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const numberToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): TypeTsDsl => {\n  if (schema.const !== undefined) {\n    return $.type.literal(schema.const as number);\n  }\n\n  if (schema.type === 'integer' && schema.format === 'int64') {\n    // TODO: parser - add ability to skip type transformers\n    if (plugin.getPlugin('@hey-api/transformers')?.config.bigInt) {\n      return $.type('bigint');\n    }\n  }\n\n  return $.type('number');\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport type { SchemaWithType } from '@hey-api/shared';\n\nimport { createSchemaComment } from '../../../../../plugins/shared/utils/schema';\nimport type { TypeTsDsl } from '../../../../../ts-dsl';\nimport { $ } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): TypeTsDsl => {\n  // TODO: parser - handle constants\n  const shape = $.type.object();\n  const required = schema.required ?? [];\n  let indexSchemas: Array<IR.SchemaObject> = [];\n  let hasOptionalProperties = false;\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const propertyType = irSchemaToAst({\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: ref([...fromRef(state.path), 'properties', name]),\n      },\n    });\n    const isRequired = required.includes(name);\n    shape.prop(name, (p) =>\n      p\n        .$if(plugin.config.comments && createSchemaComment(property), (p, v) => p.doc(v))\n        .readonly(property.accessScope === 'read')\n        .required(isRequired)\n        .type(propertyType),\n    );\n    indexSchemas.push(property);\n\n    if (!isRequired) {\n      hasOptionalProperties = true;\n    }\n  }\n\n  // include pattern value schemas into the index union\n  if (schema.patternProperties) {\n    for (const pattern in schema.patternProperties) {\n      const ir = schema.patternProperties[pattern]!;\n      indexSchemas.unshift(ir);\n    }\n  }\n\n  const hasPatterns =\n    !!schema.patternProperties && Object.keys(schema.patternProperties).length > 0;\n\n  const addPropsRaw = schema.additionalProperties;\n  const addPropsObj =\n    addPropsRaw !== false && addPropsRaw ? (addPropsRaw as IR.SchemaObject) : undefined;\n  const shouldCreateIndex =\n    hasPatterns || (!!addPropsObj && (addPropsObj.type !== 'never' || !indexSchemas.length));\n\n  if (shouldCreateIndex) {\n    // only inject additionalProperties when it's not \"never\"\n    const addProps = addPropsObj;\n    if (addProps && addProps.type !== 'never') {\n      indexSchemas.unshift(addProps);\n    } else if (!hasPatterns && !indexSchemas.length && addProps && addProps.type === 'never') {\n      // keep \"never\" only when there are NO patterns and NO explicit properties\n      indexSchemas = [addProps];\n    }\n\n    if (hasOptionalProperties) {\n      indexSchemas.push({ type: 'undefined' });\n    }\n\n    const type =\n      indexSchemas.length === 1\n        ? irSchemaToAst({\n            plugin,\n            schema: indexSchemas[0]!,\n            state,\n          })\n        : irSchemaToAst({\n            plugin,\n            schema: { items: indexSchemas, logicalOperator: 'or' },\n            state,\n          });\n\n    if (schema.propertyNames?.$ref) {\n      return $.type\n        .mapped('key')\n        .key(\n          irSchemaToAst({\n            plugin,\n            schema: {\n              $ref: schema.propertyNames.$ref,\n            },\n            state,\n          }),\n        )\n        .optional()\n        .type(type);\n    }\n\n    shape.idxSig('key', (i) => i.key('string').type(type));\n  }\n\n  return shape;\n};\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\nimport { toCase } from '@hey-api/shared';\n\nimport type { TypeTsDsl } from '../../../../../ts-dsl';\nimport { $ } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const stringToAst = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): TypeTsDsl => {\n  if (schema.const !== undefined) {\n    return $.type.literal(schema.const as string);\n  }\n\n  if (schema.format) {\n    if (schema.format === 'binary') {\n      return $.type.or($.type('Blob'), $.type('File'));\n    }\n\n    if (schema.format === 'date-time' || schema.format === 'date') {\n      // TODO: parser - add ability to skip type transformers\n      if (plugin.getPlugin('@hey-api/transformers')?.config.dates) {\n        return $.type('Date');\n      }\n    }\n\n    if (schema.format === 'typeid' && typeof schema.example === 'string') {\n      const parts = String(schema.example).split('_');\n      parts.pop(); // remove the ID part\n      const type = parts.join('_');\n\n      const query: SymbolMeta = {\n        category: 'type',\n        resource: 'type-id',\n        resourceId: type,\n        tool: 'typescript',\n      };\n      if (!plugin.getSymbol(query)) {\n        const queryTypeId: SymbolMeta = {\n          category: 'type',\n          resource: 'type-id',\n          tool: 'typescript',\n          variant: 'container',\n        };\n\n        if (!plugin.getSymbol(queryTypeId)) {\n          const symbolTypeId = plugin.symbol('TypeID', {\n            meta: queryTypeId,\n          });\n          const nodeTypeId = $.type\n            .alias(symbolTypeId)\n            .export()\n            .generic('T', (g) => g.extends('string'))\n            .type($.type.template().add($.type('T')).add('_').add($.type('string')));\n          plugin.node(nodeTypeId);\n        }\n\n        const symbolTypeId = plugin.referenceSymbol(queryTypeId);\n        const symbolTypeName = plugin.symbol(toCase(`${type}_id`, plugin.config.case), {\n          meta: query,\n        });\n        const node = $.type\n          .alias(symbolTypeName)\n          .export()\n          .type($.type(symbolTypeId).generic($.type.literal(type)));\n        plugin.node(node);\n      }\n      const symbol = plugin.referenceSymbol(query);\n      return $.type(symbol);\n    }\n  }\n\n  return $.type('string');\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../../../../../ts-dsl';\nimport { $ } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): MaybeTsDsl<TypeTsDsl> => {\n  let itemTypes: Array<MaybeTsDsl<TypeTsDsl>> = [];\n\n  if (schema.const && Array.isArray(schema.const)) {\n    itemTypes = schema.const.map((value) => $.type.fromValue(value));\n  } else if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const type = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      itemTypes.push(type);\n    });\n  }\n\n  return $.type.tuple(...itemTypes);\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport type { TypeTsDsl } from '../../../../../ts-dsl';\nimport { $ } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'undefined'>;\n  },\n): TypeTsDsl => {\n  const node = $.type('undefined');\n  return node;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport type { TypeTsDsl } from '../../../../../ts-dsl';\nimport { $ } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): TypeTsDsl => {\n  const node = $.type(plugin.config.topType);\n  return node;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport type { TypeTsDsl } from '../../../../../ts-dsl';\nimport { $ } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'void'>;\n  },\n): TypeTsDsl => {\n  const node = $.type('void');\n  return node;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToAst } from './number';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport function irSchemaWithTypeToAst({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): MaybeTsDsl<TypeTsDsl> {\n  const transformersPlugin = args.plugin.getPlugin('@hey-api/transformers');\n  if (transformersPlugin?.config.typeTransformers) {\n    for (const typeTransformer of transformersPlugin.config.typeTransformers) {\n      const typeNode = typeTransformer({ schema });\n      if (typeNode) {\n        return typeNode;\n      }\n    }\n  }\n\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToAst({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n}\n","import type { Symbol } from '@hey-api/codegen-core';\nimport { refs } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport type { SchemaWithType } from '@hey-api/shared';\nimport { applyNaming } from '@hey-api/shared';\nimport { deduplicateSchema } from '@hey-api/shared';\n\nimport type { MaybeTsDsl, TypeTsDsl } from '../../../../ts-dsl';\nimport { $ } from '../../../../ts-dsl';\nimport { createClientOptions } from '../shared/clientOptions';\nimport { exportType } from '../shared/export';\nimport { operationToType } from '../shared/operation';\nimport type { IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { webhookToType } from '../shared/webhook';\nimport type { HeyApiTypeScriptPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport function irSchemaToAst({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): MaybeTsDsl<TypeTsDsl> {\n  if (schema.symbolRef) {\n    const baseType = $.type(schema.symbolRef);\n    if (schema.omit && schema.omit.length > 0) {\n      // Render as Omit<Type, 'prop1' | 'prop2'>\n      const omittedKeys =\n        schema.omit.length === 1\n          ? $.type.literal(schema.omit[0]!)\n          : $.type.or(...schema.omit.map((key) => $.type.literal(key)));\n      return $.type('Omit').generics(baseType, omittedKeys);\n    }\n    return baseType;\n  }\n\n  if (schema.$ref) {\n    const symbol = plugin.referenceSymbol({\n      category: 'type',\n      resource: 'definition',\n      resourceId: schema.$ref,\n    });\n    const baseType = $.type(symbol);\n    if (schema.omit && schema.omit.length > 0) {\n      // Render as Omit<Type, 'prop1' | 'prop2'>\n      const omittedKeys =\n        schema.omit.length === 1\n          ? $.type.literal(schema.omit[0]!)\n          : $.type.or(...schema.omit.map((key) => $.type.literal(key)));\n      return $.type('Omit').generics(baseType, omittedKeys);\n    }\n    return baseType;\n  }\n\n  if (schema.type) {\n    return irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n  }\n\n  if (schema.items) {\n    schema = deduplicateSchema({ detectFormat: false, schema });\n    if (schema.items) {\n      const itemTypes = schema.items.map((item) => irSchemaToAst({ plugin, schema: item, state }));\n      return schema.logicalOperator === 'and' ? $.type.and(...itemTypes) : $.type.or(...itemTypes);\n    }\n\n    return irSchemaToAst({ plugin, schema, state });\n  }\n\n  // catch-all fallback for failed schemas\n  return irSchemaWithTypeToAst({\n    plugin,\n    schema: {\n      type: 'unknown',\n    },\n    state,\n  });\n}\n\nfunction handleComponent({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}) {\n  const type = irSchemaToAst({ plugin, schema, state });\n  exportType({\n    plugin,\n    schema,\n    state,\n    type,\n  });\n}\n\nexport const handlerV1: HeyApiTypeScriptPlugin['Handler'] = ({ plugin }) => {\n  // reserve node for ClientOptions\n  const nodeClientIndex = plugin.node(null);\n  // reserve node for Webhooks\n  const nodeWebhooksIndex = plugin.node(null);\n\n  const servers: Array<IR.ServerObject> = [];\n  const webhooks: Array<Symbol> = [];\n\n  plugin.forEach(\n    'operation',\n    'parameter',\n    'requestBody',\n    'schema',\n    'server',\n    'webhook',\n    (event) => {\n      const state = refs<PluginState>({\n        path: event._path,\n        tags: event.tags,\n      });\n      switch (event.type) {\n        case 'operation':\n          operationToType({\n            operation: event.operation,\n            plugin,\n            state,\n          });\n          break;\n        case 'parameter':\n          handleComponent({\n            plugin,\n            schema: event.parameter.schema,\n            state,\n          });\n          break;\n        case 'requestBody':\n          handleComponent({\n            plugin,\n            schema: event.requestBody.schema,\n            state,\n          });\n          break;\n        case 'schema':\n          handleComponent({\n            plugin,\n            schema: event.schema,\n            state,\n          });\n          break;\n        case 'server':\n          servers.push(event.server);\n          break;\n        case 'webhook':\n          webhooks.push(\n            webhookToType({\n              operation: event.operation,\n              plugin,\n              state,\n            }),\n          );\n          break;\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  createClientOptions({ nodeIndex: nodeClientIndex, plugin, servers });\n\n  if (webhooks.length > 0) {\n    const symbol = plugin.symbol(\n      applyNaming('Webhooks', {\n        case: plugin.config.case,\n      }),\n      {\n        meta: {\n          category: 'type',\n          resource: 'webhook',\n          tool: 'typescript',\n          variant: 'container',\n        },\n      },\n    );\n    const node = $.type\n      .alias(symbol)\n      .export()\n      .type($.type.or(...webhooks));\n    plugin.node(node, nodeWebhooksIndex);\n  }\n};\n","import type { MaybeTsDsl, TypeTsDsl } from '../../../ts-dsl';\nimport { irSchemaToAstV1 } from './v1/api';\n\nexport type IApi = {\n  schemaToType: (args: Parameters<typeof irSchemaToAstV1>[0]) => MaybeTsDsl<TypeTsDsl>;\n};\n\nexport class Api implements IApi {\n  schemaToType(args: Parameters<typeof irSchemaToAstV1>[0]): MaybeTsDsl<TypeTsDsl> {\n    return irSchemaToAstV1(args);\n  }\n}\n","import type { HeyApiTypeScriptPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: HeyApiTypeScriptPlugin['Handler'] = (args) => handlerV1(args);\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { HeyApiTypeScriptPlugin } from './types';\n\nexport const defaultConfig: HeyApiTypeScriptPlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'PascalCase',\n    comments: true,\n    includeInEntry: true,\n    topType: 'unknown',\n  },\n  handler,\n  name: '@hey-api/typescript',\n  resolveConfig: (plugin, context) => {\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.enums = context.valueToObject({\n      defaultValue: {\n        case: 'SCREAMING_SNAKE_CASE',\n        constantsIgnoreNull: false,\n        enabled: Boolean(plugin.config.enums),\n        mode: 'javascript',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        string: (mode) => ({ mode }),\n      },\n      value: plugin.config.enums,\n    });\n\n    plugin.config.errors = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        error: '{{name}}Error',\n        name: '{{name}}Errors',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.errors,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}Data',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}Responses',\n        response: '{{name}}Response',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        name: '{{name}}WebhookRequest',\n        payload: '{{name}}WebhookPayload',\n      },\n      mappers: {\n        function: (name) => ({ name }),\n        string: (name) => ({ name }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n};\n\n/**\n * Type helper for `@hey-api/typescript` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '@hey-api/shared';\n\nimport { $ } from '../../../ts-dsl';\nimport type { PiniaColadaPlugin } from './types';\n\nexport const handleMeta = (\n  plugin: PiniaColadaPlugin['Instance'],\n  operation: IR.OperationObject,\n  configPath: 'queryOptions' | 'mutationOptions',\n): ReturnType<typeof $.fromValue> | undefined => {\n  const metaFn = plugin.config[configPath].meta;\n  if (!metaFn) return;\n\n  const metaObject = metaFn(operation);\n  if (!Object.keys(metaObject).length) return;\n\n  return $.fromValue(metaObject);\n};\n","import type { IR } from '@hey-api/shared';\n\nimport { getTypedConfig } from '../../../config/utils';\nimport { getClientPlugin } from '../../../plugins/@hey-api/client-core/utils';\nimport { operationOptionsType } from '../../../plugins/@hey-api/sdk/shared/operation';\nimport { $ } from '../../../ts-dsl';\nimport type { PiniaColadaPlugin } from './types';\n\nexport const useTypeData = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): ReturnType<typeof $.type> => {\n  const pluginSdk = plugin.getPluginOrThrow('@hey-api/sdk');\n  return operationOptionsType({ operation, plugin: pluginSdk });\n};\n\nexport const useTypeError = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): ReturnType<typeof $.type> => {\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'error',\n  });\n  const symbolError = symbolErrorType || 'Error';\n  if (client.name === '@hey-api/client-axios') {\n    const symbol = plugin.external('axios.AxiosError');\n    return $.type(symbol).generic(symbolError);\n  }\n  return $.type(symbolError);\n};\n\nexport const useTypeResponse = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): ReturnType<typeof $.type> => {\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'response',\n  });\n  return $.type(symbolResponseType ?? 'unknown');\n};\n","import type { IR } from '@hey-api/shared';\n\nimport { $ } from '../../../ts-dsl';\nimport type { PiniaColadaPlugin } from './types';\nimport { useTypeData } from './useType';\n\nexport const getPublicTypeData = ({\n  isNuxtClient,\n  operation,\n  plugin,\n}: {\n  isNuxtClient: boolean;\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const typeData = useTypeData({ operation, plugin });\n  return isNuxtClient ? $.type('Omit').generic(typeData).generic('composable') : typeData;\n};\n","import type { IR } from '@hey-api/shared';\nimport { applyNaming } from '@hey-api/shared';\n\nimport { getTypedConfig } from '../../../config/utils';\nimport { getClientPlugin } from '../../../plugins/@hey-api/client-core/utils';\nimport { createOperationComment } from '../../../plugins/shared/utils/operation';\nimport { $ } from '../../../ts-dsl';\nimport { handleMeta } from './meta';\nimport type { PiniaColadaPlugin } from './types';\nimport { useTypeError, useTypeResponse } from './useType';\nimport { getPublicTypeData } from './utils';\n\nexport const createMutationOptions = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): void => {\n  const symbolMutationOptionsType = plugin.external(`${plugin.name}.UseMutationOptions`);\n\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n\n  const typeData = getPublicTypeData({ isNuxtClient, operation, plugin });\n\n  const options = plugin.symbol('options');\n  const fnOptions = plugin.symbol('vars');\n\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call(\n        $.object().pretty().spread(options).spread(fnOptions).prop('throwOnError', $.literal(true)),\n      )\n      .await(),\n  );\n\n  const statements: Array<ReturnType<typeof $.var | typeof $.return>> = [];\n\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push($.const().object('data').assign(awaitSdkFn), $.return('data'));\n  }\n\n  const mutationOpts = $.object()\n    .pretty()\n    .prop(\n      'mutation',\n      $.func()\n        .async()\n        .param(fnOptions, (p) =>\n          p.$if(isNuxtClient, (f) => f.type($.type('Partial').generic(typeData))),\n        )\n        .do(...statements),\n    )\n    .$if(handleMeta(plugin, operation, 'mutationOptions'), (o, v) => o.prop('meta', v));\n  const symbolMutationOptions = plugin.symbol(\n    applyNaming(operation.id, plugin.config.mutationOptions),\n  );\n  const statement = $.const(symbolMutationOptions)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v))\n    .assign(\n      $.func()\n        .param(options, (p) => p.optional().type($.type('Partial').generic(typeData)))\n        .returns(\n          $.type(symbolMutationOptionsType)\n            .generic(useTypeResponse({ operation, plugin }))\n            .generic(typeData)\n            .generic(useTypeError({ operation, plugin })),\n        )\n        .do($.return(mutationOpts)),\n    );\n  plugin.node(statement);\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming, hasOperationDataRequired } from '@hey-api/shared';\n\nimport { getTypedConfig } from '../../../config/utils';\nimport { clientFolderAbsolutePath } from '../../../generate/client';\nimport { getClientBaseUrlKey, getClientPlugin } from '../../../plugins/@hey-api/client-core/utils';\nimport { $ } from '../../../ts-dsl';\nimport type { PiniaColadaPlugin } from './types';\nimport { getPublicTypeData } from './utils';\n\nconst TOptionsType = 'TOptions';\n\nexport const createQueryKeyFunction = ({ plugin }: { plugin: PiniaColadaPlugin['Instance'] }) => {\n  const symbolCreateQueryKey = plugin.symbol(\n    applyNaming('createQueryKey', {\n      case: plugin.config.case,\n    }),\n    {\n      meta: {\n        category: 'utility',\n        resource: 'createQueryKey',\n        tool: plugin.name,\n      },\n    },\n  );\n  const symbolQueryKeyType = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'QueryKey',\n    tool: plugin.name,\n  });\n  const symbolJsonValue = plugin.external(`${plugin.name}._JSONValue`);\n\n  const returnType = $.type(symbolQueryKeyType).generic(TOptionsType).idx(0);\n\n  const baseUrlKey = getClientBaseUrlKey(getTypedConfig(plugin));\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolClient = plugin.getSymbol({\n    category: 'client',\n  });\n\n  const clientModule = clientFolderAbsolutePath(getTypedConfig(plugin));\n  const symbolSerializeQueryValue = plugin.symbol('serializeQueryKeyValue', {\n    external: clientModule,\n    meta: {\n      category: 'external',\n      resource: `${clientModule}.serializeQueryKeyValue`,\n    },\n  });\n\n  const fn = $.const(symbolCreateQueryKey).assign(\n    $.func()\n      .param('id', (p) => p.type('string'))\n      .param('options', (p) => p.optional().type(TOptionsType))\n      .param('tags', (p) => p.optional().type('ReadonlyArray<string>'))\n      .returns($.type.tuple(returnType))\n      .generic(TOptionsType, (g) => g.extends(symbolOptions))\n      .do(\n        $.const('params')\n          .type(returnType)\n          .assign(\n            $.object()\n              .prop('_id', 'id')\n              .prop(\n                baseUrlKey,\n                $('options')\n                  .attr(baseUrlKey)\n                  .optional()\n                  .or(\n                    $('options')\n                      .attr('client')\n                      .optional()\n                      .$if(symbolClient, (a, v) => a.coalesce(v))\n                      .attr('getConfig')\n                      .call()\n                      .attr(baseUrlKey),\n                  ),\n              )\n              .as(returnType),\n          ),\n        $.if('tags').do(\n          $('params').attr('tags').assign($('tags').as('unknown').as(symbolJsonValue)),\n        ),\n        $.if($('options').attr('body').optional().neq($.id('undefined'))).do(\n          $.const('normalizedBody').assign(\n            $(symbolSerializeQueryValue).call($('options').attr('body')),\n          ),\n          $.if($('normalizedBody').neq($.id('undefined'))).do(\n            $('params').attr('body').assign('normalizedBody'),\n          ),\n        ),\n        $.if($('options').attr('path').optional()).do(\n          $('params').attr('path').assign($('options').attr('path')),\n        ),\n        $.if($('options').attr('query').optional().neq($.id('undefined'))).do(\n          $.const('normalizedQuery').assign(\n            $(symbolSerializeQueryValue).call($('options').attr('query')),\n          ),\n          $.if($('normalizedQuery').neq($.id('undefined'))).do(\n            $('params').attr('query').assign('normalizedQuery'),\n          ),\n        ),\n        $.return($.array($('params'))),\n      ),\n  );\n  plugin.node(fn);\n};\n\nconst createQueryKeyLiteral = ({\n  id,\n  operation,\n  plugin,\n}: {\n  id: string;\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}) => {\n  const config = plugin.config.queryKeys;\n  let tagsExpression: ReturnType<typeof $.array> | undefined;\n  if (config.tags && operation.tags && operation.tags.length > 0) {\n    tagsExpression = $.array(...operation.tags.map((tag) => $.literal(tag)));\n  }\n\n  const symbolCreateQueryKey = plugin.referenceSymbol({\n    category: 'utility',\n    resource: 'createQueryKey',\n    tool: plugin.name,\n  });\n  const createQueryKeyCallExpression = $(symbolCreateQueryKey).call(\n    $.literal(id),\n    'options',\n    tagsExpression,\n  );\n  return createQueryKeyCallExpression;\n};\n\nexport const createQueryKeyType = ({ plugin }: { plugin: PiniaColadaPlugin['Instance'] }) => {\n  const symbolJsonValue = plugin.external(`${plugin.name}._JSONValue`);\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolQueryKeyType = plugin.symbol('QueryKey', {\n    meta: {\n      category: 'type',\n      resource: 'QueryKey',\n      tool: plugin.name,\n    },\n  });\n  const queryKeyType = $.type\n    .alias(symbolQueryKeyType)\n    .export()\n    .generic(TOptionsType, (g) => g.extends($.type(symbolOptions)))\n    .type(\n      $.type.tuple(\n        $.type.and(\n          $.type(`Pick<${TOptionsType}, 'path'>`),\n          $.type\n            .object()\n            .prop('_id', (p) => p.type('string'))\n            .prop(getClientBaseUrlKey(getTypedConfig(plugin)), (p) =>\n              p.optional().type(symbolJsonValue),\n            )\n            .prop('body', (p) => p.optional().type(symbolJsonValue))\n            .prop('query', (p) => p.optional().type(symbolJsonValue))\n            .prop('tags', (p) => p.optional().type(symbolJsonValue)),\n        ),\n      ),\n    );\n  plugin.node(queryKeyType);\n};\n\nexport const queryKeyStatement = ({\n  operation,\n  plugin,\n  symbol,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n  symbol: Symbol;\n}) => {\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const statement = $.const(symbol)\n    .export()\n    .assign(\n      $.func()\n        .param('options', (p) =>\n          p\n            .required(hasOperationDataRequired(operation))\n            .type(getPublicTypeData({ isNuxtClient, operation, plugin })),\n        )\n        .do(\n          createQueryKeyLiteral({\n            id: operation.id,\n            operation,\n            plugin,\n          }).return(),\n        ),\n    );\n  return statement;\n};\n","import type { IR } from '@hey-api/shared';\nimport { applyNaming } from '@hey-api/shared';\n\nimport { getTypedConfig } from '../../../config/utils';\nimport { getClientPlugin } from '../../../plugins/@hey-api/client-core/utils';\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '../../../plugins/shared/utils/operation';\nimport { $ } from '../../../ts-dsl';\nimport { handleMeta } from './meta';\nimport { createQueryKeyFunction, createQueryKeyType, queryKeyStatement } from './queryKey';\nimport type { PiniaColadaPlugin } from './types';\nimport { getPublicTypeData } from './utils';\n\nconst optionsParamName = 'options';\nconst fnOptions = 'context';\n\nexport const createQueryOptions = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PiniaColadaPlugin['Instance'];\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    })\n  ) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  let keyExpression: ReturnType<typeof $.call>;\n  if (plugin.config.queryKeys.enabled) {\n    const symbolQueryKey = plugin.symbol(applyNaming(operation.id, plugin.config.queryKeys));\n    const node = queryKeyStatement({\n      operation,\n      plugin,\n      symbol: symbolQueryKey,\n    });\n    plugin.node(node);\n    keyExpression = $(symbolQueryKey).call(optionsParamName);\n  } else {\n    const symbolCreateQueryKey = plugin.referenceSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    });\n    // Optionally include tags when configured\n    let tagsExpr: ReturnType<typeof $.array> | undefined;\n    if (plugin.config.queryKeys.tags && operation.tags && operation.tags.length > 0) {\n      tagsExpr = $.array(...operation.tags.map((t) => $.literal(t)));\n    }\n    keyExpression = $(symbolCreateQueryKey).call(\n      $.literal(operation.id),\n      optionsParamName,\n      tagsExpr,\n    );\n  }\n\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const isNuxtClient = client.name === '@hey-api/client-nuxt';\n  const typeData = getPublicTypeData({ isNuxtClient, operation, plugin });\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call(\n        $.object().spread(optionsParamName).spread(fnOptions).prop('throwOnError', $.literal(true)),\n      )\n      .await(),\n  );\n\n  const statements: Array<ReturnType<typeof $.return | typeof $.const>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push($.const().object('data').assign(awaitSdkFn), $.return('data'));\n  }\n\n  const queryOpts = $.object()\n    .pretty()\n    .prop('key', keyExpression)\n    .prop(\n      'query',\n      $.func()\n        .async()\n        .param(fnOptions)\n        .do(...statements),\n    )\n    .$if(handleMeta(plugin, operation, 'queryOptions'), (o, v) => o.prop('meta', v));\n\n  const symbolQueryOptionsFn = plugin.symbol(\n    applyNaming(operation.id, plugin.config.queryOptions),\n    {\n      meta: {\n        category: 'hook',\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'queryOptions',\n        tool: plugin.name,\n      },\n    },\n  );\n  const symbolDefineQueryOptions = plugin.external(`${plugin.name}.defineQueryOptions`);\n  const statement = $.const(symbolQueryOptionsFn)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v))\n    .assign(\n      $(symbolDefineQueryOptions).call(\n        $.func()\n          .param(optionsParamName, (p) => p.required(isRequiredOptions).type(typeData))\n          .do($.return(queryOpts)),\n      ),\n    );\n  plugin.node(statement);\n};\n","import { createMutationOptions } from '../mutationOptions';\nimport { createQueryOptions } from '../queryOptions';\nimport type { PiniaColadaPlugin } from '../types';\n\nexport const handlerV0: PiniaColadaPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('defineQueryOptions', {\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.defineQueryOptions`,\n    },\n  });\n  plugin.symbol('UseMutationOptions', {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.UseMutationOptions`,\n    },\n  });\n  plugin.symbol('UseQueryOptions', {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.UseQueryOptions`,\n    },\n  });\n  plugin.symbol('_JSONValue', {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}._JSONValue`,\n    },\n  });\n  plugin.symbol('AxiosError', {\n    external: 'axios',\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: 'axios.AxiosError',\n    },\n  });\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      if (plugin.hooks.operation.isQuery(operation)) {\n        if (plugin.config.queryOptions.enabled) {\n          createQueryOptions({ operation, plugin });\n        }\n      }\n\n      if (plugin.hooks.operation.isMutation(operation)) {\n        if (plugin.config.mutationOptions.enabled) {\n          createMutationOptions({ operation, plugin });\n        }\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import type { PiniaColadaPlugin } from './types';\nimport { handlerV0 } from './v0/plugin';\n\nexport const handler: PiniaColadaPlugin['Handler'] = (args) => handlerV0(args);\n","import { definePluginConfig, mappers } from '@hey-api/shared';\n\nimport { handler } from './plugin';\nimport type { PiniaColadaPlugin } from './types';\n\nexport const defaultConfig: PiniaColadaPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    includeInEntry: false,\n  },\n  dependencies: ['@hey-api/typescript', '@hey-api/sdk'],\n  handler: handler as PiniaColadaPlugin['Handler'],\n  name: '@pinia/colada',\n  resolveConfig: (plugin, context) => {\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers,\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Query',\n      },\n      mappers,\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@pinia/colada` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '@hey-api/shared';\n\nimport { getTypedConfig } from '../../../../config/utils';\nimport { getClientPlugin } from '../../../../plugins/@hey-api/client-core/utils';\nimport { operationOptionsType } from '../../../../plugins/@hey-api/sdk/shared/operation';\nimport { $ } from '../../../../ts-dsl';\nimport type { PluginInstance } from '../types';\n\nexport const useTypeData = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): ReturnType<typeof $.type> => {\n  const pluginSdk = plugin.getPluginOrThrow('@hey-api/sdk');\n  return operationOptionsType({ operation, plugin: pluginSdk });\n};\n\nexport const useTypeError = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): ReturnType<typeof $.type> => {\n  const client = getClientPlugin(getTypedConfig(plugin));\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'error',\n  });\n  const symbolError = symbolErrorType || plugin.external(`${plugin.name}.DefaultError`);\n  if (client.name === '@hey-api/client-axios') {\n    const symbol = plugin.external('axios.AxiosError');\n    return $.type(symbol).generic(symbolError);\n  }\n  return $.type(symbolError);\n};\n\nexport const useTypeResponse = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): ReturnType<typeof $.type> => {\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'response',\n  });\n  return $.type(symbolResponseType ?? 'unknown');\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming, hasOperationDataRequired } from '@hey-api/shared';\nimport type ts from 'typescript';\n\nimport { getTypedConfig } from '../../../config/utils';\nimport { getClientBaseUrlKey } from '../../../plugins/@hey-api/client-core/utils';\nimport type { TsDsl } from '../../../ts-dsl';\nimport { $ } from '../../../ts-dsl';\nimport { useTypeData } from './shared/useType';\nimport type { PluginInstance } from './types';\n\nconst TOptionsType = 'TOptions';\n\nexport const createQueryKeyFunction = ({ plugin }: { plugin: PluginInstance }) => {\n  const symbolCreateQueryKey = plugin.symbol(\n    applyNaming('createQueryKey', {\n      case: plugin.config.case,\n    }),\n    {\n      meta: {\n        category: 'utility',\n        resource: 'createQueryKey',\n        tool: plugin.name,\n      },\n    },\n  );\n  const symbolQueryKeyType = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'QueryKey',\n    tool: plugin.name,\n  });\n\n  const baseUrlKey = getClientBaseUrlKey(getTypedConfig(plugin));\n\n  const symbolClient = plugin.getSymbol({\n    category: 'client',\n  });\n\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n\n  const returnType = $.type(symbolQueryKeyType).generic(TOptionsType).idx(0);\n\n  const fn = $.const(symbolCreateQueryKey).assign(\n    $.func()\n      .param('id', (p) => p.type('string'))\n      .param('options', (p) => p.optional().type(TOptionsType))\n      .param('infinite', (p) => p.optional().type('boolean'))\n      .param('tags', (p) => p.optional().type('ReadonlyArray<string>'))\n      .generic(TOptionsType, (g) => g.extends(symbolOptions))\n      .returns($.type.tuple(returnType))\n      .do(\n        $.const('params')\n          .type(returnType)\n          .assign(\n            $.object()\n              .prop('_id', 'id')\n              .prop(\n                baseUrlKey,\n                $('options')\n                  .attr(baseUrlKey)\n                  .optional()\n                  .or(\n                    $('options')\n                      .attr('client')\n                      .optional()\n                      .$if(symbolClient, (a, v) => a.coalesce(v))\n                      .attr('getConfig')\n                      .call()\n                      .attr(baseUrlKey),\n                  ),\n              )\n              .as(returnType),\n          ),\n        $.if('infinite').do($('params').attr('_infinite').assign('infinite')),\n        $.if('tags').do($('params').attr('tags').assign('tags')),\n        $.if($('options').attr('body').optional()).do(\n          $('params').attr('body').assign($('options').attr('body')),\n        ),\n        $.if($('options').attr('headers').optional()).do(\n          $('params').attr('headers').assign($('options').attr('headers')),\n        ),\n        $.if($('options').attr('path').optional()).do(\n          $('params').attr('path').assign($('options').attr('path')),\n        ),\n        $.if($('options').attr('query').optional()).do(\n          $('params').attr('query').assign($('options').attr('query')),\n        ),\n        $.return($.array().element($('params'))),\n      ),\n  );\n  plugin.node(fn);\n};\n\nconst createQueryKeyLiteral = ({\n  id,\n  isInfinite,\n  operation,\n  plugin,\n}: {\n  id: string;\n  isInfinite?: boolean;\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}) => {\n  const config = isInfinite ? plugin.config.infiniteQueryKeys : plugin.config.queryKeys;\n  let tagsArray: TsDsl<ts.ArrayLiteralExpression> | undefined;\n  if (config.tags && operation.tags && operation.tags.length > 0) {\n    tagsArray = $.array().elements(...operation.tags);\n  }\n  const symbolCreateQueryKey = plugin.referenceSymbol({\n    category: 'utility',\n    resource: 'createQueryKey',\n    tool: plugin.name,\n  });\n  const createQueryKeyCallExpression = $(symbolCreateQueryKey).call(\n    $.literal(id),\n    'options',\n    isInfinite || tagsArray ? $.literal(Boolean(isInfinite)) : undefined,\n    tagsArray,\n  );\n  return createQueryKeyCallExpression;\n};\n\nexport const createQueryKeyType = ({ plugin }: { plugin: PluginInstance }) => {\n  const symbolOptions = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'client-options',\n    tool: 'sdk',\n  });\n  const symbolQueryKeyType = plugin.symbol('QueryKey', {\n    meta: {\n      category: 'type',\n      resource: 'QueryKey',\n      tool: plugin.name,\n    },\n  });\n  const queryKeyType = $.type\n    .alias(symbolQueryKeyType)\n    .export()\n    .generic(TOptionsType, (g) => g.extends(symbolOptions))\n    .type(\n      $.type.tuple(\n        $.type.and(\n          $.type(\n            `Pick<${TOptionsType}, '${getClientBaseUrlKey(getTypedConfig(plugin))}' | 'body' | 'headers' | 'path' | 'query'>`,\n          ),\n          $.type\n            .object()\n            .prop('_id', (p) => p.type('string'))\n            .prop('_infinite', (p) => p.optional().type('boolean'))\n            .prop('tags', (p) => p.optional().type('ReadonlyArray<string>')),\n        ),\n      ),\n    );\n  plugin.node(queryKeyType);\n};\n\nexport const queryKeyStatement = ({\n  isInfinite,\n  operation,\n  plugin,\n  symbol,\n  typeQueryKey,\n}: {\n  isInfinite: boolean;\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n  symbol: Symbol;\n  typeQueryKey?: ReturnType<typeof $.type>;\n}) => {\n  const typeData = useTypeData({ operation, plugin });\n  const statement = $.const(symbol)\n    .export()\n    .assign(\n      $.func()\n        .param('options', (p) => p.required(hasOperationDataRequired(operation)).type(typeData))\n        .$if(isInfinite && typeQueryKey, (f, v) => f.returns(v))\n        .do(\n          createQueryKeyLiteral({\n            id: operation.id,\n            isInfinite,\n            operation,\n            plugin,\n          }).return(),\n        ),\n    );\n  return statement;\n};\n","import type { IR } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport type { PluginInstance } from '../types';\n\nexport const handleMeta = (\n  plugin: PluginInstance,\n  operation: IR.OperationObject,\n  configPath: 'queryOptions' | 'infiniteQueryOptions' | 'mutationOptions',\n): ReturnType<typeof $.fromValue> | undefined => {\n  const metaFn = plugin.config[configPath].meta;\n  if (!metaFn) return;\n\n  const metaObject = metaFn(operation);\n  if (!Object.keys(metaObject).length) return;\n\n  return $.fromValue(metaObject);\n};\n","import { ref } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming, operationPagination } from '@hey-api/shared';\n\nimport {\n  createOperationComment,\n  isOperationOptionsRequired,\n} from '../../../../plugins/shared/utils/operation';\nimport type { TsDsl } from '../../../../ts-dsl';\nimport { $ } from '../../../../ts-dsl';\nimport { createQueryKeyFunction, createQueryKeyType, queryKeyStatement } from '../queryKey';\nimport { handleMeta } from '../shared/meta';\nimport { useTypeData, useTypeError, useTypeResponse } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nconst createInfiniteParamsFunction = ({ plugin }: { plugin: PluginInstance }) => {\n  const symbolCreateInfiniteParams = plugin.symbol(\n    applyNaming('createInfiniteParams', {\n      case: plugin.config.case,\n    }),\n    {\n      meta: {\n        category: 'utility',\n        resource: 'createInfiniteParams',\n        tool: plugin.name,\n      },\n    },\n  );\n\n  const fn = $.const(symbolCreateInfiniteParams).assign(\n    $.func()\n      .generic('K', (g) =>\n        g.extends(\n          $.type('Pick').generics(\n            $.type('QueryKey').generic('Options').idx(0),\n            $.type.or(\n              $.type.literal('body'),\n              $.type.literal('headers'),\n              $.type.literal('path'),\n              $.type.literal('query'),\n            ),\n          ),\n        ),\n      )\n      .param('queryKey', (p) => p.type('QueryKey<Options>'))\n      .param('page', (p) => p.type('K'))\n      .do(\n        $.const('params').assign($.object().spread($('queryKey').attr(0))),\n        $.if($('page').attr('body')).do(\n          $('params')\n            .attr('body')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('body').as('any'))\n                .spread($('page').attr('body').as('any')),\n            ),\n        ),\n        $.if($('page').attr('headers')).do(\n          $('params')\n            .attr('headers')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('headers'))\n                .spread($('page').attr('headers')),\n            ),\n        ),\n        $.if($('page').attr('path')).do(\n          $('params')\n            .attr('path')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('path').as('any'))\n                .spread($('page').attr('path').as('any')),\n            ),\n        ),\n        $.if($('page').attr('query')).do(\n          $('params')\n            .attr('query')\n            .assign(\n              $.object()\n                .pretty()\n                .spread($('queryKey').attr(0).attr('query').as('any'))\n                .spread($('page').attr('query').as('any')),\n            ),\n        ),\n        $.return($('params').as('unknown').as($('page').typeofType())),\n      ),\n  );\n  plugin.node(fn);\n};\n\nexport const createInfiniteQueryOptions = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): void => {\n  const pagination = operationPagination({\n    context: plugin.context,\n    operation,\n  });\n\n  if (!pagination) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    })\n  ) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createInfiniteParams',\n      tool: plugin.name,\n    })\n  ) {\n    createInfiniteParamsFunction({ plugin });\n  }\n\n  const symbolInfiniteQueryOptions = plugin.external(`${plugin.name}.infiniteQueryOptions`);\n  const symbolInfiniteDataType = plugin.external(`${plugin.name}.InfiniteData`);\n\n  const typeData = useTypeData({ operation, plugin });\n  const typeResponse = useTypeResponse({ operation, plugin });\n\n  const symbolQueryKeyType = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'QueryKey',\n    tool: plugin.name,\n  });\n  const typeQueryKey = $.type(symbolQueryKeyType).generic(typeData);\n  const typePageObjectParam = $.type('Pick').generics(\n    typeQueryKey.idx(0),\n    $.type.or(\n      $.type.literal('body'),\n      $.type.literal('headers'),\n      $.type.literal('path'),\n      $.type.literal('query'),\n    ),\n  );\n  const pluginTypeScript = plugin.getPluginOrThrow('@hey-api/typescript');\n  const type = pluginTypeScript.api.schemaToType({\n    plugin: pluginTypeScript,\n    schema: pagination.schema,\n    state: {\n      path: ref([]),\n    },\n  });\n\n  const symbolInfiniteQueryKey = plugin.symbol(\n    applyNaming(operation.id, plugin.config.infiniteQueryKeys),\n  );\n  const node = queryKeyStatement({\n    isInfinite: true,\n    operation,\n    plugin,\n    symbol: symbolInfiniteQueryKey,\n    typeQueryKey,\n  });\n  plugin.node(node);\n\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call(\n        $.object()\n          .spread('options')\n          .spread('params')\n          .prop('signal', $('signal'))\n          .prop('throwOnError', $.literal(true)),\n      )\n      .await(),\n  );\n\n  const symbolCreateInfiniteParams = plugin.referenceSymbol({\n    category: 'utility',\n    resource: 'createInfiniteParams',\n    tool: plugin.name,\n  });\n\n  const statements: Array<TsDsl<any>> = [\n    $.const('page')\n      .type(typePageObjectParam)\n      .hint('@ts-ignore')\n      .assign(\n        $.ternary($('pageParam').typeofExpr().eq($.literal('object')))\n          .do('pageParam')\n          .otherwise(\n            $.object()\n              .pretty()\n              .prop(pagination.in, $.object().pretty().prop(pagination.name, $('pageParam'))),\n          ),\n      ),\n    $.const('params').assign($(symbolCreateInfiniteParams).call('queryKey', 'page')),\n  ];\n\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push($.const().object('data').assign(awaitSdkFn), $.return('data'));\n  }\n\n  const symbolInfiniteQueryOptionsFn = plugin.symbol(\n    applyNaming(operation.id, plugin.config.infiniteQueryOptions),\n  );\n  const statement = $.const(symbolInfiniteQueryOptionsFn)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v))\n    .assign(\n      $.func()\n        .param('options', (p) => p.required(isRequiredOptions).type(typeData))\n        .do(\n          $.return(\n            $(symbolInfiniteQueryOptions)\n              .call(\n                $.object()\n                  .pretty()\n                  .hint('@ts-ignore')\n                  .prop(\n                    'queryFn',\n                    $.func()\n                      .async()\n                      .param((p) => p.object('pageParam', 'queryKey', 'signal'))\n                      .do(...statements),\n                  )\n                  .prop('queryKey', $(symbolInfiniteQueryKey).call('options'))\n                  .$if(handleMeta(plugin, operation, 'infiniteQueryOptions'), (o, v) =>\n                    o.prop('meta', v),\n                  ),\n              )\n              .generics(\n                typeResponse,\n                useTypeError({ operation, plugin }),\n                $.type(symbolInfiniteDataType).generic(typeResponse),\n                typeQueryKey,\n                $.type.or(type, typePageObjectParam),\n              ),\n          ),\n        ),\n    );\n  plugin.node(statement);\n};\n","import type { IR } from '@hey-api/shared';\nimport { applyNaming } from '@hey-api/shared';\n\nimport { createOperationComment } from '../../../../plugins/shared/utils/operation';\nimport type { TsDsl } from '../../../../ts-dsl';\nimport { $ } from '../../../../ts-dsl';\nimport { handleMeta } from '../shared/meta';\nimport { useTypeData, useTypeError, useTypeResponse } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nexport const createMutationOptions = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): void => {\n  const symbolMutationOptionsType = plugin.external(`${plugin.name}.MutationOptions`);\n\n  const typeData = useTypeData({ operation, plugin });\n  const mutationType = $.type(symbolMutationOptionsType)\n    .generic(useTypeResponse({ operation, plugin }))\n    .generic(useTypeError({ operation, plugin }))\n    .generic(typeData);\n\n  const fnOptions = 'fnOptions';\n\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call($.object().spread('options').spread(fnOptions).prop('throwOnError', $.literal(true)))\n      .await(),\n  );\n\n  const statements: Array<TsDsl<any>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push($.const().object('data').assign(awaitSdkFn), $.return('data'));\n  }\n\n  const mutationOptionsFn = 'mutationOptions';\n  const symbolMutationOptions = plugin.symbol(\n    applyNaming(operation.id, plugin.config.mutationOptions),\n    {\n      meta: {\n        category: 'hook',\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'mutationOptions',\n        tool: plugin.name,\n      },\n    },\n  );\n  const statement = $.const(symbolMutationOptions)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v))\n    .assign(\n      $.func()\n        .param('options', (p) => p.optional().type($.type('Partial').generic(typeData)))\n        .returns(mutationType)\n        .do(\n          $.const(mutationOptionsFn)\n            .type(mutationType)\n            .assign(\n              $.object()\n                .pretty()\n                .prop(\n                  'mutationFn',\n                  $.func()\n                    .async()\n                    .param(fnOptions)\n                    .do(...statements),\n                )\n                .$if(handleMeta(plugin, operation, 'mutationOptions'), (c, v) => c.prop('meta', v)),\n            ),\n          $(mutationOptionsFn).return(),\n        ),\n    );\n  plugin.node(statement);\n};\n","import type { IR } from '@hey-api/shared';\nimport { applyNaming } from '@hey-api/shared';\n\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '../../../../plugins/shared/utils/operation';\nimport type { TsDsl } from '../../../../ts-dsl';\nimport { $ } from '../../../../ts-dsl';\nimport { createQueryKeyFunction, createQueryKeyType, queryKeyStatement } from '../queryKey';\nimport { handleMeta } from '../shared/meta';\nimport { useTypeData, useTypeError, useTypeResponse } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nconst optionsParamName = 'options';\n\nexport const createQueryOptions = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n\n  if (\n    !plugin.getSymbol({\n      category: 'utility',\n      resource: 'createQueryKey',\n      tool: plugin.name,\n    })\n  ) {\n    createQueryKeyType({ plugin });\n    createQueryKeyFunction({ plugin });\n  }\n\n  const symbolQueryOptions = plugin.external(`${plugin.name}.queryOptions`);\n\n  const symbolQueryKey = plugin.symbol(applyNaming(operation.id, plugin.config.queryKeys));\n  const node = queryKeyStatement({\n    isInfinite: false,\n    operation,\n    plugin,\n    symbol: symbolQueryKey,\n  });\n  plugin.node(node);\n\n  const typeResponse = useTypeResponse({ operation, plugin });\n\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call(\n        $.object()\n          .spread(optionsParamName)\n          .spread($('queryKey').attr(0))\n          .prop('signal', $('signal'))\n          .prop('throwOnError', $.literal(true)),\n      )\n      .await(),\n  );\n\n  const statements: Array<TsDsl<any>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push($.const().object('data').assign(awaitSdkFn), $.return('data'));\n  }\n\n  const queryOptionsObj = $.object()\n    .pretty()\n    .prop(\n      'queryFn',\n      $.func()\n        .async()\n        .param((p) => p.object('queryKey', 'signal'))\n        .do(...statements),\n    )\n    .prop('queryKey', $(symbolQueryKey).call(optionsParamName))\n    .$if(handleMeta(plugin, operation, 'queryOptions'), (o, v) => o.prop('meta', v));\n\n  const symbolQueryOptionsFn = plugin.symbol(\n    applyNaming(operation.id, plugin.config.queryOptions),\n    {\n      meta: {\n        category: 'hook',\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'queryOptions',\n        tool: plugin.name,\n      },\n    },\n  );\n  // TODO: add type error\n  // TODO: AxiosError<PutSubmissionMetaError>\n  const statement = $.const(symbolQueryOptionsFn)\n    .export(plugin.config.queryOptions.exported)\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v))\n    .assign(\n      $.func()\n        .param(optionsParamName, (p) =>\n          p.required(isRequiredOptions).type(useTypeData({ operation, plugin })),\n        )\n        .do(\n          $(symbolQueryOptions)\n            .call(queryOptionsObj)\n            .generics(\n              typeResponse,\n              useTypeError({ operation, plugin }),\n              typeResponse,\n              $(symbolQueryKey).returnType(),\n            )\n            .return(),\n        ),\n    );\n  plugin.node(statement);\n};\n","import type { IR } from '@hey-api/shared';\nimport { applyNaming } from '@hey-api/shared';\n\nimport {\n  createOperationComment,\n  hasOperationSse,\n  isOperationOptionsRequired,\n} from '../../../../plugins/shared/utils/operation';\nimport { $ } from '../../../../ts-dsl';\nimport { useTypeData } from '../shared/useType';\nimport type { PluginInstance } from '../types';\n\nconst optionsParamName = 'options';\n\nexport const createUseQuery = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: PluginInstance;\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  if (!('useQuery' in plugin.config)) {\n    return;\n  }\n\n  const symbolUseQueryFn = plugin.symbol(applyNaming(operation.id, plugin.config.useQuery));\n\n  const symbolUseQuery = plugin.external(`${plugin.name}.useQuery`);\n\n  const isRequiredOptions = isOperationOptionsRequired({\n    context: plugin.context,\n    operation,\n  });\n  const typeData = useTypeData({ operation, plugin });\n\n  const symbolQueryOptionsFn = plugin.referenceSymbol({\n    category: 'hook',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'queryOptions',\n    tool: plugin.name,\n  });\n  const statement = $.const(symbolUseQueryFn)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v))\n    .assign(\n      $.func()\n        .param(optionsParamName, (p) => p.required(isRequiredOptions).type(typeData))\n        .do($(symbolUseQuery).call($(symbolQueryOptionsFn).call(optionsParamName)).return()),\n    );\n  plugin.node(statement);\n};\n","import type { PluginHandler } from '../types';\nimport { createInfiniteQueryOptions } from './infiniteQueryOptions';\nimport { createMutationOptions } from './mutationOptions';\nimport { createQueryOptions } from './queryOptions';\nimport { createUseQuery } from './useQuery';\n\nexport const handlerV5: PluginHandler = ({ plugin }) => {\n  plugin.symbol('DefaultError', {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.DefaultError`,\n    },\n  });\n  plugin.symbol('InfiniteData', {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.InfiniteData`,\n    },\n  });\n  const mutationsType =\n    plugin.name === '@tanstack/angular-query-experimental' ||\n    plugin.name === '@tanstack/svelte-query' ||\n    plugin.name === '@tanstack/solid-query'\n      ? 'MutationOptions'\n      : 'UseMutationOptions';\n  plugin.symbol(mutationsType, {\n    external: plugin.name,\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.MutationOptions`,\n    },\n  });\n  plugin.symbol('infiniteQueryOptions', {\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.infiniteQueryOptions`,\n    },\n  });\n  plugin.symbol('queryOptions', {\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.queryOptions`,\n    },\n  });\n  plugin.symbol('useQuery', {\n    external: plugin.name,\n    meta: {\n      category: 'external',\n      resource: `${plugin.name}.useQuery`,\n    },\n  });\n  plugin.symbol('AxiosError', {\n    external: 'axios',\n    kind: 'type',\n    meta: {\n      category: 'external',\n      resource: 'axios.AxiosError',\n    },\n  });\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      if (plugin.hooks.operation.isQuery(operation)) {\n        if (plugin.config.queryOptions.enabled) {\n          createQueryOptions({ operation, plugin });\n        }\n\n        if (plugin.config.infiniteQueryOptions.enabled) {\n          createInfiniteQueryOptions({ operation, plugin });\n        }\n\n        if ('useQuery' in plugin.config && plugin.config.useQuery.enabled) {\n          createUseQuery({ operation, plugin });\n        }\n      }\n\n      if (plugin.hooks.operation.isMutation(operation)) {\n        if (plugin.config.mutationOptions.enabled) {\n          createMutationOptions({ operation, plugin });\n        }\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import type { PluginHandler } from './types';\nimport { handlerV5 } from './v5/plugin';\n\nexport const handler: PluginHandler = (args) => handlerV5(args as Parameters<PluginHandler>[0]);\n","import { definePluginConfig, mappers } from '@hey-api/shared';\n\nimport { handler } from '../../../plugins/@tanstack/query-core/plugin';\nimport type { TanStackAngularQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackAngularQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    includeInEntry: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackAngularQueryPlugin['Handler'],\n  name: '@tanstack/angular-query-experimental',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers,\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers,\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers,\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/angular-query-experimental` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig, mappers } from '@hey-api/shared';\n\nimport { handler } from '../../../plugins/@tanstack/query-core/plugin';\nimport type { TanStackReactQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackReactQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    includeInEntry: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackReactQueryPlugin['Handler'],\n  name: '@tanstack/react-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers,\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers,\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers,\n      value: plugin.config.queryOptions,\n    });\n\n    plugin.config.useQuery = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: false,\n        name: 'use{{name}}Query',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ enabled: true, name }),\n        object: (fields) => ({ enabled: true, ...fields }),\n        string: (name) => ({ enabled: true, name }),\n      },\n      value: plugin.config.useQuery,\n    });\n\n    if (plugin.config.useQuery.enabled) {\n      // useQuery hooks consume queryOptions\n      if (!plugin.config.queryOptions.enabled) {\n        plugin.config.queryOptions.enabled = true;\n        plugin.config.queryOptions.exported = false;\n      }\n    }\n  },\n};\n\n/**\n * Type helper for `@tanstack/react-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig, mappers } from '@hey-api/shared';\n\nimport { handler } from '../../../plugins/@tanstack/query-core/plugin';\nimport type { TanStackSolidQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackSolidQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    includeInEntry: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackSolidQueryPlugin['Handler'],\n  name: '@tanstack/solid-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers,\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers,\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers,\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/solid-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig, mappers } from '@hey-api/shared';\n\nimport { handler } from '../../../plugins/@tanstack/query-core/plugin';\nimport type { TanStackSvelteQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackSvelteQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    includeInEntry: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackSvelteQueryPlugin['Handler'],\n  name: '@tanstack/svelte-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers,\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers,\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers,\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/svelte-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { definePluginConfig, mappers } from '@hey-api/shared';\n\nimport { handler } from '../../../plugins/@tanstack/query-core/plugin';\nimport type { TanStackVueQueryPlugin } from './types';\n\nexport const defaultConfig: TanStackVueQueryPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    includeInEntry: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as TanStackVueQueryPlugin['Handler'],\n  name: '@tanstack/vue-query',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers,\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers,\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers,\n      value: plugin.config.queryOptions,\n    });\n  },\n};\n\n/**\n * Type helper for `@tanstack/vue-query` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import { $ } from '../../../ts-dsl';\nimport type { ValidatorArgs } from '../shared/types';\n\nexport const createRequestValidatorV2 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'arktype',\n  });\n  if (!symbol) return;\n\n  // const out = User({\n  //   name: \"Alan Turing\",\n  //   device: {\n  //     platform: \"enigma\",\n  //     versions: [0, \"1\", 0n]\n  //   }\n  // })\n  // if (out instanceof type.errors) {\n  //   // hover out.summary to see validation errors\n  //   console.error(out.summary)\n  // } else {\n  //   // hover out to see your validated data\n  //   console.log(`Hello, ${out.name}`)\n  // }\n  const dataParameterName = 'data';\n  return $.func()\n    .async()\n    .param(dataParameterName)\n    .do($(symbol).attr('parseAsync').call(dataParameterName).await().return());\n};\n\nexport const createResponseValidatorV2 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'arktype',\n  });\n  if (!symbol) return;\n\n  const dataParameterName = 'data';\n  return $.func()\n    .async()\n    .param(dataParameterName)\n    .do($(symbol).attr('parseAsync').call(dataParameterName).await().return());\n};\n","import type { $ } from '../../ts-dsl';\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV2, createResponseValidatorV2 } from './v2/api';\n\nexport type IApi = {\n  createRequestValidator: (args: ValidatorArgs) => ReturnType<typeof $.func> | undefined;\n  createResponseValidator: (args: ValidatorArgs) => ReturnType<typeof $.func> | undefined;\n};\n\nexport class Api implements IApi {\n  createRequestValidator(args: ValidatorArgs): ReturnType<typeof $.func> | undefined {\n    return createRequestValidatorV2(args);\n  }\n\n  createResponseValidator(args: ValidatorArgs): ReturnType<typeof $.func> | undefined {\n    return createResponseValidatorV2(args);\n  }\n}\n","export const identifiers = {\n  keywords: {\n    false: 'false',\n    true: 'true',\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives#number Number}\n   */\n  number: {\n    Infinity: 'Infinity',\n    NaN: 'NaN',\n    NegativeInfinity: 'NegativeInfinity',\n    epoch: 'epoch',\n    integer: 'integer',\n    safe: 'safe',\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives Primitives}\n   */\n  primitives: {\n    bigint: 'bigint',\n    boolean: 'boolean',\n    keywords: 'keywords',\n    null: 'null',\n    number: 'number',\n    string: 'string',\n    symbol: 'symbol',\n    undefined: 'undefined',\n    unit: 'unit',\n  },\n  /**\n   * {@link https://arktype.io/docs/primitives#string String}\n   */\n  string: {\n    NFC: 'NFC',\n    NFD: 'NFD',\n    NFKC: 'NFKC',\n    NFKD: 'NFKD',\n    alpha: 'alpha',\n    alphanumeric: 'alphanumeric',\n    base64: 'base64',\n    capitalize: 'capitalize',\n    creditCard: 'creditCard',\n    date: 'date',\n    digits: 'digits',\n    email: 'email',\n    epoch: 'epoch',\n    hex: 'hex',\n    integer: 'integer',\n    ip: 'ip',\n    iso: 'iso',\n    json: 'json',\n    lower: 'lower',\n    normalize: 'normalize',\n    numeric: 'numeric',\n    parse: 'parse',\n    preformatted: 'preformatted',\n    regex: 'regex',\n    semver: 'semver',\n    trim: 'trim',\n    upper: 'upper',\n    url: 'url',\n    uuid: 'uuid',\n    v1: 'v1',\n    v2: 'v2',\n    v3: 'v3',\n    v4: 'v4',\n    v5: 'v5',\n    v6: 'v6',\n    v7: 'v7',\n    v8: 'v8',\n  },\n  /**\n   * {@link https://arktype.io/docs/type-api Type API}\n   */\n  type: {\n    $: '$',\n    allows: 'allows',\n    and: 'and',\n    array: 'array',\n    as: 'as',\n    assert: 'assert',\n    brand: 'brand',\n    configure: 'configure',\n    default: 'default',\n    describe: 'describe',\n    description: 'description',\n    equals: 'equals',\n    exclude: 'exclude',\n    expression: 'expression',\n    extends: 'extends',\n    extract: 'extract',\n    filter: 'filter',\n    from: 'from',\n    ifEquals: 'ifEquals',\n    ifExtends: 'ifExtends',\n    infer: 'infer',\n    inferIn: 'inferIn',\n    intersect: 'intersect',\n    json: 'json',\n    meta: 'meta',\n    narrow: 'narrow',\n    onDeepUndeclaredKey: 'onDeepUndeclaredKey',\n    onUndeclaredKey: 'onUndeclaredKey',\n    optional: 'optional',\n    or: 'or',\n    overlaps: 'overlaps',\n    pipe: 'pipe',\n    select: 'select',\n    to: 'to',\n    toJsonSchema: 'toJsonSchema',\n  },\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\n\nimport { createSchemaComment } from '../../../plugins/shared/utils/schema';\nimport { $ } from '../../../ts-dsl';\nimport { identifiers } from '../constants';\nimport type { ArktypePlugin } from '../types';\nimport type { Ast } from './types';\n\nexport function exportAst({\n  ast,\n  plugin,\n  schema,\n  symbol,\n  typeInferSymbol,\n}: {\n  ast: Ast;\n  plugin: ArktypePlugin['Instance'];\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n  typeInferSymbol: Symbol | undefined;\n}): void {\n  const type = plugin.external('arktype.type');\n\n  const statement = $.const(symbol)\n    .export()\n    .$if(plugin.config.comments && createSchemaComment(schema), (c, v) => c.doc(v))\n    // .type(\n    //   ast.typeName\n    //     ? (tsc.propertyAccessExpression({\n    //         expression: z,\n    //         name: ast.typeName,\n    //       }) as unknown as ts.TypeNode)\n    //     : undefined,\n    // )\n    .assign($(type).call(ast.def ? $.literal(ast.def) : ast.expression));\n  plugin.node(statement);\n\n  if (typeInferSymbol) {\n    const inferType = $.type\n      .alias(typeInferSymbol)\n      .export()\n      .type($.type(symbol).attr(identifiers.type.infer).typeofType());\n    plugin.node(inferType);\n  }\n}\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = (\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _args: IrSchemaToAstOptions & {\n    schema: SchemaWithType<'null'>;\n  },\n): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.def = identifiers.primitives.null;\n  return result as Omit<Ast, 'typeName'>;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\n// import { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  // TODO: parser - handle constants\n\n  const shape = $.object().pretty();\n\n  const required = schema.required ?? [];\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n    const isRequired = required.includes(name);\n\n    const propertyAst = irSchemaToAst({\n      optional: !isRequired,\n      plugin,\n      schema: property,\n      state: {\n        ...state,\n        path: ref([...fromRef(state.path), 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    // if (propertyAst.hasCircularReference) {\n    //   properties.push(\n    //     tsc.getAccessorDeclaration({\n    //       name: propertyName,\n    //       // @ts-expect-error\n    //       returnType: propertyAst.typeName\n    //         ? tsc.propertyAccessExpression({\n    //             expression: 'TODO',\n    //             name: propertyAst.typeName,\n    //           })\n    //         : undefined,\n    //       statements: [\n    //         tsc.returnStatement({\n    //           expression: propertyAst.expression,\n    //         }),\n    //       ],\n    //     }),\n    //   );\n    // } else {\n    //   properties.push(\n    //     tsc.propertyAssignment({\n    //       initializer: propertyAst.expression,\n    //       name: ts.factory.createComputedPropertyName(\n    //         ts.factory.createStringLiteral(`${propertyName}?`),\n    //       ),\n    //     }),\n    //   );\n    // }\n\n    shape.prop(isRequired ? name : `${name}?`, propertyAst.expression);\n  }\n\n  if (\n    schema.additionalProperties &&\n    (!schema.properties || !Object.keys(schema.properties).length)\n  ) {\n    const additionalAst = irSchemaToAst({\n      plugin,\n      schema: schema.additionalProperties,\n      state: {\n        ...state,\n        path: ref([...fromRef(state.path), 'additionalProperties']),\n      },\n    });\n    // name: identifiers.record,\n    result.expression = $('TODO').attr('record').call(\n      // name: identifiers.string,\n      $('TODO').attr('string').call(),\n      additionalAst.expression,\n    );\n    if (additionalAst.hasLazyExpression) {\n      result.hasLazyExpression = true;\n    }\n\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  result.expression = shape;\n\n  // return with typeName for circular references\n  if (result.hasLazyExpression) {\n    return {\n      ...result,\n      typeName: 'TODO',\n    } as Ast;\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const stringToAst = ({\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  if (typeof schema.const === 'string') {\n    result.def = schema.const;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  let def = identifiers.primitives.string;\n\n  if (schema.format) {\n    switch (schema.format) {\n      case 'date':\n      case 'date-time':\n      case 'time':\n        def = `${def}.${identifiers.string.date}.${identifiers.string.iso}`;\n        break;\n      case 'email':\n        def = `${def}.${identifiers.string.email}`;\n        break;\n      case 'ipv4':\n        def = `${def}.${identifiers.string.ip}.${identifiers.string.v4}`;\n        break;\n      case 'ipv6':\n        def = `${def}.${identifiers.string.ip}.${identifiers.string.v6}`;\n        break;\n      case 'uri':\n        def = `${def}.${identifiers.string.url}`;\n        break;\n      case 'uuid':\n        def = `${def}.${identifiers.string.uuid}`;\n        break;\n    }\n  }\n\n  if (schema.minLength === schema.maxLength && schema.minLength !== undefined) {\n    def = `${schema.minLength} <= ${def} <= ${schema.maxLength}`;\n  } else {\n    if (schema.maxLength !== undefined) {\n      def = `${def} <= ${schema.maxLength}`;\n\n      if (schema.minLength !== undefined) {\n        def = `${schema.minLength} <= ${def}`;\n      }\n    } else if (schema.minLength !== undefined) {\n      def = `${def} >= ${schema.minLength}`;\n    }\n  }\n\n  if (schema.pattern) {\n    def = `/${schema.pattern}/`;\n  }\n\n  result.def = def;\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { nullToAst } from './null';\nimport { objectToAst } from './object';\nimport { stringToAst } from './string';\n// import { arrayToAst } from \"./array\";\n// import { booleanToAst } from \"./boolean\";\n// import { enumToAst } from \"./enum\";\n// import { neverToAst } from \"./never\";\n// import { numberToAst } from \"./number\";\n// import { tupleToAst } from \"./tuple\";\n// import { undefinedToAst } from \"./undefined\";\n// import { unknownToAst } from \"./unknown\";\n// import { voidToAst } from \"./void\";\n\nexport function irSchemaWithTypeToAst({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> {\n  switch (schema.type) {\n    // case 'array':\n    //   return arrayToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'array'>,\n    //   });\n    // case 'boolean':\n    //   return booleanToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'boolean'>,\n    //   });\n    // case 'enum':\n    //   return enumToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'enum'>,\n    //   });\n    // case 'integer':\n    // case 'number':\n    //   return numberToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'integer' | 'number'>,\n    //   });\n    // case 'never':\n    //   return neverToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'never'>,\n    //   });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return stringToAst({\n        ...args,\n        schema: schema as SchemaWithType<'string'>,\n      });\n    // case 'tuple':\n    //   return tupleToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'tuple'>,\n    //   });\n    // case 'undefined':\n    //   return undefinedToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'undefined'>,\n    //   });\n    // case 'unknown':\n    //   return unknownToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'unknown'>,\n    //   });\n    // case 'void':\n    //   return voidToAst({\n    //     ...args,\n    //     schema: schema as SchemaWithType<'void'>,\n    //   });\n  }\n\n  const type = args.plugin.external('arktype.type');\n\n  const expression = $(type).call(\n    $.object()\n      .prop('name', $.literal('string'))\n      .prop('platform', $.literal(\"'android' | 'ios'\"))\n      .prop('versions?', $.literal('(number | string)[]')),\n  );\n\n  return {\n    def: '',\n    expression,\n    hasLazyExpression: false,\n  };\n}\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { fromRef, refs } from '@hey-api/codegen-core';\nimport type { IR, SchemaWithType } from '@hey-api/shared';\nimport { applyNaming, deduplicateSchema, pathToJsonPointer, refToName } from '@hey-api/shared';\n\nimport { $ } from '../../../ts-dsl';\nimport { exportAst } from '../shared/export';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport type { ArktypePlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport function irSchemaToAst({\n  // optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast {\n  let ast: Partial<Ast> = {};\n\n  // const z = plugin.referenceSymbol({\n  //   category: 'external',\n  //   resource: 'arktype.type',\n  // });\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'arktype',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      const ref = $(refSymbol);\n      ast.expression = ref;\n    } else {\n      // expression: z,\n      // name: identifiers.lazy,\n      const lazyExpression = $('TODO')\n        .attr('TODO')\n        .call($.func().returns('any').do($.return(refSymbol)));\n      ast.expression = lazyExpression;\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression['~ref'] = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.def = typeAst.def;\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      // TODO: add description\n      // ast.expression = tsc.callExpression({\n      //   functionName: tsc.propertyAccessExpression({\n      //     expression: ast.expression,\n      //     name: identifiers.register,\n      //   }),\n      //   parameters: [\n      //     tsc.propertyAccessExpression({\n      //       expression: z,\n      //       name: identifiers.globalRegistry,\n      //     }),\n      //     tsc.objectExpression({\n      //       obj: [\n      //         {\n      //           key: 'description',\n      //           value: tsc.stringLiteral({ text: schema.description }),\n      //         },\n      //       ],\n      //     }),\n      //   ],\n      // });\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      //     const itemSchemas = schema.items.map((item, index) =>\n      //       irSchemaToAst({\n      //         plugin,\n      //         schema: item,\n      //         state: {\n      //           ...state,\n      //           _path: [...state._path, 'items', index],\n      //         },\n      //       }),\n      //     );\n      //     if (schema.logicalOperator === 'and') {\n      //       const firstSchema = schema.items[0]!;\n      //       // we want to add an intersection, but not every schema can use the same API.\n      //       // if the first item contains another array or not an object, we cannot use\n      //       // `.merge()` as that does not exist on `.union()` and non-object schemas.\n      //       if (\n      //         firstSchema.logicalOperator === 'or' ||\n      //         (firstSchema.type && firstSchema.type !== 'object')\n      //       ) {\n      //         ast.expression = tsc.callExpression({\n      //           functionName: tsc.propertyAccessExpression({\n      //             expression: z,\n      //             name: identifiers.intersection,\n      //           }),\n      //           parameters: itemSchemas.map((schema) => schema.expression),\n      //         });\n      //       } else {\n      //         ast.expression = itemSchemas[0]!.expression;\n      //         itemSchemas.slice(1).forEach((schema) => {\n      //           ast.expression = tsc.callExpression({\n      //             functionName: tsc.propertyAccessExpression({\n      //               expression: ast.expression!,\n      //               name: identifiers.and,\n      //             }),\n      //             parameters: [\n      //               schema.hasCircularReference\n      //                 ? tsc.callExpression({\n      //                     functionName: tsc.propertyAccessExpression({\n      //                       expression: z,\n      //                       name: identifiers.lazy,\n      //                     }),\n      //                     parameters: [\n      //                       tsc.arrowFunction({\n      //                         statements: [\n      //                           tsc.returnStatement({\n      //                             expression: schema.expression,\n      //                           }),\n      //                         ],\n      //                       }),\n      //                     ],\n      //                   })\n      //                 : schema.expression,\n      //             ],\n      //           });\n      //         });\n      //       }\n      //     } else {\n      //       ast.expression = tsc.callExpression({\n      //         functionName: tsc.propertyAccessExpression({\n      //           expression: z,\n      //           name: identifiers.union,\n      //         }),\n      //         parameters: [\n      //           tsc.arrayLiteralExpression({\n      //             elements: itemSchemas.map((schema) => schema.expression),\n      //           }),\n      //         ],\n      //       });\n      //     }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.def = typeAst.def;\n    ast.expression = typeAst.expression;\n  }\n\n  // TODO: remove later\n  if (!ast.expression) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n  // END TODO: remove later\n\n  // if (ast.expression) {\n  //   if (schema.accessScope === 'read') {\n  //     ast.expression = tsc.callExpression({\n  //       functionName: tsc.propertyAccessExpression({\n  //         expression: ast.expression,\n  //         name: identifiers.readonly,\n  //       }),\n  //     });\n  //   }\n\n  //   if (optional) {\n  //     ast.expression = tsc.callExpression({\n  //       functionName: tsc.propertyAccessExpression({\n  //         expression: z,\n  //         name: identifiers.optional,\n  //       }),\n  //       parameters: [ast.expression],\n  //     });\n  //     ast.typeName = identifiers.ZodOptional;\n  //   }\n\n  //   if (schema.default !== undefined) {\n  //     const isBigInt = schema.type === 'integer' && schema.format === 'int64';\n  //     const callParameter = numberParameter({\n  //       isBigInt,\n  //       value: schema.default,\n  //     });\n  //     if (callParameter) {\n  //       ast.expression = tsc.callExpression({\n  //         functionName: tsc.propertyAccessExpression({\n  //           expression: ast.expression,\n  //           name: identifiers.default,\n  //         }),\n  //         parameters: [callParameter],\n  //       });\n  //     }\n  //   }\n  // }\n\n  return ast as Ast;\n}\n\nfunction handleComponent({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.symbol(applyNaming(baseName, plugin.config.definitions), {\n    meta: {\n      category: 'schema',\n      path: fromRef(state.path),\n      resource: 'definition',\n      resourceId: $ref,\n      tags: fromRef(state.tags),\n      tool: 'arktype',\n    },\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.symbol(applyNaming(baseName, plugin.config.definitions.types.infer), {\n        meta: {\n          category: 'type',\n          path: fromRef(state.path),\n          resource: 'definition',\n          resourceId: $ref,\n          tool: 'arktype',\n          variant: 'infer',\n        },\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n}\n\nexport const handlerV2: ArktypePlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('type', {\n    external: 'arktype',\n    meta: {\n      category: 'external',\n      resource: 'arktype.type',\n    },\n  });\n\n  plugin.forEach('operation', 'parameter', 'requestBody', 'schema', 'webhook', (event) => {\n    const state = refs<PluginState>({\n      hasLazyExpression: false,\n      path: event._path,\n      tags: event.tags,\n    });\n    switch (event.type) {\n      //   case 'operation':\n      //     operationToZodSchema({\n      //       getZodSchema: (schema) => {\n      //         const state: State = {\n      //           circularReferenceTracker: [],\n      //           currentReferenceTracker: [],\n      //           hasCircularReference: false,\n      //         };\n      //         return schemaToZodSchema({ plugin, schema, state });\n      //       },\n      //       operation: event.operation,\n      //       plugin,\n      //     });\n      //     break;\n      case 'parameter':\n        handleComponent({\n          plugin,\n          schema: event.parameter.schema,\n          state,\n        });\n        break;\n      case 'requestBody':\n        handleComponent({\n          plugin,\n          schema: event.requestBody.schema,\n          state,\n        });\n        break;\n      case 'schema':\n        handleComponent({\n          plugin,\n          schema: event.schema,\n          state,\n        });\n        break;\n      //   case 'webhook':\n      //     webhookToZodSchema({\n      //       getZodSchema: (schema) => {\n      //         const state: State = {\n      //           circularReferenceTracker: [],\n      //           currentReferenceTracker: [],\n      //           hasCircularReference: false,\n      //         };\n      //         return schemaToZodSchema({ plugin, schema, state });\n      //       },\n      //       operation: event.operation,\n      //       plugin,\n      //     });\n      //     break;\n    }\n  });\n};\n","import type { ArktypePlugin } from './types';\nimport { handlerV2 } from './v2/plugin';\n\nexport const handler: ArktypePlugin['Handler'] = (args) => handlerV2(args);\n","import { definePluginConfig, mappers } from '@hey-api/shared';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ArktypePlugin } from './types';\n\nexport const defaultConfig: ArktypePlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'PascalCase',\n    comments: true,\n    includeInEntry: false,\n    metadata: false,\n  },\n  handler,\n  name: 'arktype',\n  resolveConfig: (plugin, context) => {\n    plugin.config.types = context.valueToObject({\n      defaultValue: {\n        infer: {\n          case: 'PascalCase',\n          enabled: false,\n        },\n      },\n      mappers: {\n        object: (fields, defaultValue) => ({\n          ...fields,\n          infer: context.valueToObject({\n            defaultValue: {\n              ...(defaultValue.infer as Extract<\n                typeof defaultValue.infer,\n                Record<string, unknown>\n              >),\n              enabled:\n                fields.infer !== undefined\n                  ? Boolean(fields.infer)\n                  : (\n                      defaultValue.infer as Extract<\n                        typeof defaultValue.infer,\n                        Record<string, unknown>\n                      >\n                    ).enabled,\n            },\n            mappers,\n            value: fields.infer,\n          }),\n        }),\n      },\n      value: plugin.config.types,\n    });\n\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}Data',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}Data',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}Response',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}Response',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'PascalCase',\n        enabled: true,\n        name: '{{name}}WebhookRequest',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}WebhookRequest',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Arktype plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '@hey-api/shared';\nimport { hasParameterGroupObjectRequired, operationResponsesMap } from '@hey-api/shared';\n\nimport { $ } from '../../ts-dsl';\nimport type { FastifyPlugin } from './types';\n\nconst operationToRouteHandler = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: FastifyPlugin['Instance'];\n}) => {\n  const type = $.type.object();\n\n  const symbolDataType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'typescript',\n  });\n  if (symbolDataType) {\n    if (operation.body) {\n      type.prop('Body', (p) =>\n        p\n          .required(operation.body!.required)\n          .type($.type(symbolDataType).idx($.type.literal('body'))),\n      );\n    }\n\n    if (operation.parameters) {\n      if (operation.parameters.header) {\n        type.prop('Headers', (p) =>\n          p\n            .required(hasParameterGroupObjectRequired(operation.parameters!.header))\n            .type($.type(symbolDataType).idx($.type.literal('headers'))),\n        );\n      }\n\n      if (operation.parameters.path) {\n        type.prop('Params', (p) =>\n          p\n            .required(hasParameterGroupObjectRequired(operation.parameters!.path))\n            .type($.type(symbolDataType).idx($.type.literal('path'))),\n        );\n      }\n\n      if (operation.parameters.query) {\n        type.prop('Querystring', (p) =>\n          p\n            .required(hasParameterGroupObjectRequired(operation.parameters!.query))\n            .type($.type(symbolDataType).idx($.type.literal('query'))),\n        );\n      }\n    }\n  }\n\n  const { errors, responses } = operationResponsesMap(operation);\n\n  let errorsTypeReference: ReturnType<typeof $.type> | undefined;\n  const symbolErrorType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'errors',\n  });\n  if (symbolErrorType && errors && errors.properties) {\n    const keys = Object.keys(errors.properties);\n    if (keys.length) {\n      const hasDefaultResponse = keys.includes('default');\n      if (!hasDefaultResponse) {\n        errorsTypeReference = $.type(symbolErrorType);\n      } else if (keys.length > 1) {\n        errorsTypeReference = $.type('Omit', (t) =>\n          t.generics($.type(symbolErrorType), $.type.literal('default')),\n        );\n      }\n    }\n  }\n\n  let responsesTypeReference: ReturnType<typeof $.type> | undefined = undefined;\n  const symbolResponseType = plugin.querySymbol({\n    category: 'type',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n  });\n  if (symbolResponseType && responses && responses.properties) {\n    const keys = Object.keys(responses.properties);\n    if (keys.length) {\n      const hasDefaultResponse = keys.includes('default');\n      if (!hasDefaultResponse) {\n        responsesTypeReference = $.type(symbolResponseType);\n      } else if (keys.length > 1) {\n        responsesTypeReference = $.type('Omit', (t) =>\n          t.generics($.type(symbolResponseType), $.type.literal('default')),\n        );\n      }\n    }\n  }\n\n  const replyTypes = [errorsTypeReference, responsesTypeReference].filter(\n    (t): t is ReturnType<typeof $.type> => t !== undefined,\n  );\n  if (replyTypes.length) {\n    type.prop('Reply', (p) => p.type($.type.and(...replyTypes)));\n  }\n\n  if (type.isEmpty) {\n    return;\n  }\n\n  const symbolRouteHandler = plugin.referenceSymbol({\n    category: 'type',\n    resource: 'route-handler',\n    tool: 'fastify',\n  });\n  return {\n    name: operation.id,\n    type: $.type(symbolRouteHandler, (t) => t.generic(type)),\n  };\n};\n\nexport const handler: FastifyPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('RouteHandler', {\n    external: 'fastify',\n    kind: 'type',\n    meta: {\n      category: 'type',\n      resource: 'route-handler',\n      tool: 'fastify',\n    },\n  });\n\n  const symbolRouteHandlers = plugin.symbol('RouteHandlers');\n\n  const type = $.type.object();\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      const routeHandler = operationToRouteHandler({ operation, plugin });\n      if (routeHandler) {\n        type.prop(routeHandler.name, (p) => p.type(routeHandler.type));\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n\n  const node = $.type.alias(symbolRouteHandlers).export().type(type);\n  plugin.node(node);\n};\n","import { definePluginConfig } from '@hey-api/shared';\n\nimport { handler } from './plugin';\nimport type { FastifyPlugin } from './types';\n\nexport const defaultConfig: FastifyPlugin['Config'] = {\n  config: {\n    includeInEntry: false,\n  },\n  dependencies: ['@hey-api/typescript'],\n  handler,\n  name: 'fastify',\n};\n\n/**\n * Type helper for `fastify` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { IR } from '@hey-api/shared';\nimport { applyNaming } from '@hey-api/shared';\n\nimport { createOperationComment, hasOperationSse } from '../../../plugins/shared/utils/operation';\nimport type { TsDsl } from '../../../ts-dsl';\nimport { $ } from '../../../ts-dsl';\nimport type { SwrPlugin } from '../types';\n\nexport const createUseSwr = ({\n  operation,\n  plugin,\n}: {\n  operation: IR.OperationObject;\n  plugin: SwrPlugin['Instance'];\n}): void => {\n  if (hasOperationSse({ operation })) {\n    return;\n  }\n\n  const symbolUseSwr = plugin.external('swr');\n  const symbolUseQueryFn = plugin.symbol(applyNaming(operation.id, plugin.config.useSwr));\n\n  const awaitSdkFn = $.lazy((ctx) =>\n    ctx\n      .access(\n        plugin.referenceSymbol({\n          category: 'sdk',\n          resource: 'operation',\n          resourceId: operation.id,\n        }),\n      )\n      .call($.object().prop('throwOnError', $.literal(true)))\n      .await(),\n  );\n\n  const statements: Array<TsDsl<any>> = [];\n  if (plugin.getPluginOrThrow('@hey-api/sdk').config.responseStyle === 'data') {\n    statements.push($.return(awaitSdkFn));\n  } else {\n    statements.push($.const().object('data').assign(awaitSdkFn), $.return('data'));\n  }\n\n  const statement = $.const(symbolUseQueryFn)\n    .export()\n    .$if(plugin.config.comments && createOperationComment(operation), (c, v) => c.doc(v))\n    .assign(\n      $.func().do(\n        $(symbolUseSwr)\n          .call(\n            $.literal(operation.path),\n            $.func()\n              .async()\n              .do(...statements),\n          )\n          .return(),\n      ),\n    );\n  plugin.node(statement);\n};\n","import type { SwrPlugin } from '../types';\nimport { createUseSwr } from './useSwr';\n\nexport const handlerV2: SwrPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('useSWR', {\n    external: 'swr',\n    importKind: 'default',\n    kind: 'function',\n    meta: {\n      category: 'external',\n      resource: 'swr',\n    },\n  });\n\n  plugin.forEach(\n    'operation',\n    ({ operation }) => {\n      if (plugin.hooks.operation.isQuery(operation)) {\n        // if (plugin.config.queryOptions.enabled) {\n        //   createQueryOptions({ operation, plugin });\n        // }\n\n        // if (plugin.config.infiniteQueryOptions.enabled) {\n        //   createInfiniteQueryOptions({ operation, plugin });\n        // }\n\n        if (plugin.config.useSwr.enabled) {\n          createUseSwr({ operation, plugin });\n        }\n      }\n    },\n    {\n      order: 'declarations',\n    },\n  );\n};\n","import type { SwrPlugin } from './types';\nimport { handlerV2 } from './v2/plugin';\n\nexport const handler: SwrPlugin['Handler'] = (args) => handlerV2(args);\n","import { definePluginConfig, mappers } from '@hey-api/shared';\n\nimport { handler } from './plugin';\nimport type { SwrPlugin } from './types';\n\nexport const defaultConfig: SwrPlugin['Config'] = {\n  config: {\n    case: 'camelCase',\n    comments: true,\n    includeInEntry: false,\n  },\n  dependencies: ['@hey-api/sdk', '@hey-api/typescript'],\n  handler: handler as SwrPlugin['Handler'],\n  name: 'swr',\n  resolveConfig: (plugin, context) => {\n    plugin.config.infiniteQueryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteQueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.infiniteQueryKeys,\n    });\n\n    plugin.config.infiniteQueryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}InfiniteOptions',\n      },\n      mappers,\n      value: plugin.config.infiniteQueryOptions,\n    });\n\n    plugin.config.mutationOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}Mutation',\n      },\n      mappers,\n      value: plugin.config.mutationOptions,\n    });\n\n    plugin.config.queryKeys = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: '{{name}}QueryKey',\n        tags: false,\n      },\n      mappers,\n      value: plugin.config.queryKeys,\n    });\n\n    plugin.config.queryOptions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        exported: true,\n        name: '{{name}}Options',\n      },\n      mappers,\n      value: plugin.config.queryOptions,\n    });\n\n    plugin.config.useSwr = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'use{{name}}',\n      },\n      mappers: {\n        boolean: (enabled) => ({ enabled }),\n        function: (name) => ({ enabled: true, name }),\n        object: (fields) => ({ enabled: true, ...fields }),\n        string: (name) => ({ enabled: true, name }),\n      },\n      value: plugin.config.useSwr,\n    });\n\n    if (plugin.config.useSwr.enabled) {\n      // useSwr hooks consume queryOptions\n      if (!plugin.config.queryOptions.enabled) {\n        plugin.config.queryOptions.enabled = true;\n        plugin.config.queryOptions.exported = false;\n      }\n    }\n  },\n};\n\n/**\n * Type helper for `swr` plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","export const identifiers = {\n  /**\n   * {@link https://valibot.dev/api/#actions Actions}\n   */\n  actions: {\n    args: 'args',\n    base64: 'base64',\n    bic: 'bic',\n    brand: 'brand',\n    bytes: 'bytes',\n    check: 'check',\n    checkItems: 'checkItems',\n    creditCard: 'creditCard',\n    cuid2: 'cuid2',\n    decimal: 'decimal',\n    description: 'description',\n    digits: 'digits',\n    email: 'email',\n    emoji: 'emoji',\n    empty: 'empty',\n    endsWith: 'endsWith',\n    entries: 'entries',\n    everyItem: 'everyItem',\n    excludes: 'excludes',\n    filterItems: 'filterItems',\n    findItem: 'findItem',\n    finite: 'finite',\n    flavor: 'flavor',\n    graphemes: 'graphemes',\n    gtValue: 'gtValue',\n    hash: 'hash',\n    hexColor: 'hexColor',\n    hexadecimal: 'hexadecimal',\n    imei: 'imei',\n    includes: 'includes',\n    integer: 'integer',\n    ip: 'ip',\n    ipv4: 'ipv4',\n    ipv6: 'ipv6',\n    isoDate: 'isoDate',\n    isoDateTime: 'isoDateTime',\n    isoTime: 'isoTime',\n    isoTimeSecond: 'isoTimeSecond',\n    isoTimestamp: 'isoTimestamp',\n    isoWeek: 'isoWeek',\n    length: 'length',\n    ltValue: 'ltValue',\n    mac: 'mac',\n    mac48: 'mac48',\n    mac64: 'mac64',\n    mapItems: 'mapItems',\n    maxBytes: 'maxBytes',\n    maxEntries: 'maxEntries',\n    maxGraphemes: 'maxGraphemes',\n    maxLength: 'maxLength',\n    maxSize: 'maxSize',\n    maxValue: 'maxValue',\n    maxWords: 'maxWords',\n    metadata: 'metadata',\n    mimeType: 'mimeType',\n    minBytes: 'minBytes',\n    minEntries: 'minEntries',\n    minGraphemes: 'minGraphemes',\n    minLength: 'minLength',\n    minSize: 'minSize',\n    minValue: 'minValue',\n    minWords: 'minWords',\n    multipleOf: 'multipleOf',\n    nanoid: 'nanoid',\n    nonEmpty: 'nonEmpty',\n    normalize: 'normalize',\n    notBytes: 'notBytes',\n    notEntries: 'notEntries',\n    notGraphemes: 'notGraphemes',\n    notLength: 'notLength',\n    notSize: 'notSize',\n    notValue: 'notValue',\n    notValues: 'notValues',\n    notWords: 'notWords',\n    octal: 'octal',\n    parseJson: 'parseJson',\n    partialCheck: 'partialCheck',\n    rawCheck: 'rawCheck',\n    rawTransform: 'rawTransform',\n    readonly: 'readonly',\n    reduceItems: 'reduceItems',\n    regex: 'regex',\n    returns: 'returns',\n    rfcEmail: 'rfcEmail',\n    safeInteger: 'safeInteger',\n    size: 'size',\n    slug: 'slug',\n    someItem: 'someItem',\n    sortItems: 'sortItems',\n    startsWith: 'startsWith',\n    stringifyJson: 'stringifyJson',\n    title: 'title',\n    toLowerCase: 'toLowerCase',\n    toMaxValue: 'toMaxValue',\n    toMinValue: 'toMinValue',\n    toUpperCase: 'toUpperCase',\n    transform: 'transform',\n    trim: 'trim',\n    trimEnd: 'trimEnd',\n    trimStart: 'trimStart',\n    ulid: 'ulid',\n    url: 'url',\n    uuid: 'uuid',\n    value: 'value',\n    values: 'values',\n    words: 'words',\n  },\n  /**\n   * {@link https://valibot.dev/api/#async Async}\n   */\n  async: {\n    argsAsync: 'argsAsync',\n    arrayAsync: 'arrayAsync',\n    awaitAsync: 'awaitAsync',\n    checkAsync: 'checkAsync',\n    checkItemsAsync: 'checkItemsAsync',\n    customAsync: 'customAsync',\n    exactOptionalAsync: 'exactOptionalAsync',\n    fallbackAsync: 'fallbackAsync',\n    forwardAsync: 'forwardAsync',\n    getDefaultsAsync: 'getDefaultsAsync',\n    getFallbacksAsync: 'getFallbacksAsync',\n    intersectAsync: 'intersectAsync',\n    lazyAsync: 'lazyAsync',\n    looseObjectAsync: 'looseObjectAsync',\n    looseTupleAsync: 'looseTupleAsync',\n    mapAsync: 'mapAsync',\n    nonNullableAsync: 'nonNullableAsync',\n    nonNullishAsync: 'nonNullishAsync',\n    nonOptionalAsync: 'nonOptionalAsync',\n    nullableAsync: 'nullableAsync',\n    nullishAsync: 'nullishAsync',\n    objectAsync: 'objectAsync',\n    objectWithRestAsync: 'objectWithRestAsync',\n    optionalAsync: 'optionalAsync',\n    parseAsync: 'parseAsync',\n    parserAsync: 'parserAsync',\n    partialAsync: 'partialAsync',\n    partialCheckAsync: 'partialCheckAsync',\n    pipeAsync: 'pipeAsync',\n    rawCheckAsync: 'rawCheckAsync',\n    rawTransformAsync: 'rawTransformAsync',\n    recordAsync: 'recordAsync',\n    requiredAsync: 'requiredAsync',\n    returnsAsync: 'returnsAsync',\n    safeParseAsync: 'safeParseAsync',\n    safeParserAsync: 'safeParserAsync',\n    setAsync: 'setAsync',\n    strictObjectAsync: 'strictObjectAsync',\n    strictTupleAsync: 'strictTupleAsync',\n    transformAsync: 'transformAsync',\n    tupleAsync: 'tupleAsync',\n    tupleWithRestAsync: 'tupleWithRestAsync',\n    undefinedableAsync: 'undefinedableAsync',\n    unionAsync: 'unionAsync',\n    variantAsync: 'variantAsync',\n  },\n  /**\n   * {@link https://valibot.dev/api/#methods Methods}\n   */\n  methods: {\n    assert: 'assert',\n    config: 'config',\n    fallback: 'fallback',\n    flatten: 'flatten',\n    forward: 'forward',\n    getDefault: 'getDefault',\n    getDefaults: 'getDefaults',\n    getDescription: 'getDescription',\n    getFallback: 'getFallback',\n    getFallbacks: 'getFallbacks',\n    getMetadata: 'getMetadata',\n    getTitle: 'getTitle',\n    is: 'is',\n    keyof: 'keyof',\n    message: 'message',\n    omit: 'omit',\n    parse: 'parse',\n    parser: 'parser',\n    partial: 'partial',\n    pick: 'pick',\n    pipe: 'pipe',\n    required: 'required',\n    safeParse: 'safeParse',\n    safeParser: 'safeParser',\n    summarize: 'summarize',\n    unwrap: 'unwrap',\n  },\n  /**\n   * {@link https://valibot.dev/api/#schemas Schemas}\n   */\n  schemas: {\n    any: 'any',\n    array: 'array',\n    bigInt: 'bigint',\n    blob: 'blob',\n    boolean: 'boolean',\n    custom: 'custom',\n    date: 'date',\n    enum: 'enum',\n    exactOptional: 'exactOptional',\n    file: 'file',\n    function: 'function',\n    instance: 'instance',\n    intersect: 'intersect',\n    lazy: 'lazy',\n    literal: 'literal',\n    looseObject: 'looseObject',\n    looseTuple: 'looseTuple',\n    map: 'map',\n    nan: 'nan',\n    never: 'never',\n    nonNullable: 'nonNullable',\n    nonNullish: 'nonNullish',\n    nonOptional: 'nonOptional',\n    null: 'null',\n    nullable: 'nullable',\n    nullish: 'nullish',\n    number: 'number',\n    object: 'object',\n    objectWithRest: 'objectWithRest',\n    optional: 'optional',\n    picklist: 'picklist',\n    promise: 'promise',\n    record: 'record',\n    set: 'set',\n    strictObject: 'strictObject',\n    strictTuple: 'strictTuple',\n    string: 'string',\n    symbol: 'symbol',\n    tuple: 'tuple',\n    tupleWithRest: 'tupleWithRest',\n    undefined: 'undefined',\n    undefinedable: 'undefinedable',\n    union: 'union',\n    unknown: 'unknown',\n    variant: 'variant',\n    void: 'void',\n  },\n  /**\n   * {@link https://valibot.dev/api/#storages Storages}\n   */\n  storages: {\n    // TODO: implement if necessary\n  },\n  /**\n   * {@link https://valibot.dev/api/#types Types}\n   */\n  types: {\n    // TODO: implement if necessary\n    GenericSchema: 'GenericSchema',\n  },\n  /**\n   * {@link https://valibot.dev/api/#utils Utils}\n   */\n  utils: {\n    // TODO: implement if necessary\n  },\n};\n","import { $ } from '../../../ts-dsl';\nimport type { ValibotPlugin } from '../types';\nimport { identifiers } from '../v1/constants';\n\nexport type Pipe = ReturnType<typeof $.call | typeof $.expr>;\nexport type Pipes = Array<Pipe>;\nexport type PipeResult = Pipes | Pipe;\n\ntype PushPipes = (target: Pipes, pipes: PipeResult) => Pipes;\ntype PipesToNode = (pipes: PipeResult, plugin: ValibotPlugin['Instance']) => Pipe;\n\nexport const pipesToNode: PipesToNode = (pipes, plugin) => {\n  if (!(pipes instanceof Array)) return pipes;\n  if (pipes.length === 1) return pipes[0]!;\n\n  const v = plugin.external('valibot.v');\n  return $(v)\n    .attr(identifiers.methods.pipe)\n    .call(...pipes);\n};\n\nexport const pushPipes: PushPipes = (target, pipes) => {\n  if (pipes instanceof Array) {\n    target.push(...pipes);\n  } else {\n    target.push(pipes);\n  }\n  return target;\n};\n\nexport interface PipesUtils {\n  /**\n   * Push pipes into target array.\n   */\n  push: PushPipes;\n  /**\n   * Convert pipes to a single node.\n   */\n  toNode: PipesToNode;\n}\n\n/**\n * Functions for working with pipes.\n */\nexport const pipes: PipesUtils = {\n  push: pushPipes,\n  toNode: pipesToNode,\n};\n","import { $ } from '../../../ts-dsl';\nimport type { ValidatorResolverContext } from '../resolvers';\nimport { pipes } from '../shared/pipes';\nimport type { ValidatorArgs } from '../shared/types';\nimport { identifiers } from './constants';\n\nconst validatorResolver = (ctx: ValidatorResolverContext): ReturnType<typeof $.return> => {\n  const { schema, v } = ctx.symbols;\n  return $(v).attr(identifiers.async.parseAsync).call(schema, 'data').await().return();\n};\n\nexport const createRequestValidatorV1 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'valibot',\n  });\n  if (!symbol) return;\n\n  const ctx: ValidatorResolverContext = {\n    $,\n    operation,\n    pipes: {\n      ...pipes,\n      current: [],\n    },\n    plugin,\n    symbols: {\n      schema: symbol,\n      v: plugin.external('valibot.v'),\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver = typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorV1 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'valibot',\n  });\n  if (!symbol) return;\n\n  const ctx: ValidatorResolverContext = {\n    $,\n    operation,\n    pipes: {\n      ...pipes,\n      current: [],\n    },\n    plugin,\n    symbols: {\n      schema: symbol,\n      v: plugin.external('valibot.v'),\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver = typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import type { $ } from '../../ts-dsl';\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV1, createResponseValidatorV1 } from './v1/api';\n\nexport type IApi = {\n  createRequestValidator: (args: ValidatorArgs) => ReturnType<typeof $.func> | undefined;\n  createResponseValidator: (args: ValidatorArgs) => ReturnType<typeof $.func> | undefined;\n};\n\nexport class Api implements IApi {\n  createRequestValidator(args: ValidatorArgs): ReturnType<typeof $.func> | undefined {\n    return createRequestValidatorV1(args);\n  }\n\n  createResponseValidator(args: ValidatorArgs): ReturnType<typeof $.func> | undefined {\n    return createResponseValidatorV1(args);\n  }\n}\n","import { $ } from '../../../ts-dsl';\n\nexport type MaybeBigInt = (\n  value: unknown,\n  format: string | undefined,\n) => ReturnType<typeof $.fromValue>;\nexport type ShouldCoerceToBigInt = (format: string | undefined) => boolean;\n\nexport const shouldCoerceToBigInt: ShouldCoerceToBigInt = (format) =>\n  format === 'int64' || format === 'uint64';\n\nexport const maybeBigInt: MaybeBigInt = (value, format) => {\n  if (!shouldCoerceToBigInt(format)) {\n    return $.fromValue(value);\n  }\n\n  if (typeof value === 'string') {\n    // handle invalid input\n    if (value.endsWith('n')) value = value.slice(0, -1);\n    return $('BigInt').call($.fromValue(value));\n  }\n\n  if (typeof value === 'number') {\n    return $('BigInt').call($.fromValue(value));\n  }\n\n  return $.fromValue(value);\n};\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\n\nimport { createSchemaComment } from '../../../plugins/shared/utils/schema';\nimport { $ } from '../../../ts-dsl';\nimport { identifiers } from '../v1/constants';\nimport { pipesToNode } from './pipes';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport function exportAst({\n  ast,\n  plugin,\n  schema,\n  state,\n  symbol,\n}: IrSchemaToAstOptions & {\n  ast: Ast;\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n}): void {\n  const v = plugin.external('valibot.v');\n  const statement = $.const(symbol)\n    .export()\n    .$if(plugin.config.comments && createSchemaComment(schema), (c, v) => c.doc(v))\n    .$if(state.hasLazyExpression['~ref'], (c) =>\n      c.type($.type(v).attr(ast.typeName || identifiers.types.GenericSchema)),\n    )\n    .assign(pipesToNode(ast.pipes, plugin));\n  plugin.node(statement);\n}\n","import { fromRef } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming, operationResponsesMap } from '@hey-api/shared';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irOperationToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (schema: IR.SchemaObject, path: ReadonlyArray<string | number>) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.requests.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, fromRef(state.path));\n    const symbol = plugin.symbol(applyNaming(operation.id, plugin.config.requests), {\n      meta: {\n        category: 'schema',\n        path: fromRef(state.path),\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'data',\n        tags: fromRef(state.tags),\n        tool: 'valibot',\n      },\n    });\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      state,\n      symbol,\n    });\n  }\n\n  if (plugin.config.responses.enabled) {\n    if (operation.responses) {\n      const { response } = operationResponsesMap(operation);\n\n      if (response) {\n        const path = [...fromRef(state.path), 'responses'];\n        const ast = getAst(response, path);\n        const symbol = plugin.symbol(applyNaming(operation.id, plugin.config.responses), {\n          meta: {\n            category: 'schema',\n            path,\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'responses',\n            tags: fromRef(state.tags),\n            tool: 'valibot',\n          },\n        });\n        exportAst({\n          ast,\n          plugin,\n          schema: response,\n          state,\n          symbol,\n        });\n      }\n    }\n  }\n};\n","import { fromRef } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming } from '@hey-api/shared';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irWebhookToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (schema: IR.SchemaObject, path: ReadonlyArray<string | number>) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.webhooks.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, fromRef(state.path));\n    const symbol = plugin.symbol(applyNaming(operation.id, plugin.config.webhooks), {\n      meta: {\n        category: 'schema',\n        path: fromRef(state.path),\n        resource: 'webhook',\n        resourceId: operation.id,\n        role: 'data',\n        tags: fromRef(state.tags),\n        tool: 'valibot',\n      },\n    });\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      state,\n      symbol,\n    });\n  }\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}) => {\n  const v = plugin.external('valibot.v');\n  const expression = $(v).attr(identifiers.schemas.unknown).call();\n  return expression;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\nimport { deduplicateSchema } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { pipesToNode } from '../../shared/pipes';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Omit<Ast, 'typeName'> = {\n    pipes: [],\n  };\n\n  const v = plugin.external('valibot.v');\n  const functionName = $(v).attr(identifiers.schemas.array);\n\n  if (!schema.items) {\n    const expression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }),\n    );\n    result.pipes.push(expression);\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return pipesToNode(itemAst.pipes, plugin);\n    });\n\n    if (itemExpressions.length === 1) {\n      const expression = functionName.call(...itemExpressions);\n      result.pipes.push(expression);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        // TODO: parser - handle intersection\n        // return tsc.typeArrayNode(\n        //   tsc.typeIntersectionNode({ types: itemExpressions }),\n        // );\n      }\n\n      // TODO: parser - handle union\n      // return tsc.typeArrayNode(tsc.typeUnionNode({ types: itemExpressions }));\n\n      const expression = functionName.call(\n        unknownToAst({\n          plugin,\n          schema: {\n            type: 'unknown',\n          },\n          state,\n        }),\n      );\n      result.pipes.push(expression);\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    const expression = $(v).attr(identifiers.actions.length).call($.fromValue(schema.minItems));\n    result.pipes.push(expression);\n  } else {\n    if (schema.minItems !== undefined) {\n      const expression = $(v)\n        .attr(identifiers.actions.minLength)\n        .call($.fromValue(schema.minItems));\n      result.pipes.push(expression);\n    }\n\n    if (schema.maxItems !== undefined) {\n      const expression = $(v)\n        .attr(identifiers.actions.maxLength)\n        .call($.fromValue(schema.maxItems));\n      result.pipes.push(expression);\n    }\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { pipesToNode } from '../../shared/pipes';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport function booleanToAst({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): ReturnType<typeof $.call | typeof $.expr> {\n  const pipes: Array<ReturnType<typeof $.call>> = [];\n\n  const v = plugin.external('valibot.v');\n\n  if (typeof schema.const === 'boolean') {\n    pipes.push($(v).attr(identifiers.schemas.literal).call($.literal(schema.const)));\n    return pipesToNode(pipes, plugin);\n  }\n\n  pipes.push($(v).attr(identifiers.schemas.boolean).call());\n  return pipesToNode(pipes, plugin);\n}\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport type { EnumResolverContext } from '../../resolvers';\nimport type { Pipe, PipeResult } from '../../shared/pipes';\nimport { pipes } from '../../shared/pipes';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { unknownToAst } from './unknown';\n\nfunction itemsNode(ctx: EnumResolverContext): ReturnType<EnumResolverContext['nodes']['items']> {\n  const { schema } = ctx;\n\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n\n  let isNullable = false;\n\n  for (const item of schema.items ?? []) {\n    if (item.type === 'string' && typeof item.const === 'string') {\n      enumMembers.push($.literal(item.const));\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  return {\n    enumMembers,\n    isNullable,\n  };\n}\n\nfunction baseNode(ctx: EnumResolverContext): PipeResult {\n  const { symbols } = ctx;\n  const { v } = symbols;\n  const { enumMembers } = ctx.nodes.items(ctx);\n  return $(v)\n    .attr(identifiers.schemas.picklist)\n    .call($.array(...enumMembers));\n}\n\nfunction nullableNode(ctx: EnumResolverContext): PipeResult | undefined {\n  const { symbols } = ctx;\n  const { v } = symbols;\n  const { isNullable } = ctx.nodes.items(ctx);\n  if (!isNullable) return;\n  const currentNode = ctx.pipes.toNode(ctx.pipes.current, ctx.plugin);\n  return $(v).attr(identifiers.schemas.nullable).call(currentNode);\n}\n\nfunction enumResolver(ctx: EnumResolverContext): PipeResult {\n  const { enumMembers } = ctx.nodes.items(ctx);\n\n  if (!enumMembers.length) {\n    return ctx.pipes.current;\n  }\n\n  const baseExpression = ctx.nodes.base(ctx);\n  ctx.pipes.push(ctx.pipes.current, baseExpression);\n\n  const nullableExpression = ctx.nodes.nullable(ctx);\n  if (nullableExpression) {\n    return nullableExpression;\n  }\n\n  return ctx.pipes.current;\n}\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): Pipe => {\n  const v = plugin.external('valibot.v');\n\n  const { enumMembers } = itemsNode({\n    $,\n    nodes: { base: baseNode, items: itemsNode, nullable: nullableNode },\n    pipes: { ...pipes, current: [] },\n    plugin,\n    schema,\n    symbols: { v },\n    utils: { state },\n  });\n\n  if (!enumMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  const ctx: EnumResolverContext = {\n    $,\n    nodes: {\n      base: baseNode,\n      items: itemsNode,\n      nullable: nullableNode,\n    },\n    pipes: {\n      ...pipes,\n      current: [],\n    },\n    plugin,\n    schema,\n    symbols: {\n      v,\n    },\n    utils: {\n      state,\n    },\n  };\n\n  const resolver = plugin.config['~resolvers']?.enum;\n  const node = resolver?.(ctx) ?? enumResolver(ctx);\n  return ctx.pipes.toNode(node, plugin);\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}) => {\n  const v = plugin.external('valibot.v');\n  const expression = $(v).attr(identifiers.schemas.never).call();\n  return expression;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}) => {\n  const v = plugin.external('valibot.v');\n  const expression = $(v).attr(identifiers.schemas.null).call();\n  return expression;\n};\n","type Range = number | string;\n\ninterface IntegerLimit {\n  maxError: string;\n  maxValue: Range;\n  minError: string;\n  minValue: Range;\n}\n\nexport type GetIntegerLimit = (format: string | undefined) => IntegerLimit | undefined;\n\nconst rangeErrors = (format: string, range: [Range, Range]) => ({\n  maxError: `Invalid value: Expected ${format} to be <= ${range[1]}`,\n  minError: `Invalid value: Expected ${format} to be >= ${range[0]}`,\n});\n\nconst integerRange: Record<string, [Range, Range]> = {\n  int16: [-32768, 32767],\n  int32: [-2147483648, 2147483647],\n  int64: ['-9223372036854775808', '9223372036854775807'],\n  int8: [-128, 127],\n  uint16: [0, 65535],\n  uint32: [0, 4294967295],\n  uint64: ['0', '18446744073709551615'],\n  uint8: [0, 255],\n};\n\nexport const getIntegerLimit: GetIntegerLimit = (format) => {\n  if (!format) return;\n  const range = integerRange[format];\n  if (!range) return;\n  const errors = rangeErrors(format, range);\n  return { maxValue: range[1], minValue: range[0], ...errors };\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { maybeBigInt, shouldCoerceToBigInt } from '../../../../plugins/shared/utils/coerce';\nimport { getIntegerLimit } from '../../../../plugins/shared/utils/formats';\nimport { $ } from '../../../../ts-dsl';\nimport type { NumberResolverContext } from '../../resolvers';\nimport type { Pipe, PipeResult, Pipes } from '../../shared/pipes';\nimport { pipes } from '../../shared/pipes';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nfunction baseNode(ctx: NumberResolverContext): PipeResult {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (ctx.utils.shouldCoerceToBigInt(schema.format)) {\n    return [\n      $(v)\n        .attr(identifiers.schemas.union)\n        .call(\n          $.array(\n            $(v).attr(identifiers.schemas.number).call(),\n            $(v).attr(identifiers.schemas.string).call(),\n            $(v).attr(identifiers.schemas.bigInt).call(),\n          ),\n        ),\n      $(v)\n        .attr(identifiers.actions.transform)\n        .call($.func().param('x').do($('BigInt').call('x').return())),\n    ];\n  }\n  const pipes: Pipes = [];\n  pipes.push($(v).attr(identifiers.schemas.number).call());\n  if (schema.type === 'integer') {\n    pipes.push($(v).attr(identifiers.actions.integer).call());\n  }\n  return pipes;\n}\n\nfunction constNode(ctx: NumberResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.const === undefined) return;\n  return $(v)\n    .attr(identifiers.schemas.literal)\n    .call(ctx.utils.maybeBigInt(schema.const, schema.format));\n}\n\nfunction maxNode(ctx: NumberResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.exclusiveMaximum !== undefined) {\n    return $(v)\n      .attr(identifiers.actions.ltValue)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));\n  }\n  if (schema.maximum !== undefined) {\n    return $(v)\n      .attr(identifiers.actions.maxValue)\n      .call(ctx.utils.maybeBigInt(schema.maximum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return $(v)\n      .attr(identifiers.actions.maxValue)\n      .call(ctx.utils.maybeBigInt(limit.maxValue, schema.format), $.literal(limit.maxError));\n  }\n  return;\n}\n\nfunction minNode(ctx: NumberResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.exclusiveMinimum !== undefined) {\n    return $(v)\n      .attr(identifiers.actions.gtValue)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));\n  }\n  if (schema.minimum !== undefined) {\n    return $(v)\n      .attr(identifiers.actions.minValue)\n      .call(ctx.utils.maybeBigInt(schema.minimum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return $(v)\n      .attr(identifiers.actions.minValue)\n      .call(ctx.utils.maybeBigInt(limit.minValue, schema.format), $.literal(limit.minError));\n  }\n  return;\n}\n\nfunction numberResolver(ctx: NumberResolverContext): Pipes {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) return ctx.pipes.push(ctx.pipes.current, constNode);\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.pipes.push(ctx.pipes.current, baseNode);\n\n  const minNode = ctx.nodes.min(ctx);\n  if (minNode) ctx.pipes.push(ctx.pipes.current, minNode);\n\n  const maxNode = ctx.nodes.max(ctx);\n  if (maxNode) ctx.pipes.push(ctx.pipes.current, maxNode);\n\n  return ctx.pipes.current;\n}\n\nexport const numberToNode = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Pipe => {\n  const ctx: NumberResolverContext = {\n    $,\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      max: maxNode,\n      min: minNode,\n    },\n    pipes: {\n      ...pipes,\n      current: [],\n    },\n    plugin,\n    schema,\n    symbols: {\n      v: plugin.external('valibot.v'),\n    },\n    utils: {\n      getIntegerLimit,\n      maybeBigInt,\n      shouldCoerceToBigInt,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.number;\n  const node = resolver?.(ctx) ?? numberResolver(ctx);\n  return ctx.pipes.toNode(node, plugin);\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport type { ObjectResolverContext } from '../../resolvers';\nimport type { Pipe, PipeResult } from '../../shared/pipes';\nimport { pipes } from '../../shared/pipes';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\n\nfunction additionalPropertiesNode(ctx: ObjectResolverContext): Pipe | null | undefined {\n  const { plugin, schema } = ctx;\n\n  if (!schema.additionalProperties || !schema.additionalProperties.type) return;\n  if (schema.additionalProperties.type === 'never') return null;\n\n  const additionalAst = irSchemaToAst({\n    plugin,\n    schema: schema.additionalProperties,\n    state: {\n      ...ctx.utils.state,\n      path: ref([...fromRef(ctx.utils.state.path), 'additionalProperties']),\n    },\n  });\n  if (additionalAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n  return pipes.toNode(additionalAst.pipes, plugin);\n}\n\nfunction baseNode(ctx: ObjectResolverContext): PipeResult {\n  const { nodes, symbols } = ctx;\n  const { v } = symbols;\n\n  const additional = nodes.additionalProperties(ctx);\n  const shape = nodes.shape(ctx);\n\n  if (additional === null) {\n    return $(v).attr(identifiers.schemas.strictObject).call(shape);\n  }\n\n  if (additional) {\n    if (shape.isEmpty) {\n      return $(v)\n        .attr(identifiers.schemas.record)\n        .call($(v).attr(identifiers.schemas.string).call(), additional);\n    }\n\n    return $(v).attr(identifiers.schemas.objectWithRest).call(shape, additional);\n  }\n\n  return $(v).attr(identifiers.schemas.object).call(shape);\n}\n\nfunction objectResolver(ctx: ObjectResolverContext): PipeResult {\n  // TODO: parser - handle constants\n  return ctx.nodes.base(ctx);\n}\n\nfunction shapeNode(ctx: ObjectResolverContext): ReturnType<typeof $.object> {\n  const { plugin, schema } = ctx;\n  const shape = $.object().pretty();\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n\n    const propertyAst = irSchemaToAst({\n      optional: !schema.required?.includes(name),\n      plugin,\n      schema: property,\n      state: {\n        ...ctx.utils.state,\n        path: ref([...fromRef(ctx.utils.state.path), 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n    shape.prop(name, pipes.toNode(propertyAst.pipes, plugin));\n  }\n\n  return shape;\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const ctx: ObjectResolverContext = {\n    $,\n    nodes: {\n      additionalProperties: additionalPropertiesNode,\n      base: baseNode,\n      shape: shapeNode,\n    },\n    pipes: {\n      ...pipes,\n      current: [],\n    },\n    plugin,\n    schema,\n    symbols: {\n      v: plugin.external('valibot.v'),\n    },\n    utils: {\n      ast: {},\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.object;\n  const node = resolver?.(ctx) ?? objectResolver(ctx);\n  ctx.utils.ast.pipes = [ctx.pipes.toNode(node, plugin)];\n  return ctx.utils.ast as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport type { StringResolverContext } from '../../resolvers';\nimport type { Pipe, PipeResult, Pipes } from '../../shared/pipes';\nimport { pipes } from '../../shared/pipes';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nfunction baseNode(ctx: StringResolverContext): PipeResult {\n  const { v } = ctx.symbols;\n  return $(v).attr(identifiers.schemas.string).call();\n}\n\nfunction constNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (typeof schema.const !== 'string') return;\n  return $(v).attr(identifiers.schemas.literal).call($.literal(schema.const));\n}\n\nfunction formatNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  switch (schema.format) {\n    case 'date':\n      return $(v).attr(identifiers.actions.isoDate).call();\n    case 'date-time':\n      return $(v).attr(identifiers.actions.isoTimestamp).call();\n    case 'email':\n      return $(v).attr(identifiers.actions.email).call();\n    case 'ipv4':\n    case 'ipv6':\n      return $(v).attr(identifiers.actions.ip).call();\n    case 'time':\n      return $(v).attr(identifiers.actions.isoTimeSecond).call();\n    case 'uri':\n      return $(v).attr(identifiers.actions.url).call();\n    case 'uuid':\n      return $(v).attr(identifiers.actions.uuid).call();\n  }\n\n  return;\n}\n\nfunction lengthNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.minLength === undefined || schema.minLength !== schema.maxLength) return;\n  return $(v).attr(identifiers.actions.length).call($.literal(schema.minLength));\n}\n\nfunction maxLengthNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.maxLength === undefined) return;\n  return $(v).attr(identifiers.actions.maxLength).call($.literal(schema.maxLength));\n}\n\nfunction minLengthNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (schema.minLength === undefined) return;\n  return $(v).attr(identifiers.actions.minLength).call($.literal(schema.minLength));\n}\n\nfunction patternNode(ctx: StringResolverContext): PipeResult | undefined {\n  const { schema, symbols } = ctx;\n  const { v } = symbols;\n  if (!schema.pattern) return;\n  return $(v).attr(identifiers.actions.regex).call($.regexp(schema.pattern));\n}\n\nfunction stringResolver(ctx: StringResolverContext): Pipes {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) return ctx.pipes.push(ctx.pipes.current, constNode);\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.pipes.push(ctx.pipes.current, baseNode);\n\n  const formatNode = ctx.nodes.format(ctx);\n  if (formatNode) ctx.pipes.push(ctx.pipes.current, formatNode);\n\n  const lengthNode = ctx.nodes.length(ctx);\n  if (lengthNode) {\n    ctx.pipes.push(ctx.pipes.current, lengthNode);\n  } else {\n    const minLengthNode = ctx.nodes.minLength(ctx);\n    if (minLengthNode) ctx.pipes.push(ctx.pipes.current, minLengthNode);\n\n    const maxLengthNode = ctx.nodes.maxLength(ctx);\n    if (maxLengthNode) ctx.pipes.push(ctx.pipes.current, maxLengthNode);\n  }\n\n  const patternNode = ctx.nodes.pattern(ctx);\n  if (patternNode) ctx.pipes.push(ctx.pipes.current, patternNode);\n\n  return ctx.pipes.current;\n}\n\nexport const stringToNode = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Pipe => {\n  const ctx: StringResolverContext = {\n    $,\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      format: formatNode,\n      length: lengthNode,\n      maxLength: maxLengthNode,\n      minLength: minLengthNode,\n      pattern: patternNode,\n    },\n    pipes: {\n      ...pipes,\n      current: [],\n    },\n    plugin,\n    schema,\n    symbols: {\n      v: plugin.external('valibot.v'),\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.string;\n  const node = resolver?.(ctx) ?? stringResolver(ctx);\n  return ctx.pipes.toNode(node, plugin);\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { pipesToNode } from '../../shared/pipes';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const v = plugin.external('valibot.v');\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(v).attr(identifiers.schemas.literal).call($.fromValue(value)),\n    );\n    result.pipes = [\n      $(v)\n        .attr(identifiers.schemas.tuple)\n        .call($.array(...tupleElements)),\n    ];\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  if (schema.items) {\n    const tupleElements = schema.items.map((item, index) => {\n      const schemaPipes = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      if (schemaPipes.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return pipesToNode(schemaPipes.pipes, plugin);\n    });\n    result.pipes = [\n      $(v)\n        .attr(identifiers.schemas.tuple)\n        .call($.array(...tupleElements)),\n    ];\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  return {\n    pipes: [\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }),\n    ],\n  };\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}) => {\n  const v = plugin.external('valibot.v');\n  const expression = $(v).attr(identifiers.schemas.undefined).call();\n  return expression;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { identifiers } from '../constants';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}) => {\n  const v = plugin.external('valibot.v');\n  const expression = $(v).attr(identifiers.schemas.void).call();\n  return expression;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { shouldCoerceToBigInt } from '../../../../plugins/shared/utils/coerce';\nimport type { $ } from '../../../../ts-dsl';\nimport { pipesToNode } from '../../shared/pipes';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToNode } from './number';\nimport { objectToAst } from './object';\nimport { stringToNode } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport function irSchemaWithTypeToAst({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): {\n  anyType?: string;\n  expression: ReturnType<typeof $.call | typeof $.expr>;\n} {\n  switch (schema.type) {\n    case 'array':\n      return {\n        expression: pipesToNode(\n          arrayToAst({\n            ...args,\n            schema: schema as SchemaWithType<'array'>,\n          }).pipes,\n          args.plugin,\n        ),\n      };\n    case 'boolean':\n      return {\n        expression: booleanToAst({\n          ...args,\n          schema: schema as SchemaWithType<'boolean'>,\n        }),\n      };\n    case 'enum':\n      return {\n        expression: enumToAst({\n          ...args,\n          schema: schema as SchemaWithType<'enum'>,\n        }),\n      };\n    case 'integer':\n    case 'number':\n      return {\n        expression: numberToNode({\n          ...args,\n          schema: schema as SchemaWithType<'integer' | 'number'>,\n        }),\n      };\n    case 'never':\n      return {\n        expression: neverToAst({\n          ...args,\n          schema: schema as SchemaWithType<'never'>,\n        }),\n      };\n    case 'null':\n      return {\n        expression: nullToAst({\n          ...args,\n          schema: schema as SchemaWithType<'null'>,\n        }),\n      };\n    case 'object':\n      return {\n        expression: pipesToNode(\n          objectToAst({\n            ...args,\n            schema: schema as SchemaWithType<'object'>,\n          }).pipes,\n          args.plugin,\n        ),\n      };\n    case 'string':\n      return {\n        expression: shouldCoerceToBigInt(schema.format)\n          ? numberToNode({\n              ...args,\n              schema: { ...schema, type: 'number' },\n            })\n          : stringToNode({\n              ...args,\n              schema: schema as SchemaWithType<'string'>,\n            }),\n      };\n    case 'tuple':\n      return {\n        expression: pipesToNode(\n          tupleToAst({\n            ...args,\n            schema: schema as SchemaWithType<'tuple'>,\n          }).pipes,\n          args.plugin,\n        ),\n      };\n    case 'undefined':\n      return {\n        expression: undefinedToAst({\n          ...args,\n          schema: schema as SchemaWithType<'undefined'>,\n        }),\n      };\n    case 'unknown':\n      return {\n        expression: unknownToAst({\n          ...args,\n          schema: schema as SchemaWithType<'unknown'>,\n        }),\n      };\n    case 'void':\n      return {\n        expression: voidToAst({\n          ...args,\n          schema: schema as SchemaWithType<'void'>,\n        }),\n      };\n  }\n}\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { fromRef, ref, refs } from '@hey-api/codegen-core';\nimport type { IR, SchemaExtractor, SchemaWithType } from '@hey-api/shared';\nimport {\n  applyNaming,\n  deduplicateSchema,\n  inlineSchema,\n  pathToJsonPointer,\n  refToName,\n} from '@hey-api/shared';\n\nimport { maybeBigInt } from '../../../plugins/shared/utils/coerce';\nimport { $ } from '../../../ts-dsl';\nimport { exportAst } from '../shared/export';\nimport { irOperationToAst } from '../shared/operation';\nimport { pipesToNode } from '../shared/pipes';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ValibotPlugin } from '../types';\nimport { identifiers } from './constants';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport function irSchemaToAst({\n  optional,\n  plugin,\n  schema,\n  schemaExtractor = inlineSchema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n  schemaExtractor?: SchemaExtractor;\n}): Ast {\n  if (!schema.$ref) {\n    const resolved = schemaExtractor({ path: fromRef(state.path), schema });\n    if (resolved !== schema) {\n      schema = resolved;\n    }\n  }\n\n  const ast: Ast = {\n    pipes: [],\n  };\n\n  const v = plugin.external('valibot.v');\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'valibot',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      const ref = $(refSymbol);\n      ast.pipes.push(ref);\n    } else {\n      const lazyExpression = $(v)\n        .attr(identifiers.schemas.lazy)\n        .call($.func().do($(refSymbol).return()));\n      ast.pipes.push(lazyExpression);\n      state.hasLazyExpression['~ref'] = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.typeName = typeAst.anyType;\n    ast.pipes.push(typeAst.expression);\n\n    if (plugin.config.metadata && schema.description) {\n      const expression = $(v)\n        .attr(identifiers.actions.metadata)\n        .call($.object().prop('description', $.literal(schema.description)));\n      ast.pipes.push(expression);\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemsAst = schema.items.map((item, index) => {\n        const itemAst = irSchemaToAst({\n          plugin,\n          schema: item,\n          schemaExtractor,\n          state: {\n            ...state,\n            path: ref([...fromRef(state.path), 'items', index]),\n          },\n        });\n        return pipesToNode(itemAst.pipes, plugin);\n      });\n\n      if (schema.logicalOperator === 'and') {\n        const intersectExpression = $(v)\n          .attr(identifiers.schemas.intersect)\n          .call($.array(...itemsAst));\n        ast.pipes.push(intersectExpression);\n      } else {\n        const unionExpression = $(v)\n          .attr(identifiers.schemas.union)\n          .call($.array(...itemsAst));\n        ast.pipes.push(unionExpression);\n      }\n    } else {\n      const schemaPipes = irSchemaToAst({ plugin, schema, state });\n      ast.pipes.push(...schemaPipes.pipes);\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.typeName = typeAst.anyType;\n    ast.pipes.push(typeAst.expression);\n  }\n\n  if (ast.pipes.length) {\n    if (schema.accessScope === 'read') {\n      const readonlyExpression = $(v).attr(identifiers.actions.readonly).call();\n      ast.pipes.push(readonlyExpression);\n    }\n\n    if (schema.default !== undefined) {\n      ast.pipes = [\n        $(v)\n          .attr(identifiers.schemas.optional)\n          .call(\n            pipesToNode(ast.pipes, plugin),\n            schema.type === 'integer' || schema.type === 'number'\n              ? maybeBigInt(schema.default, schema.format)\n              : $.fromValue(schema.default),\n          ),\n      ];\n    } else if (optional) {\n      ast.pipes = [$(v).attr(identifiers.schemas.optional).call(pipesToNode(ast.pipes, plugin))];\n    }\n  }\n\n  return ast as Ast;\n}\n\nfunction handleComponent({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.symbol(applyNaming(baseName, plugin.config.definitions), {\n    meta: {\n      category: 'schema',\n      path: fromRef(state.path),\n      resource: 'definition',\n      resourceId: $ref,\n      tags: fromRef(state.tags),\n      tool: 'valibot',\n    },\n  });\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    state,\n    symbol,\n  });\n}\n\nexport const handlerV1: ValibotPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('v', {\n    external: 'valibot',\n    importKind: 'namespace',\n    meta: {\n      category: 'external',\n      resource: 'valibot.v',\n    },\n  });\n\n  plugin.forEach('operation', 'parameter', 'requestBody', 'schema', 'webhook', (event) => {\n    const state = refs<PluginState>({\n      hasLazyExpression: false,\n      path: event._path,\n      tags: event.tags,\n    });\n    switch (event.type) {\n      case 'operation':\n        irOperationToAst({\n          getAst: (schema, path) => {\n            const state = refs<PluginState>({\n              hasLazyExpression: false,\n              path,\n              tags: event.tags,\n            });\n            return irSchemaToAst({ plugin, schema, state });\n          },\n          operation: event.operation,\n          plugin,\n          state,\n        });\n        break;\n      case 'parameter':\n        handleComponent({\n          plugin,\n          schema: event.parameter.schema,\n          state,\n        });\n        break;\n      case 'requestBody':\n        handleComponent({\n          plugin,\n          schema: event.requestBody.schema,\n          state,\n        });\n        break;\n      case 'schema':\n        handleComponent({\n          plugin,\n          schema: event.schema,\n          state,\n        });\n        break;\n      case 'webhook':\n        irWebhookToAst({\n          getAst: (schema, path) => {\n            const state = refs<PluginState>({\n              hasLazyExpression: false,\n              path,\n              tags: event.tags,\n            });\n            return irSchemaToAst({ plugin, schema, state });\n          },\n          operation: event.operation,\n          plugin,\n          state,\n        });\n        break;\n    }\n  });\n};\n","import type { ValibotPlugin } from './types';\nimport { handlerV1 } from './v1/plugin';\n\nexport const handler: ValibotPlugin['Handler'] = (args) => handlerV1(args);\n","import { definePluginConfig, mappers } from '@hey-api/shared';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ValibotPlugin } from './types';\n\nexport const defaultConfig: ValibotPlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    includeInEntry: false,\n    metadata: false,\n  },\n  handler,\n  name: 'valibot',\n  resolveConfig: (plugin, context) => {\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}',\n      },\n      mappers,\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}Data',\n      },\n      mappers,\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}Response',\n      },\n      mappers,\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'v{{name}}WebhookRequest',\n      },\n      mappers,\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Valibot plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","// TODO: this is inaccurate, it combines identifiers for all supported versions\nexport const identifiers = {\n  ZodMiniOptional: 'ZodMiniOptional',\n  ZodOptional: 'ZodOptional',\n  _default: '_default',\n  and: 'and',\n  array: 'array',\n  bigint: 'bigint',\n  boolean: 'boolean',\n  check: 'check',\n  coerce: 'coerce',\n  date: 'date',\n  datetime: 'datetime',\n  default: 'default',\n  describe: 'describe',\n  email: 'email',\n  enum: 'enum',\n  globalRegistry: 'globalRegistry',\n  gt: 'gt',\n  gte: 'gte',\n  infer: 'infer',\n  int: 'int',\n  intersection: 'intersection',\n  ip: 'ip',\n  ipv4: 'ipv4',\n  ipv6: 'ipv6',\n  iso: 'iso',\n  lazy: 'lazy',\n  length: 'length',\n  literal: 'literal',\n  lt: 'lt',\n  lte: 'lte',\n  max: 'max',\n  maxLength: 'maxLength',\n  maximum: 'maximum', // Zod Mini\n  min: 'min',\n  minLength: 'minLength',\n  minimum: 'minimum', // Zod Mini\n  never: 'never',\n  null: 'null',\n  nullable: 'nullable',\n  number: 'number',\n  object: 'object',\n  optional: 'optional',\n  parseAsync: 'parseAsync',\n  readonly: 'readonly',\n  record: 'record',\n  regex: 'regex',\n  register: 'register',\n  string: 'string',\n  time: 'time',\n  tuple: 'tuple',\n  undefined: 'undefined',\n  union: 'union',\n  unknown: 'unknown',\n  url: 'url',\n  uuid: 'uuid',\n  void: 'void',\n};\n","import { $ } from '../../../ts-dsl';\nimport { identifiers } from '../constants';\nimport type { ValidatorResolverContext } from '../resolvers';\nimport type { ValidatorArgs } from '../shared/types';\n\nconst validatorResolver = (ctx: ValidatorResolverContext): ReturnType<typeof $.return> => {\n  const { schema } = ctx.symbols;\n  return $(schema).attr(identifiers.parseAsync).call('data').await().return();\n};\n\nexport const createRequestValidatorMini = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver = typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorMini = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver = typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import { $ } from '../../../ts-dsl';\nimport { identifiers } from '../constants';\nimport type { ValidatorResolverContext } from '../resolvers';\nimport type { ValidatorArgs } from '../shared/types';\n\nconst validatorResolver = (ctx: ValidatorResolverContext): ReturnType<typeof $.return> => {\n  const { schema } = ctx.symbols;\n  return $(schema).attr(identifiers.parseAsync).call('data').await().return();\n};\n\nexport const createRequestValidatorV3 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver = typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorV3 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver = typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import { $ } from '../../../ts-dsl';\nimport { identifiers } from '../constants';\nimport type { ValidatorResolverContext } from '../resolvers';\nimport type { ValidatorArgs } from '../shared/types';\n\nconst validatorResolver = (ctx: ValidatorResolverContext): ReturnType<typeof $.return> => {\n  const { schema } = ctx.symbols;\n  return $(schema).attr(identifiers.parseAsync).call('data').await().return();\n};\n\nexport const createRequestValidatorV4 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'data',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver = typeof validator === 'function' ? validator : validator?.request;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n\nexport const createResponseValidatorV4 = ({\n  operation,\n  plugin,\n}: ValidatorArgs): ReturnType<typeof $.func> | undefined => {\n  const symbol = plugin.getSymbol({\n    category: 'schema',\n    resource: 'operation',\n    resourceId: operation.id,\n    role: 'responses',\n    tool: 'zod',\n  });\n  if (!symbol) return;\n\n  const z = plugin.external('zod.z');\n  const ctx: ValidatorResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    operation,\n    plugin,\n    symbols: {\n      schema: symbol,\n      z,\n    },\n  };\n  const validator = plugin.config['~resolvers']?.validator;\n  const resolver = typeof validator === 'function' ? validator : validator?.response;\n  const candidates = [resolver, validatorResolver];\n  for (const candidate of candidates) {\n    const statements = candidate?.(ctx);\n    if (statements === null) return;\n    if (statements !== undefined) {\n      return $.func()\n        .async()\n        .param('data')\n        .do(...(statements instanceof Array ? statements : [statements]));\n    }\n  }\n  return;\n};\n","import type { $ } from '../../ts-dsl';\nimport { createRequestValidatorMini, createResponseValidatorMini } from './mini/api';\nimport type { ValidatorArgs } from './shared/types';\nimport { createRequestValidatorV3, createResponseValidatorV3 } from './v3/api';\nimport { createRequestValidatorV4, createResponseValidatorV4 } from './v4/api';\n\nexport type IApi = {\n  createRequestValidator: (args: ValidatorArgs) => ReturnType<typeof $.func> | undefined;\n  createResponseValidator: (args: ValidatorArgs) => ReturnType<typeof $.func> | undefined;\n};\n\nexport class Api implements IApi {\n  createRequestValidator(args: ValidatorArgs): ReturnType<typeof $.func> | undefined {\n    const { plugin } = args;\n    switch (plugin.config.compatibilityVersion) {\n      case 3:\n        return createRequestValidatorV3(args);\n      case 'mini':\n        return createRequestValidatorMini(args);\n      case 4:\n      default:\n        return createRequestValidatorV4(args);\n    }\n  }\n\n  createResponseValidator(args: ValidatorArgs): ReturnType<typeof $.func> | undefined {\n    const { plugin } = args;\n    switch (plugin.config.compatibilityVersion) {\n      case 3:\n        return createResponseValidatorV3(args);\n      case 'mini':\n        return createResponseValidatorMini(args);\n      case 4:\n      default:\n        return createResponseValidatorV4(args);\n    }\n  }\n}\n","import type { Symbol } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\n\nimport { createSchemaComment } from '../../../plugins/shared/utils/schema';\nimport { $ } from '../../../ts-dsl';\nimport { identifiers } from '../constants';\nimport type { ZodPlugin } from '../types';\nimport type { Ast } from './types';\n\nexport function exportAst({\n  ast,\n  plugin,\n  schema,\n  symbol,\n  typeInferSymbol,\n}: {\n  ast: Ast;\n  plugin: ZodPlugin['Instance'];\n  schema: IR.SchemaObject;\n  symbol: Symbol;\n  typeInferSymbol: Symbol | undefined;\n}): void {\n  const z = plugin.external('zod.z');\n\n  const statement = $.const(symbol)\n    .export()\n    .$if(plugin.config.comments && createSchemaComment(schema), (c, v) => c.doc(v))\n    .$if(ast.typeName, (c, v) => c.type($.type(z).attr(v)))\n    .assign(ast.expression);\n  plugin.node(statement);\n\n  if (typeInferSymbol) {\n    const inferType = $.type\n      .alias(typeInferSymbol)\n      .export()\n      .type($.type(z).attr(identifiers.infer).generic($(symbol).typeofType()));\n    plugin.node(inferType);\n  }\n}\n","import type { ZodPlugin } from '../types';\n\nexport function getZodModule({ plugin }: { plugin: ZodPlugin['Instance'] }): string {\n  const version = plugin.package.getVersion('zod');\n\n  if (version) {\n    if (plugin.package.satisfies(version, '<4.0.0')) {\n      switch (plugin.config.compatibilityVersion) {\n        case 3:\n        default:\n          return 'zod';\n        case 4:\n          return 'zod/v4';\n        case 'mini':\n          return 'zod/v4-mini';\n      }\n    }\n  }\n\n  switch (plugin.config.compatibilityVersion) {\n    case 3:\n      return 'zod/v3';\n    case 4:\n    default:\n      return 'zod';\n    case 'mini':\n      return 'zod/mini';\n  }\n}\n","import { fromRef } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming, operationResponsesMap } from '@hey-api/shared';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irOperationToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (schema: IR.SchemaObject, path: ReadonlyArray<string | number>) => Ast;\n  operation: IR.OperationObject;\n}): void => {\n  if (plugin.config.requests.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, fromRef(state.path));\n    const symbol = plugin.symbol(applyNaming(operation.id, plugin.config.requests), {\n      meta: {\n        category: 'schema',\n        path: fromRef(state.path),\n        resource: 'operation',\n        resourceId: operation.id,\n        role: 'data',\n        tags: fromRef(state.tags),\n        tool: 'zod',\n      },\n    });\n    const typeInferSymbol = plugin.config.requests.types.infer.enabled\n      ? plugin.symbol(applyNaming(operation.id, plugin.config.requests.types.infer), {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'data',\n            tags: fromRef(state.tags),\n            tool: 'zod',\n            variant: 'infer',\n          },\n        })\n      : undefined;\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      symbol,\n      typeInferSymbol,\n    });\n  }\n\n  if (plugin.config.responses.enabled) {\n    if (operation.responses) {\n      const { response } = operationResponsesMap(operation);\n\n      if (response) {\n        const path = [...fromRef(state.path), 'responses'];\n        const ast = getAst(response, path);\n        const symbol = plugin.symbol(applyNaming(operation.id, plugin.config.responses), {\n          meta: {\n            category: 'schema',\n            path,\n            resource: 'operation',\n            resourceId: operation.id,\n            role: 'responses',\n            tags: fromRef(state.tags),\n            tool: 'zod',\n          },\n        });\n        const typeInferSymbol = plugin.config.responses.types.infer.enabled\n          ? plugin.symbol(applyNaming(operation.id, plugin.config.responses.types.infer), {\n              meta: {\n                category: 'type',\n                path,\n                resource: 'operation',\n                resourceId: operation.id,\n                role: 'responses',\n                tags: fromRef(state.tags),\n                tool: 'zod',\n                variant: 'infer',\n              },\n            })\n          : undefined;\n        exportAst({\n          ast,\n          plugin,\n          schema: response,\n          symbol,\n          typeInferSymbol,\n        });\n      }\n    }\n  }\n};\n","import { fromRef } from '@hey-api/codegen-core';\nimport type { IR } from '@hey-api/shared';\nimport { applyNaming } from '@hey-api/shared';\n\nimport { exportAst } from './export';\nimport type { Ast, IrSchemaToAstOptions } from './types';\n\nexport const irWebhookToAst = ({\n  getAst,\n  operation,\n  plugin,\n  state,\n}: IrSchemaToAstOptions & {\n  getAst: (schema: IR.SchemaObject, path: ReadonlyArray<string | number>) => Ast;\n  operation: IR.OperationObject;\n}) => {\n  if (plugin.config.webhooks.enabled) {\n    const requiredProperties = new Set<string>();\n\n    const schemaData: IR.SchemaObject = {\n      properties: {\n        body: {\n          type: 'never',\n        },\n        path: {\n          type: 'never',\n        },\n        query: {\n          type: 'never',\n        },\n      },\n      type: 'object',\n    };\n\n    if (operation.parameters) {\n      // TODO: add support for cookies\n\n      if (operation.parameters.header) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.header) {\n          const parameter = operation.parameters.header[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('headers');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.headers = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.path) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.path) {\n          const parameter = operation.parameters.path[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('path');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.path = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n\n      if (operation.parameters.query) {\n        const properties: Record<string, IR.SchemaObject> = {};\n        const required: Array<string> = [];\n\n        for (const key in operation.parameters.query) {\n          const parameter = operation.parameters.query[key]!;\n          properties[parameter.name] = parameter.schema;\n          if (parameter.required) {\n            required.push(parameter.name);\n            requiredProperties.add('query');\n          }\n        }\n\n        if (Object.keys(properties).length) {\n          schemaData.properties!.query = {\n            properties,\n            required,\n            type: 'object',\n          };\n        }\n      }\n    }\n\n    if (operation.body) {\n      schemaData.properties!.body = operation.body.schema;\n\n      if (operation.body.required) {\n        requiredProperties.add('body');\n      }\n    }\n\n    schemaData.required = [...requiredProperties];\n\n    const ast = getAst(schemaData, fromRef(state.path));\n    const symbol = plugin.symbol(applyNaming(operation.id, plugin.config.webhooks), {\n      meta: {\n        category: 'schema',\n        path: fromRef(state.path),\n        resource: 'webhook',\n        resourceId: operation.id,\n        role: 'data',\n        tags: fromRef(state.tags),\n        tool: 'zod',\n      },\n    });\n    const typeInferSymbol = plugin.config.webhooks.types.infer.enabled\n      ? plugin.symbol(applyNaming(operation.id, plugin.config.webhooks.types.infer), {\n          meta: {\n            category: 'type',\n            path: fromRef(state.path),\n            resource: 'webhook',\n            resourceId: operation.id,\n            role: 'data',\n            tags: fromRef(state.tags),\n            tool: 'zod',\n            variant: 'infer',\n          },\n        })\n      : undefined;\n    exportAst({\n      ast,\n      plugin,\n      schema: schemaData,\n      symbol,\n      typeInferSymbol,\n    });\n  }\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z).attr(identifiers.unknown).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\nimport { deduplicateSchema } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const functionName = $(z).attr(identifiers.array);\n\n  if (!schema.items) {\n    result.expression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }).expression,\n    );\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      result.expression = functionName.call(...itemExpressions);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.intersection()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ReturnType<typeof $.expr | typeof $.call>;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemExpressions);\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = $(z)\n              .attr(identifiers.intersection)\n              .call(intersectionExpression, itemExpressions[i]);\n          }\n        }\n\n        result.expression = functionName.call(intersectionExpression);\n      } else {\n        result.expression = $(z)\n          .attr(identifiers.array)\n          .call(\n            $(z)\n              .attr(identifiers.union)\n              .call($.array(...itemExpressions)),\n          );\n      }\n    }\n  }\n\n  const checks: Array<ReturnType<typeof $.call>> = [];\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    checks.push($(z).attr(identifiers.length).call($.fromValue(schema.minItems)));\n  } else {\n    if (schema.minItems !== undefined) {\n      checks.push($(z).attr(identifiers.minLength).call($.fromValue(schema.minItems)));\n    }\n\n    if (schema.maxItems !== undefined) {\n      checks.push($(z).attr(identifiers.maxLength).call($.fromValue(schema.maxItems)));\n    }\n  }\n\n  if (checks.length > 0) {\n    result.expression = result.expression.attr(identifiers.check).call(...checks);\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport function booleanToAst({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): Omit<Ast, 'typeName'> {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.external('zod.z');\n\n  if (typeof schema.const === 'boolean') {\n    chain = $(z).attr(identifiers.literal).call($.literal(schema.const));\n    result.expression = chain;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  chain = $(z).attr(identifiers.boolean).call();\n  result.expression = chain;\n  return result as Omit<Ast, 'typeName'>;\n}\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { EnumResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nfunction itemsNode(ctx: EnumResolverContext): ReturnType<EnumResolverContext['nodes']['items']> {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n  const literalMembers: Array<Chain> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const literal = $.literal(item.const);\n      enumMembers.push(literal);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  return {\n    allStrings,\n    enumMembers,\n    isNullable,\n    literalMembers,\n  };\n}\n\nfunction baseNode(ctx: EnumResolverContext): Chain {\n  const { symbols } = ctx;\n  const { z } = symbols;\n  const { allStrings, enumMembers, literalMembers } = ctx.nodes.items(ctx);\n\n  if (allStrings && enumMembers.length > 0) {\n    return $(z)\n      .attr(identifiers.enum)\n      .call($.array(...enumMembers));\n  } else if (literalMembers.length === 1) {\n    return literalMembers[0]!;\n  } else {\n    return $(z)\n      .attr(identifiers.union)\n      .call($.array(...literalMembers));\n  }\n}\n\nfunction nullableNode(ctx: EnumResolverContext): Chain | undefined {\n  const { chain, symbols } = ctx;\n  const { z } = symbols;\n  const { isNullable } = ctx.nodes.items(ctx);\n  if (!isNullable) return;\n  return $(z).attr(identifiers.nullable).call(chain.current);\n}\n\nfunction enumResolver(ctx: EnumResolverContext): Chain {\n  const { literalMembers } = ctx.nodes.items(ctx);\n\n  if (!literalMembers.length) {\n    return ctx.chain.current;\n  }\n\n  const baseExpression = ctx.nodes.base(ctx);\n  ctx.chain.current = baseExpression;\n\n  const nullableExpression = ctx.nodes.nullable(ctx);\n  if (nullableExpression) {\n    ctx.chain.current = nullableExpression;\n  }\n\n  return ctx.chain.current;\n}\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n\n  const { literalMembers } = itemsNode({\n    $,\n    chain: { current: $(z) },\n    nodes: { base: baseNode, items: itemsNode, nullable: nullableNode },\n    plugin,\n    schema,\n    symbols: { z },\n    utils: { ast: {}, state },\n  });\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  const ctx: EnumResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      items: itemsNode,\n      nullable: nullableNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast: {},\n      state,\n    },\n  };\n\n  const resolver = plugin.config['~resolvers']?.enum;\n  const node = resolver?.(ctx) ?? enumResolver(ctx);\n\n  return {\n    expression: node,\n  };\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z).attr(identifiers.never).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z).attr(identifiers.null).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { maybeBigInt, shouldCoerceToBigInt } from '../../../../plugins/shared/utils/coerce';\nimport { getIntegerLimit } from '../../../../plugins/shared/utils/formats';\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { NumberResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nfunction baseNode(ctx: NumberResolverContext): Chain {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (ctx.utils.shouldCoerceToBigInt(schema.format)) {\n    return $(z).attr(identifiers.coerce).attr(identifiers.bigint).call();\n  }\n  let chain = $(z).attr(identifiers.number).call();\n  if (schema.type === 'integer') {\n    chain = $(z).attr(identifiers.int).call();\n  }\n  return chain;\n}\n\nfunction constNode(ctx: NumberResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.const === undefined) return;\n  return $(z).attr(identifiers.literal).call(ctx.utils.maybeBigInt(schema.const, schema.format));\n}\n\nfunction maxNode(ctx: NumberResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.exclusiveMaximum !== undefined) {\n    return $(z)\n      .attr(identifiers.lt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));\n  }\n  if (schema.maximum !== undefined) {\n    return $(z).attr(identifiers.lte).call(ctx.utils.maybeBigInt(schema.maximum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return $(z)\n      .attr(identifiers.maximum)\n      .call(\n        ctx.utils.maybeBigInt(limit.maxValue, schema.format),\n        $.object().prop('error', $.literal(limit.maxError)),\n      );\n  }\n  return;\n}\n\nfunction minNode(ctx: NumberResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.exclusiveMinimum !== undefined) {\n    return $(z)\n      .attr(identifiers.gt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));\n  }\n  if (schema.minimum !== undefined) {\n    return $(z).attr(identifiers.gte).call(ctx.utils.maybeBigInt(schema.minimum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return $(z)\n      .attr(identifiers.minimum)\n      .call(\n        ctx.utils.maybeBigInt(limit.minValue, schema.format),\n        $.object().prop('error', $.literal(limit.minError)),\n      );\n  }\n  return;\n}\n\nfunction numberResolver(ctx: NumberResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const checks: Array<Chain> = [];\n\n  const minNode = ctx.nodes.min(ctx);\n  if (minNode) checks.push(minNode);\n\n  const maxNode = ctx.nodes.max(ctx);\n  if (maxNode) checks.push(maxNode);\n\n  if (checks.length > 0) {\n    ctx.chain.current = ctx.chain.current.attr(identifiers.check).call(...checks);\n  }\n\n  return ctx.chain.current;\n}\n\nexport const numberToNode = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Omit<Ast, 'typeName'> => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: NumberResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      max: maxNode,\n      min: minNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      getIntegerLimit,\n      maybeBigInt,\n      shouldCoerceToBigInt,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.number;\n  const node = resolver?.(ctx) ?? numberResolver(ctx);\n  ast.expression = node;\n  return ast as Omit<Ast, 'typeName'>;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { ObjectResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nfunction additionalPropertiesNode(ctx: ObjectResolverContext): Chain | null | undefined {\n  const { plugin, schema } = ctx;\n\n  if (\n    !schema.additionalProperties ||\n    (schema.properties && Object.keys(schema.properties).length > 0)\n  )\n    return;\n\n  const additionalAst = irSchemaToAst({\n    plugin,\n    schema: schema.additionalProperties,\n    state: {\n      ...ctx.utils.state,\n      path: ref([...fromRef(ctx.utils.state.path), 'additionalProperties']),\n    },\n  });\n  if (additionalAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n  return additionalAst.expression;\n}\n\nfunction baseNode(ctx: ObjectResolverContext): Chain {\n  const { nodes, symbols } = ctx;\n  const { z } = symbols;\n\n  const additional = nodes.additionalProperties(ctx);\n  const shape = nodes.shape(ctx);\n\n  if (additional) {\n    return $(z).attr(identifiers.record).call($(z).attr(identifiers.string).call(), additional);\n  }\n\n  return $(z).attr(identifiers.object).call(shape);\n}\n\nfunction objectResolver(ctx: ObjectResolverContext): Chain {\n  // TODO: parser - handle constants\n  return ctx.nodes.base(ctx);\n}\n\nfunction shapeNode(ctx: ObjectResolverContext): ReturnType<typeof $.object> {\n  const { plugin, schema } = ctx;\n  const shape = $.object().pretty();\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n\n    const propertyAst = irSchemaToAst({\n      optional: !schema.required?.includes(name),\n      plugin,\n      schema: property,\n      state: {\n        ...ctx.utils.state,\n        path: ref([...fromRef(ctx.utils.state.path), 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      ctx.utils.ast.hasLazyExpression = true;\n      shape.getter(name, propertyAst.expression.return());\n    } else {\n      shape.prop(name, propertyAst.expression);\n    }\n  }\n\n  return shape;\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: ObjectResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      additionalProperties: additionalPropertiesNode,\n      base: baseNode,\n      shape: shapeNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.object;\n  const node = resolver?.(ctx) ?? objectResolver(ctx);\n  ast.expression = node;\n  return ast as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { StringResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nfunction baseNode(ctx: StringResolverContext): Chain {\n  const { z } = ctx.symbols;\n  return $(z).attr(identifiers.string).call();\n}\n\nfunction constNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (typeof schema.const !== 'string') return;\n  return $(z).attr(identifiers.literal).call($.literal(schema.const));\n}\n\nfunction formatNode(ctx: StringResolverContext): Chain | undefined {\n  const { plugin, schema, symbols } = ctx;\n  const { z } = symbols;\n\n  switch (schema.format) {\n    case 'date':\n      return $(z).attr(identifiers.iso).attr(identifiers.date).call();\n    case 'date-time': {\n      const obj = $.object()\n        .$if(plugin.config.dates.offset, (o) => o.prop('offset', $.literal(true)))\n        .$if(plugin.config.dates.local, (o) => o.prop('local', $.literal(true)));\n      return $(z)\n        .attr(identifiers.iso)\n        .attr(identifiers.datetime)\n        .call(obj.hasProps() ? obj : undefined);\n    }\n    case 'email':\n      return $(z).attr(identifiers.email).call();\n    case 'ipv4':\n      return $(z).attr(identifiers.ipv4).call();\n    case 'ipv6':\n      return $(z).attr(identifiers.ipv6).call();\n    case 'time':\n      return $(z).attr(identifiers.iso).attr(identifiers.time).call();\n    case 'uri':\n      return $(z).attr(identifiers.url).call();\n    case 'uuid':\n      return $(z).attr(identifiers.uuid).call();\n  }\n\n  return;\n}\n\nfunction lengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.minLength === undefined || schema.minLength !== schema.maxLength) return;\n  return $(z).attr(identifiers.length).call($.literal(schema.minLength));\n}\n\nfunction maxLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.maxLength === undefined) return;\n  return $(z).attr(identifiers.maxLength).call($.literal(schema.maxLength));\n}\n\nfunction minLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.minLength === undefined) return;\n  return $(z).attr(identifiers.minLength).call($.literal(schema.minLength));\n}\n\nfunction patternNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (!schema.pattern) return;\n  return $(z).attr(identifiers.regex).call($.regexp(schema.pattern));\n}\n\nfunction stringResolver(ctx: StringResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const formatNode = ctx.nodes.format(ctx);\n  if (formatNode) ctx.chain.current = formatNode;\n\n  const checks: Array<Chain> = [];\n\n  const lengthNode = ctx.nodes.length(ctx);\n  if (lengthNode) {\n    checks.push(lengthNode);\n  } else {\n    const minLengthNode = ctx.nodes.minLength(ctx);\n    if (minLengthNode) checks.push(minLengthNode);\n\n    const maxLengthNode = ctx.nodes.maxLength(ctx);\n    if (maxLengthNode) checks.push(maxLengthNode);\n  }\n\n  const patternNode = ctx.nodes.pattern(ctx);\n  if (patternNode) checks.push(patternNode);\n\n  if (checks.length > 0) {\n    ctx.chain.current = ctx.chain.current.attr(identifiers.check).call(...checks);\n  }\n\n  return ctx.chain.current;\n}\n\nexport const stringToNode = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n  const ctx: StringResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      format: formatNode,\n      length: lengthNode,\n      maxLength: maxLengthNode,\n      minLength: minLengthNode,\n      pattern: patternNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.string;\n  const node = resolver?.(ctx) ?? stringResolver(ctx);\n  return {\n    expression: node,\n  };\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(z).attr(identifiers.literal).call($.fromValue(value)),\n    );\n    result.expression = $(z)\n      .attr(identifiers.tuple)\n      .call($.array(...tupleElements));\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  const tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n    });\n  }\n\n  result.expression = $(z)\n    .attr(identifiers.tuple)\n    .call($.array(...tupleElements));\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z).attr(identifiers.undefined).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  result.expression = $(z).attr(identifiers.void).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { shouldCoerceToBigInt } from '../../../../plugins/shared/utils/coerce';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToNode } from './number';\nimport { objectToAst } from './object';\nimport { stringToNode } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport function irSchemaWithTypeToAst({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToNode({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return shouldCoerceToBigInt(schema.format)\n        ? numberToNode({\n            ...args,\n            schema: { ...schema, type: 'number' },\n          })\n        : stringToNode({\n            ...args,\n            schema: schema as SchemaWithType<'string'>,\n          });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n}\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { fromRef, ref, refs } from '@hey-api/codegen-core';\nimport type { IR, SchemaWithType } from '@hey-api/shared';\nimport { applyNaming, deduplicateSchema, pathToJsonPointer, refToName } from '@hey-api/shared';\n\nimport { maybeBigInt } from '../../../plugins/shared/utils/coerce';\nimport { $ } from '../../../ts-dsl';\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport function irSchemaToAst({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.external('zod.z');\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'zod',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      ast.expression = $(refSymbol);\n    } else {\n      ast.expression = $(z)\n        .attr(identifiers.lazy)\n        .call($.func().returns('any').do($(refSymbol).return()));\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression['~ref'] = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = ast.expression\n        .attr(identifiers.register)\n        .call(\n          $(z).attr(identifiers.globalRegistry),\n          $.object().pretty().prop('description', $.literal(schema.description)),\n        );\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemSchemas = schema.items.map((item, index) =>\n        irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: ref([...fromRef(state.path), 'items', index]),\n          },\n        }),\n      );\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemSchemas.map((schema) => schema.expression));\n        } else {\n          ast.expression = itemSchemas[0]!.expression;\n          itemSchemas.slice(1).forEach((schema) => {\n            ast.expression = $(z)\n              .attr(identifiers.intersection)\n              .call(\n                ast.expression,\n                schema.hasLazyExpression\n                  ? $(z).attr(identifiers.lazy).call($.func().do(schema.expression.return()))\n                  : schema.expression,\n              );\n          });\n        }\n      } else {\n        ast.expression = $(z)\n          .attr(identifiers.union)\n          .call(\n            $.array()\n              .pretty()\n              .elements(...itemSchemas.map((schema) => schema.expression)),\n          );\n      }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = $(z).attr(identifiers.readonly).call(ast.expression);\n    }\n\n    if (optional) {\n      ast.expression = $(z).attr(identifiers.optional).call(ast.expression);\n      ast.typeName = identifiers.ZodMiniOptional;\n    }\n\n    if (schema.default !== undefined) {\n      ast.expression = $(z)\n        .attr(identifiers._default)\n        .call(\n          ast.expression,\n          schema.type === 'integer' || schema.type === 'number'\n            ? maybeBigInt(schema.default, schema.format)\n            : $.fromValue(schema.default),\n        );\n    }\n  }\n\n  return ast as Ast;\n}\n\nfunction handleComponent({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.symbol(applyNaming(baseName, plugin.config.definitions), {\n    meta: {\n      category: 'schema',\n      path: fromRef(state.path),\n      resource: 'definition',\n      resourceId: $ref,\n      tags: fromRef(state.tags),\n      tool: 'zod',\n    },\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.symbol(applyNaming(baseName, plugin.config.definitions.types.infer), {\n        meta: {\n          category: 'type',\n          path: fromRef(state.path),\n          resource: 'definition',\n          resourceId: $ref,\n          tags: fromRef(state.tags),\n          tool: 'zod',\n          variant: 'infer',\n        },\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n}\n\nexport const handlerMini: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('z', {\n    external: getZodModule({ plugin }),\n    importKind: 'namespace',\n    meta: {\n      category: 'external',\n      resource: 'zod.z',\n    },\n  });\n\n  plugin.forEach('operation', 'parameter', 'requestBody', 'schema', 'webhook', (event) => {\n    const state = refs<PluginState>({\n      hasLazyExpression: false,\n      path: event._path,\n      tags: event.tags,\n    });\n    switch (event.type) {\n      case 'operation':\n        irOperationToAst({\n          getAst: (schema, path) => {\n            const state = refs<PluginState>({\n              hasLazyExpression: false,\n              path,\n              tags: event.tags,\n            });\n            return irSchemaToAst({ plugin, schema, state });\n          },\n          operation: event.operation,\n          plugin,\n          state,\n        });\n        break;\n      case 'parameter':\n        handleComponent({\n          plugin,\n          schema: event.parameter.schema,\n          state,\n        });\n        break;\n      case 'requestBody':\n        handleComponent({\n          plugin,\n          schema: event.requestBody.schema,\n          state,\n        });\n        break;\n      case 'schema':\n        handleComponent({\n          plugin,\n          schema: event.schema,\n          state,\n        });\n        break;\n      case 'webhook':\n        irWebhookToAst({\n          getAst: (schema, path) => {\n            const state = refs<PluginState>({\n              hasLazyExpression: false,\n              path,\n              tags: event.tags,\n            });\n            return irSchemaToAst({ plugin, schema, state });\n          },\n          operation: event.operation,\n          plugin,\n          state,\n        });\n        break;\n    }\n  });\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}) => {\n  const z = plugin.external('zod.z');\n  const expression = $(z).attr(identifiers.unknown).call();\n  return expression;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\nimport { deduplicateSchema } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  const z = plugin.external('zod.z');\n\n  const functionName = $(z).attr(identifiers.array);\n\n  let arrayExpression: ReturnType<typeof $.call> | undefined;\n  let hasLazyExpression = false;\n\n  if (!schema.items) {\n    arrayExpression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }),\n    );\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      arrayExpression = functionName.call(...itemExpressions);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.and()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ReturnType<typeof $.call | typeof $.expr>;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemExpressions);\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = intersectionExpression\n              .attr(identifiers.and)\n              .call(itemExpressions[i]);\n          }\n        }\n\n        arrayExpression = functionName.call(intersectionExpression);\n      } else {\n        arrayExpression = $(z)\n          .attr(identifiers.array)\n          .call(\n            $(z)\n              .attr(identifiers.union)\n              .call($.array(...itemExpressions)),\n          );\n      }\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    arrayExpression = arrayExpression.attr(identifiers.length).call($.fromValue(schema.minItems));\n  } else {\n    if (schema.minItems !== undefined) {\n      arrayExpression = arrayExpression.attr(identifiers.min).call($.fromValue(schema.minItems));\n    }\n\n    if (schema.maxItems !== undefined) {\n      arrayExpression = arrayExpression.attr(identifiers.max).call($.fromValue(schema.maxItems));\n    }\n  }\n\n  return {\n    expression: arrayExpression,\n    hasLazyExpression,\n  };\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport function booleanToAst({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): ReturnType<typeof $.call> {\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.external('zod.z');\n\n  if (typeof schema.const === 'boolean') {\n    chain = $(z).attr(identifiers.literal).call($.literal(schema.const));\n    return chain;\n  }\n\n  chain = $(z).attr(identifiers.boolean).call();\n  return chain;\n}\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { EnumResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nfunction itemsNode(ctx: EnumResolverContext): ReturnType<EnumResolverContext['nodes']['items']> {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n  const literalMembers: Array<Chain> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const literal = $.literal(item.const);\n      enumMembers.push(literal);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  return {\n    allStrings,\n    enumMembers,\n    isNullable,\n    literalMembers,\n  };\n}\n\nfunction baseNode(ctx: EnumResolverContext): Chain {\n  const { symbols } = ctx;\n  const { z } = symbols;\n  const { allStrings, enumMembers, literalMembers } = ctx.nodes.items(ctx);\n\n  if (allStrings && enumMembers.length > 0) {\n    return $(z)\n      .attr(identifiers.enum)\n      .call($.array(...enumMembers));\n  } else if (literalMembers.length === 1) {\n    return literalMembers[0]!;\n  } else {\n    return $(z)\n      .attr(identifiers.union)\n      .call($.array(...literalMembers));\n  }\n}\n\nfunction nullableNode(ctx: EnumResolverContext): Chain | undefined {\n  const { chain } = ctx;\n  const { isNullable } = ctx.nodes.items(ctx);\n  if (!isNullable) return;\n  return chain.current.attr(identifiers.nullable).call();\n}\n\nfunction enumResolver(ctx: EnumResolverContext): Chain {\n  const { literalMembers } = ctx.nodes.items(ctx);\n\n  if (!literalMembers.length) {\n    return ctx.chain.current;\n  }\n\n  const baseExpression = ctx.nodes.base(ctx);\n  ctx.chain.current = baseExpression;\n\n  const nullableExpression = ctx.nodes.nullable(ctx);\n  if (nullableExpression) {\n    ctx.chain.current = nullableExpression;\n  }\n\n  return ctx.chain.current;\n}\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): Chain => {\n  const z = plugin.external('zod.z');\n\n  const { literalMembers } = itemsNode({\n    $,\n    chain: { current: $(z) },\n    nodes: { base: baseNode, items: itemsNode, nullable: nullableNode },\n    plugin,\n    schema,\n    symbols: { z },\n    utils: { ast: {}, state },\n  });\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  const ctx: EnumResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      items: itemsNode,\n      nullable: nullableNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast: {},\n      state,\n    },\n  };\n\n  const resolver = plugin.config['~resolvers']?.enum;\n  return resolver?.(ctx) ?? enumResolver(ctx);\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}) => {\n  const z = plugin.external('zod.z');\n  const expression = $(z).attr(identifiers.never).call();\n  return expression;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}) => {\n  const z = plugin.external('zod.z');\n  const expression = $(z).attr(identifiers.null).call();\n  return expression;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { maybeBigInt, shouldCoerceToBigInt } from '../../../../plugins/shared/utils/coerce';\nimport { getIntegerLimit } from '../../../../plugins/shared/utils/formats';\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { NumberResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nfunction baseNode(ctx: NumberResolverContext): Chain {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (ctx.utils.shouldCoerceToBigInt(schema.format)) {\n    return $(z).attr(identifiers.coerce).attr(identifiers.bigint).call();\n  }\n  let chain = $(z).attr(identifiers.number).call();\n  if (schema.type === 'integer') {\n    chain = chain.attr(identifiers.int).call();\n  }\n  return chain;\n}\n\nfunction constNode(ctx: NumberResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.const === undefined) return;\n  return $(z).attr(identifiers.literal).call(ctx.utils.maybeBigInt(schema.const, schema.format));\n}\n\nfunction maxNode(ctx: NumberResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.exclusiveMaximum !== undefined) {\n    return chain.current\n      .attr(identifiers.lt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));\n  }\n  if (schema.maximum !== undefined) {\n    return chain.current\n      .attr(identifiers.lte)\n      .call(ctx.utils.maybeBigInt(schema.maximum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return chain.current\n      .attr(identifiers.max)\n      .call(\n        ctx.utils.maybeBigInt(limit.maxValue, schema.format),\n        $.object().prop('message', $.literal(limit.maxError)),\n      );\n  }\n  return;\n}\n\nfunction minNode(ctx: NumberResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.exclusiveMinimum !== undefined) {\n    return chain.current\n      .attr(identifiers.gt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));\n  }\n  if (schema.minimum !== undefined) {\n    return chain.current\n      .attr(identifiers.gte)\n      .call(ctx.utils.maybeBigInt(schema.minimum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return chain.current\n      .attr(identifiers.min)\n      .call(\n        ctx.utils.maybeBigInt(limit.minValue, schema.format),\n        $.object().prop('message', $.literal(limit.minError)),\n      );\n  }\n  return;\n}\n\nfunction numberResolver(ctx: NumberResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const minNode = ctx.nodes.min(ctx);\n  if (minNode) ctx.chain.current = minNode;\n\n  const maxNode = ctx.nodes.max(ctx);\n  if (maxNode) ctx.chain.current = maxNode;\n\n  return ctx.chain.current;\n}\n\nexport const numberToNode = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Chain => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: NumberResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      max: maxNode,\n      min: minNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      getIntegerLimit,\n      maybeBigInt,\n      shouldCoerceToBigInt,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.number;\n  const node = resolver?.(ctx) ?? numberResolver(ctx);\n  return node;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { ObjectResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nfunction additionalPropertiesNode(ctx: ObjectResolverContext): Chain | null | undefined {\n  const { plugin, schema } = ctx;\n\n  if (\n    !schema.additionalProperties ||\n    (schema.properties && Object.keys(schema.properties).length > 0)\n  )\n    return;\n\n  const additionalAst = irSchemaToAst({\n    plugin,\n    schema: schema.additionalProperties,\n    state: {\n      ...ctx.utils.state,\n      path: ref([...fromRef(ctx.utils.state.path), 'additionalProperties']),\n    },\n  });\n  if (additionalAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n  return additionalAst.expression;\n}\n\nfunction baseNode(ctx: ObjectResolverContext): Chain {\n  const { nodes, symbols } = ctx;\n  const { z } = symbols;\n\n  const additional = nodes.additionalProperties(ctx);\n  const shape = nodes.shape(ctx);\n\n  if (additional) {\n    return $(z).attr(identifiers.record).call(additional);\n  }\n\n  return $(z).attr(identifiers.object).call(shape);\n}\n\nfunction objectResolver(ctx: ObjectResolverContext): Chain {\n  // TODO: parser - handle constants\n  return ctx.nodes.base(ctx);\n}\n\nfunction shapeNode(ctx: ObjectResolverContext): ReturnType<typeof $.object> {\n  const { plugin, schema } = ctx;\n  const shape = $.object().pretty();\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n\n    const propertyAst = irSchemaToAst({\n      optional: !schema.required?.includes(name),\n      plugin,\n      schema: property,\n      state: {\n        ...ctx.utils.state,\n        path: ref([...fromRef(ctx.utils.state.path), 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n    shape.prop(name, propertyAst.expression);\n  }\n\n  return shape;\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: ObjectResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      additionalProperties: additionalPropertiesNode,\n      base: baseNode,\n      shape: shapeNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.object;\n  const node = resolver?.(ctx) ?? objectResolver(ctx);\n  ast.expression = node;\n  return {\n    ...ast,\n    anyType: 'AnyZodObject',\n  } as Omit<Ast, 'typeName'> & {\n    anyType: string;\n  };\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { StringResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nfunction baseNode(ctx: StringResolverContext): Chain {\n  const { z } = ctx.symbols;\n  return $(z).attr(identifiers.string).call();\n}\n\nfunction constNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (typeof schema.const !== 'string') return;\n  return $(z).attr(identifiers.literal).call($.literal(schema.const));\n}\n\nfunction formatNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, plugin, schema } = ctx;\n\n  switch (schema.format) {\n    case 'date':\n      return chain.current.attr(identifiers.date).call();\n    case 'date-time': {\n      const obj = $.object()\n        .$if(plugin.config.dates.offset, (o) => o.prop('offset', $.literal(true)))\n        .$if(plugin.config.dates.local, (o) => o.prop('local', $.literal(true)));\n      return chain.current.attr(identifiers.datetime).call(obj.hasProps() ? obj : undefined);\n    }\n    case 'email':\n      return chain.current.attr(identifiers.email).call();\n    case 'ipv4':\n    case 'ipv6':\n      return chain.current.attr(identifiers.ip).call();\n    case 'time':\n      return chain.current.attr(identifiers.time).call();\n    case 'uri':\n      return chain.current.attr(identifiers.url).call();\n    case 'uuid':\n      return chain.current.attr(identifiers.uuid).call();\n  }\n\n  return;\n}\n\nfunction lengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.minLength === undefined || schema.minLength !== schema.maxLength) return;\n  return chain.current.attr(identifiers.length).call($.literal(schema.minLength));\n}\n\nfunction maxLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.maxLength === undefined) return;\n  return chain.current.attr(identifiers.max).call($.literal(schema.maxLength));\n}\n\nfunction minLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.minLength === undefined) return;\n  return chain.current.attr(identifiers.min).call($.literal(schema.minLength));\n}\n\nfunction patternNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (!schema.pattern) return;\n  return chain.current.attr(identifiers.regex).call($.regexp(schema.pattern));\n}\n\nfunction stringResolver(ctx: StringResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const formatNode = ctx.nodes.format(ctx);\n  if (formatNode) ctx.chain.current = formatNode;\n\n  const lengthNode = ctx.nodes.length(ctx);\n  if (lengthNode) {\n    ctx.chain.current = lengthNode;\n  } else {\n    const minLengthNode = ctx.nodes.minLength(ctx);\n    if (minLengthNode) ctx.chain.current = minLengthNode;\n\n    const maxLengthNode = ctx.nodes.maxLength(ctx);\n    if (maxLengthNode) ctx.chain.current = maxLengthNode;\n  }\n\n  const patternNode = ctx.nodes.pattern(ctx);\n  if (patternNode) ctx.chain.current = patternNode;\n\n  return ctx.chain.current;\n}\n\nexport const stringToNode = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Chain => {\n  const z = plugin.external('zod.z');\n  const ctx: StringResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      format: formatNode,\n      length: lengthNode,\n      maxLength: maxLengthNode,\n      minLength: minLengthNode,\n      pattern: patternNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.string;\n  const node = resolver?.(ctx) ?? stringResolver(ctx);\n  return node;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} => {\n  const z = plugin.external('zod.z');\n\n  let hasLazyExpression = false;\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(z).attr(identifiers.literal).call($.fromValue(value)),\n    );\n    const expression = $(z)\n      .attr(identifiers.tuple)\n      .call($.array(...tupleElements));\n    return {\n      expression,\n      hasLazyExpression,\n    };\n  }\n\n  const tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        hasLazyExpression = true;\n      }\n    });\n  }\n\n  const expression = $(z)\n    .attr(identifiers.tuple)\n    .call($.array(...tupleElements));\n\n  return {\n    expression,\n    hasLazyExpression,\n  };\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}) => {\n  const z = plugin.external('zod.z');\n  const expression = $(z).attr(identifiers.undefined).call();\n  return expression;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}) => {\n  const z = plugin.external('zod.z');\n  const expression = $(z).attr(identifiers.void).call();\n  return expression;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { shouldCoerceToBigInt } from '../../../../plugins/shared/utils/coerce';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToNode } from './number';\nimport { objectToAst } from './object';\nimport { stringToNode } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport function irSchemaWithTypeToAst({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> & {\n  anyType?: string;\n} {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return {\n        expression: booleanToAst({\n          ...args,\n          schema: schema as SchemaWithType<'boolean'>,\n        }),\n      };\n    case 'enum':\n      return {\n        expression: enumToAst({\n          ...args,\n          schema: schema as SchemaWithType<'enum'>,\n        }),\n      };\n    case 'integer':\n    case 'number':\n      return {\n        expression: numberToNode({\n          ...args,\n          schema: schema as SchemaWithType<'integer' | 'number'>,\n        }),\n      };\n    case 'never':\n      return {\n        expression: neverToAst({\n          ...args,\n          schema: schema as SchemaWithType<'never'>,\n        }),\n      };\n    case 'null':\n      return {\n        expression: nullToAst({\n          ...args,\n          schema: schema as SchemaWithType<'null'>,\n        }),\n      };\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return {\n        expression: shouldCoerceToBigInt(schema.format)\n          ? numberToNode({\n              ...args,\n              schema: { ...schema, type: 'number' },\n            })\n          : stringToNode({\n              ...args,\n              schema: schema as SchemaWithType<'string'>,\n            }),\n      };\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return {\n        expression: undefinedToAst({\n          ...args,\n          schema: schema as SchemaWithType<'undefined'>,\n        }),\n      };\n    case 'unknown':\n      return {\n        expression: unknownToAst({\n          ...args,\n          schema: schema as SchemaWithType<'unknown'>,\n        }),\n      };\n    case 'void':\n      return {\n        expression: voidToAst({\n          ...args,\n          schema: schema as SchemaWithType<'void'>,\n        }),\n      };\n  }\n}\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { fromRef, ref, refs } from '@hey-api/codegen-core';\nimport type { IR, SchemaWithType } from '@hey-api/shared';\nimport { applyNaming, deduplicateSchema, pathToJsonPointer, refToName } from '@hey-api/shared';\n\nimport { maybeBigInt } from '../../../plugins/shared/utils/coerce';\nimport { $ } from '../../../ts-dsl';\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport function irSchemaToAst({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.external('zod.z');\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'zod',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      ast.expression = $(refSymbol);\n    } else {\n      ast.expression = $(z)\n        .attr(identifiers.lazy)\n        .call($.func().do($(refSymbol).return()));\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression['~ref'] = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.typeName = typeAst.anyType;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = ast.expression\n        .attr(identifiers.describe)\n        .call($.literal(schema.description));\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemTypes = schema.items.map((item, index) => {\n        const typeAst = irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: ref([...fromRef(state.path), 'items', index]),\n          },\n        });\n        return typeAst.expression;\n      });\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemTypes);\n        } else {\n          ast.expression = itemTypes[0];\n          itemTypes.slice(1).forEach((item) => {\n            ast.expression = ast.expression!.attr(identifiers.and).call(item);\n          });\n        }\n      } else {\n        ast.expression = $(z)\n          .attr(identifiers.union)\n          .call(\n            $.array()\n              .pretty()\n              .elements(...itemTypes),\n          );\n      }\n    } else {\n      ast = irSchemaToAst({ plugin, schema, state });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.typeName = typeAst.anyType;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = ast.expression.attr(identifiers.readonly).call();\n    }\n\n    if (optional) {\n      ast.expression = ast.expression.attr(identifiers.optional).call();\n    }\n\n    if (schema.default !== undefined) {\n      ast.expression = ast.expression\n        .attr(identifiers.default)\n        .call(\n          schema.type === 'integer' || schema.type === 'number'\n            ? maybeBigInt(schema.default, schema.format)\n            : $.fromValue(schema.default),\n        );\n    }\n  }\n\n  if (state.hasLazyExpression['~ref']) {\n    if (!ast.typeName) {\n      ast.typeName = 'ZodTypeAny';\n    }\n  } else if (ast.typeName) {\n    ast.typeName = undefined;\n  }\n\n  return ast as Ast;\n}\n\nfunction handleComponent({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.symbol(applyNaming(baseName, plugin.config.definitions), {\n    meta: {\n      category: 'schema',\n      path: fromRef(state.path),\n      resource: 'definition',\n      resourceId: $ref,\n      tags: fromRef(state.tags),\n      tool: 'zod',\n    },\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.symbol(applyNaming(baseName, plugin.config.definitions.types.infer), {\n        meta: {\n          category: 'type',\n          path: fromRef(state.path),\n          resource: 'definition',\n          resourceId: $ref,\n          tags: fromRef(state.tags),\n          tool: 'zod',\n          variant: 'infer',\n        },\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n}\n\nexport const handlerV3: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('z', {\n    external: getZodModule({ plugin }),\n    meta: {\n      category: 'external',\n      resource: 'zod.z',\n    },\n  });\n\n  plugin.forEach('operation', 'parameter', 'requestBody', 'schema', 'webhook', (event) => {\n    const state = refs<PluginState>({\n      hasLazyExpression: false,\n      path: event._path,\n      tags: event.tags,\n    });\n    switch (event.type) {\n      case 'operation':\n        irOperationToAst({\n          getAst: (schema, path) => {\n            const state = refs<PluginState>({\n              hasLazyExpression: false,\n              path,\n              tags: event.tags,\n            });\n            return irSchemaToAst({ plugin, schema, state });\n          },\n          operation: event.operation,\n          plugin,\n          state,\n        });\n        break;\n      case 'parameter':\n        handleComponent({\n          plugin,\n          schema: event.parameter.schema,\n          state,\n        });\n        break;\n      case 'requestBody':\n        handleComponent({\n          plugin,\n          schema: event.requestBody.schema,\n          state,\n        });\n        break;\n      case 'schema':\n        handleComponent({\n          plugin,\n          schema: event.schema,\n          state,\n        });\n        break;\n      case 'webhook':\n        irWebhookToAst({\n          getAst: (schema, path) => {\n            const state = refs<PluginState>({\n              hasLazyExpression: false,\n              path,\n              tags: event.tags,\n            });\n            return irSchemaToAst({ plugin, schema, state });\n          },\n          operation: event.operation,\n          plugin,\n          state,\n        });\n        break;\n    }\n  });\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const unknownToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'unknown'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  result.expression = $(z).attr(identifiers.unknown).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\nimport { deduplicateSchema } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\nimport { unknownToAst } from './unknown';\n\nexport const arrayToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'array'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.external('zod.z');\n\n  const functionName = $(z).attr(identifiers.array);\n\n  if (!schema.items) {\n    result.expression = functionName.call(\n      unknownToAst({\n        plugin,\n        schema: {\n          type: 'unknown',\n        },\n        state,\n      }).expression,\n    );\n  } else {\n    schema = deduplicateSchema({ schema });\n\n    // at least one item is guaranteed\n    const itemExpressions = schema.items!.map((item, index) => {\n      const itemAst = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      if (itemAst.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n      return itemAst.expression;\n    });\n\n    if (itemExpressions.length === 1) {\n      result.expression = functionName.call(...itemExpressions);\n    } else {\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items![0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.and()` as that does not exist on `.union()` and non-object schemas.\n        let intersectionExpression: ReturnType<typeof $.call | typeof $.expr>;\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          intersectionExpression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemExpressions);\n        } else {\n          intersectionExpression = itemExpressions[0]!;\n          for (let i = 1; i < itemExpressions.length; i++) {\n            intersectionExpression = intersectionExpression\n              .attr(identifiers.and)\n              .call(itemExpressions[i]);\n          }\n        }\n\n        result.expression = functionName.call(intersectionExpression);\n      } else {\n        result.expression = $(z)\n          .attr(identifiers.array)\n          .call(\n            $(z)\n              .attr(identifiers.union)\n              .call($.array(...itemExpressions)),\n          );\n      }\n    }\n  }\n\n  if (schema.minItems === schema.maxItems && schema.minItems !== undefined) {\n    result.expression = result.expression\n      .attr(identifiers.length)\n      .call($.fromValue(schema.minItems));\n  } else {\n    if (schema.minItems !== undefined) {\n      result.expression = result.expression\n        .attr(identifiers.min)\n        .call($.fromValue(schema.minItems));\n    }\n\n    if (schema.maxItems !== undefined) {\n      result.expression = result.expression\n        .attr(identifiers.max)\n        .call($.fromValue(schema.maxItems));\n    }\n  }\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport function booleanToAst({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'boolean'>;\n}): Omit<Ast, 'typeName'> {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  let chain: ReturnType<typeof $.call>;\n\n  const z = plugin.external('zod.z');\n\n  if (typeof schema.const === 'boolean') {\n    chain = $(z).attr(identifiers.literal).call($.literal(schema.const));\n    result.expression = chain;\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  chain = $(z).attr(identifiers.boolean).call();\n  result.expression = chain;\n  return result as Omit<Ast, 'typeName'>;\n}\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { EnumResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { unknownToAst } from './unknown';\n\nfunction itemsNode(ctx: EnumResolverContext): ReturnType<EnumResolverContext['nodes']['items']> {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n\n  const enumMembers: Array<ReturnType<typeof $.literal>> = [];\n  const literalMembers: Array<Chain> = [];\n\n  let isNullable = false;\n  let allStrings = true;\n\n  for (const item of schema.items ?? []) {\n    if (item.type === 'string' && typeof item.const === 'string') {\n      const literal = $.literal(item.const);\n      enumMembers.push(literal);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (\n      (item.type === 'number' || item.type === 'integer') &&\n      typeof item.const === 'number'\n    ) {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'boolean' && typeof item.const === 'boolean') {\n      allStrings = false;\n      const literal = $.literal(item.const);\n      literalMembers.push($(z).attr(identifiers.literal).call(literal));\n    } else if (item.type === 'null' || item.const === null) {\n      isNullable = true;\n    }\n  }\n\n  return {\n    allStrings,\n    enumMembers,\n    isNullable,\n    literalMembers,\n  };\n}\n\nfunction baseNode(ctx: EnumResolverContext): Chain {\n  const { symbols } = ctx;\n  const { z } = symbols;\n  const { allStrings, enumMembers, literalMembers } = ctx.nodes.items(ctx);\n\n  if (allStrings && enumMembers.length > 0) {\n    return $(z)\n      .attr(identifiers.enum)\n      .call($.array(...enumMembers));\n  } else if (literalMembers.length === 1) {\n    return literalMembers[0]!;\n  } else {\n    return $(z)\n      .attr(identifiers.union)\n      .call($.array(...literalMembers));\n  }\n}\n\nfunction nullableNode(ctx: EnumResolverContext): Chain | undefined {\n  const { chain, symbols } = ctx;\n  const { z } = symbols;\n  const { isNullable } = ctx.nodes.items(ctx);\n  if (!isNullable) return;\n  return $(z).attr(identifiers.nullable).call(chain.current);\n}\n\nfunction enumResolver(ctx: EnumResolverContext): Chain {\n  const { literalMembers } = ctx.nodes.items(ctx);\n\n  if (!literalMembers.length) {\n    return ctx.chain.current;\n  }\n\n  const baseExpression = ctx.nodes.base(ctx);\n  ctx.chain.current = baseExpression;\n\n  const nullableExpression = ctx.nodes.nullable(ctx);\n  if (nullableExpression) {\n    ctx.chain.current = nullableExpression;\n  }\n\n  return ctx.chain.current;\n}\n\nexport const enumToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'enum'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n\n  const { literalMembers } = itemsNode({\n    $,\n    chain: { current: $(z) },\n    nodes: { base: baseNode, items: itemsNode, nullable: nullableNode },\n    plugin,\n    schema,\n    symbols: { z },\n    utils: { ast: {}, state },\n  });\n\n  if (!literalMembers.length) {\n    return unknownToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n  }\n\n  const ctx: EnumResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      items: itemsNode,\n      nullable: nullableNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast: {},\n      state,\n    },\n  };\n\n  const resolver = plugin.config['~resolvers']?.enum;\n  const node = resolver?.(ctx) ?? enumResolver(ctx);\n\n  return {\n    expression: node,\n  };\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const neverToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'never'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  result.expression = $(z).attr(identifiers.never).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const nullToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'null'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  result.expression = $(z).attr(identifiers.null).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { maybeBigInt, shouldCoerceToBigInt } from '../../../../plugins/shared/utils/coerce';\nimport { getIntegerLimit } from '../../../../plugins/shared/utils/formats';\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { NumberResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nfunction baseNode(ctx: NumberResolverContext): Chain {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (ctx.utils.shouldCoerceToBigInt(schema.format)) {\n    return $(z).attr(identifiers.coerce).attr(identifiers.bigint).call();\n  }\n  let chain = $(z).attr(identifiers.number).call();\n  if (schema.type === 'integer') {\n    chain = $(z).attr(identifiers.int).call();\n  }\n  return chain;\n}\n\nfunction constNode(ctx: NumberResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (schema.const === undefined) return;\n  return $(z).attr(identifiers.literal).call(ctx.utils.maybeBigInt(schema.const, schema.format));\n}\n\nfunction maxNode(ctx: NumberResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.exclusiveMaximum !== undefined) {\n    return chain.current\n      .attr(identifiers.lt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMaximum, schema.format));\n  }\n  if (schema.maximum !== undefined) {\n    return chain.current\n      .attr(identifiers.lte)\n      .call(ctx.utils.maybeBigInt(schema.maximum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return chain.current\n      .attr(identifiers.max)\n      .call(\n        ctx.utils.maybeBigInt(limit.maxValue, schema.format),\n        $.object().prop('error', $.literal(limit.maxError)),\n      );\n  }\n  return;\n}\n\nfunction minNode(ctx: NumberResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.exclusiveMinimum !== undefined) {\n    return chain.current\n      .attr(identifiers.gt)\n      .call(ctx.utils.maybeBigInt(schema.exclusiveMinimum, schema.format));\n  }\n  if (schema.minimum !== undefined) {\n    return chain.current\n      .attr(identifiers.gte)\n      .call(ctx.utils.maybeBigInt(schema.minimum, schema.format));\n  }\n  const limit = ctx.utils.getIntegerLimit(schema.format);\n  if (limit) {\n    return chain.current\n      .attr(identifiers.min)\n      .call(\n        ctx.utils.maybeBigInt(limit.minValue, schema.format),\n        $.object().prop('error', $.literal(limit.minError)),\n      );\n  }\n  return;\n}\n\nfunction numberResolver(ctx: NumberResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const minNode = ctx.nodes.min(ctx);\n  if (minNode) ctx.chain.current = minNode;\n\n  const maxNode = ctx.nodes.max(ctx);\n  if (maxNode) ctx.chain.current = maxNode;\n\n  return ctx.chain.current;\n}\n\nexport const numberToNode = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'integer' | 'number'>;\n}): Omit<Ast, 'typeName'> => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: NumberResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      max: maxNode,\n      min: minNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      getIntegerLimit,\n      maybeBigInt,\n      shouldCoerceToBigInt,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.number;\n  const node = resolver?.(ctx) ?? numberResolver(ctx);\n  ast.expression = node;\n  return ast as Omit<Ast, 'typeName'>;\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { ObjectResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nfunction additionalPropertiesNode(ctx: ObjectResolverContext): Chain | null | undefined {\n  const { plugin, schema } = ctx;\n\n  if (\n    !schema.additionalProperties ||\n    (schema.properties && Object.keys(schema.properties).length > 0)\n  )\n    return;\n\n  const additionalAst = irSchemaToAst({\n    plugin,\n    schema: schema.additionalProperties,\n    state: {\n      ...ctx.utils.state,\n      path: ref([...fromRef(ctx.utils.state.path), 'additionalProperties']),\n    },\n  });\n  if (additionalAst.hasLazyExpression) ctx.utils.ast.hasLazyExpression = true;\n  return additionalAst.expression;\n}\n\nfunction baseNode(ctx: ObjectResolverContext): Chain {\n  const { nodes, symbols } = ctx;\n  const { z } = symbols;\n\n  const additional = nodes.additionalProperties(ctx);\n  const shape = nodes.shape(ctx);\n\n  if (additional) {\n    return $(z).attr(identifiers.record).call($(z).attr(identifiers.string).call(), additional);\n  }\n\n  return $(z).attr(identifiers.object).call(shape);\n}\n\nfunction objectResolver(ctx: ObjectResolverContext): Chain {\n  // TODO: parser - handle constants\n  return ctx.nodes.base(ctx);\n}\n\nfunction shapeNode(ctx: ObjectResolverContext): ReturnType<typeof $.object> {\n  const { plugin, schema } = ctx;\n  const shape = $.object().pretty();\n\n  for (const name in schema.properties) {\n    const property = schema.properties[name]!;\n\n    const propertyAst = irSchemaToAst({\n      optional: !schema.required?.includes(name),\n      plugin,\n      schema: property,\n      state: {\n        ...ctx.utils.state,\n        path: ref([...fromRef(ctx.utils.state.path), 'properties', name]),\n      },\n    });\n    if (propertyAst.hasLazyExpression) {\n      ctx.utils.ast.hasLazyExpression = true;\n      shape.getter(name, propertyAst.expression.return());\n    } else {\n      shape.prop(name, propertyAst.expression);\n    }\n  }\n\n  return shape;\n}\n\nexport const objectToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'object'>;\n}): Omit<Ast, 'typeName'> => {\n  const ast: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  const ctx: ObjectResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      additionalProperties: additionalPropertiesNode,\n      base: baseNode,\n      shape: shapeNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n    utils: {\n      ast,\n      state,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.object;\n  const node = resolver?.(ctx) ?? objectResolver(ctx);\n  ast.expression = node;\n  return ast as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { StringResolverContext } from '../../resolvers';\nimport type { Chain } from '../../shared/chain';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nfunction baseNode(ctx: StringResolverContext): Chain {\n  const { z } = ctx.symbols;\n  return $(z).attr(identifiers.string).call();\n}\n\nfunction constNode(ctx: StringResolverContext): Chain | undefined {\n  const { schema, symbols } = ctx;\n  const { z } = symbols;\n  if (typeof schema.const !== 'string') return;\n  return $(z).attr(identifiers.literal).call($.literal(schema.const));\n}\n\nfunction formatNode(ctx: StringResolverContext): Chain | undefined {\n  const { plugin, schema, symbols } = ctx;\n  const { z } = symbols;\n\n  switch (schema.format) {\n    case 'date':\n      return $(z).attr(identifiers.iso).attr(identifiers.date).call();\n    case 'date-time': {\n      const obj = $.object()\n        .$if(plugin.config.dates.offset, (o) => o.prop('offset', $.literal(true)))\n        .$if(plugin.config.dates.local, (o) => o.prop('local', $.literal(true)));\n      return $(z)\n        .attr(identifiers.iso)\n        .attr(identifiers.datetime)\n        .call(obj.hasProps() ? obj : undefined);\n    }\n    case 'email':\n      return $(z).attr(identifiers.email).call();\n    case 'ipv4':\n      return $(z).attr(identifiers.ipv4).call();\n    case 'ipv6':\n      return $(z).attr(identifiers.ipv6).call();\n    case 'time':\n      return $(z).attr(identifiers.iso).attr(identifiers.time).call();\n    case 'uri':\n      return $(z).attr(identifiers.url).call();\n    case 'uuid':\n      return $(z).attr(identifiers.uuid).call();\n  }\n\n  return;\n}\n\nfunction lengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.minLength === undefined || schema.minLength !== schema.maxLength) return;\n  return chain.current.attr(identifiers.length).call($.literal(schema.minLength));\n}\n\nfunction maxLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.maxLength === undefined) return;\n  return chain.current.attr(identifiers.max).call($.literal(schema.maxLength));\n}\n\nfunction minLengthNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (schema.minLength === undefined) return;\n  return chain.current.attr(identifiers.min).call($.literal(schema.minLength));\n}\n\nfunction patternNode(ctx: StringResolverContext): Chain | undefined {\n  const { chain, schema } = ctx;\n  if (!schema.pattern) return;\n  return chain.current.attr(identifiers.regex).call($.regexp(schema.pattern));\n}\n\nfunction stringResolver(ctx: StringResolverContext): Chain {\n  const constNode = ctx.nodes.const(ctx);\n  if (constNode) {\n    ctx.chain.current = constNode;\n    return ctx.chain.current;\n  }\n\n  const baseNode = ctx.nodes.base(ctx);\n  if (baseNode) ctx.chain.current = baseNode;\n\n  const formatNode = ctx.nodes.format(ctx);\n  if (formatNode) ctx.chain.current = formatNode;\n\n  const lengthNode = ctx.nodes.length(ctx);\n  if (lengthNode) {\n    ctx.chain.current = lengthNode;\n  } else {\n    const minLengthNode = ctx.nodes.minLength(ctx);\n    if (minLengthNode) ctx.chain.current = minLengthNode;\n\n    const maxLengthNode = ctx.nodes.maxLength(ctx);\n    if (maxLengthNode) ctx.chain.current = maxLengthNode;\n  }\n\n  const patternNode = ctx.nodes.pattern(ctx);\n  if (patternNode) ctx.chain.current = patternNode;\n\n  return ctx.chain.current;\n}\n\nexport const stringToNode = ({\n  plugin,\n  schema,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'string'>;\n}): Omit<Ast, 'typeName'> => {\n  const z = plugin.external('zod.z');\n  const ctx: StringResolverContext = {\n    $,\n    chain: {\n      current: $(z),\n    },\n    nodes: {\n      base: baseNode,\n      const: constNode,\n      format: formatNode,\n      length: lengthNode,\n      maxLength: maxLengthNode,\n      minLength: minLengthNode,\n      pattern: patternNode,\n    },\n    plugin,\n    schema,\n    symbols: {\n      z,\n    },\n  };\n  const resolver = plugin.config['~resolvers']?.string;\n  const node = resolver?.(ctx) ?? stringResolver(ctx);\n  return {\n    expression: node,\n  };\n};\n","import { fromRef, ref } from '@hey-api/codegen-core';\nimport type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { irSchemaToAst } from '../plugin';\n\nexport const tupleToAst = ({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'tuple'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n\n  const z = plugin.external('zod.z');\n\n  if (schema.const && Array.isArray(schema.const)) {\n    const tupleElements = schema.const.map((value) =>\n      $(z).attr(identifiers.literal).call($.fromValue(value)),\n    );\n    result.expression = $(z)\n      .attr(identifiers.tuple)\n      .call($.array(...tupleElements));\n    return result as Omit<Ast, 'typeName'>;\n  }\n\n  const tupleElements: Array<ReturnType<typeof $.call | typeof $.expr>> = [];\n\n  if (schema.items) {\n    schema.items.forEach((item, index) => {\n      const itemSchema = irSchemaToAst({\n        plugin,\n        schema: item,\n        state: {\n          ...state,\n          path: ref([...fromRef(state.path), 'items', index]),\n        },\n      });\n      tupleElements.push(itemSchema.expression);\n      if (itemSchema.hasLazyExpression) {\n        result.hasLazyExpression = true;\n      }\n    });\n  }\n\n  result.expression = $(z)\n    .attr(identifiers.tuple)\n    .call($.array(...tupleElements));\n\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const undefinedToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'undefined'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  result.expression = $(z).attr(identifiers.undefined).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { $ } from '../../../../ts-dsl';\nimport { identifiers } from '../../constants';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\n\nexport const voidToAst = ({\n  plugin,\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType<'void'>;\n}): Omit<Ast, 'typeName'> => {\n  const result: Partial<Omit<Ast, 'typeName'>> = {};\n  const z = plugin.external('zod.z');\n  result.expression = $(z).attr(identifiers.void).call();\n  return result as Omit<Ast, 'typeName'>;\n};\n","import type { SchemaWithType } from '@hey-api/shared';\n\nimport { shouldCoerceToBigInt } from '../../../../plugins/shared/utils/coerce';\nimport type { Ast, IrSchemaToAstOptions } from '../../shared/types';\nimport { arrayToAst } from './array';\nimport { booleanToAst } from './boolean';\nimport { enumToAst } from './enum';\nimport { neverToAst } from './never';\nimport { nullToAst } from './null';\nimport { numberToNode } from './number';\nimport { objectToAst } from './object';\nimport { stringToNode } from './string';\nimport { tupleToAst } from './tuple';\nimport { undefinedToAst } from './undefined';\nimport { unknownToAst } from './unknown';\nimport { voidToAst } from './void';\n\nexport function irSchemaWithTypeToAst({\n  schema,\n  ...args\n}: IrSchemaToAstOptions & {\n  schema: SchemaWithType;\n}): Omit<Ast, 'typeName'> {\n  switch (schema.type) {\n    case 'array':\n      return arrayToAst({\n        ...args,\n        schema: schema as SchemaWithType<'array'>,\n      });\n    case 'boolean':\n      return booleanToAst({\n        ...args,\n        schema: schema as SchemaWithType<'boolean'>,\n      });\n    case 'enum':\n      return enumToAst({\n        ...args,\n        schema: schema as SchemaWithType<'enum'>,\n      });\n    case 'integer':\n    case 'number':\n      return numberToNode({\n        ...args,\n        schema: schema as SchemaWithType<'integer' | 'number'>,\n      });\n    case 'never':\n      return neverToAst({\n        ...args,\n        schema: schema as SchemaWithType<'never'>,\n      });\n    case 'null':\n      return nullToAst({\n        ...args,\n        schema: schema as SchemaWithType<'null'>,\n      });\n    case 'object':\n      return objectToAst({\n        ...args,\n        schema: schema as SchemaWithType<'object'>,\n      });\n    case 'string':\n      return shouldCoerceToBigInt(schema.format)\n        ? numberToNode({\n            ...args,\n            schema: { ...schema, type: 'number' },\n          })\n        : stringToNode({\n            ...args,\n            schema: schema as SchemaWithType<'string'>,\n          });\n    case 'tuple':\n      return tupleToAst({\n        ...args,\n        schema: schema as SchemaWithType<'tuple'>,\n      });\n    case 'undefined':\n      return undefinedToAst({\n        ...args,\n        schema: schema as SchemaWithType<'undefined'>,\n      });\n    case 'unknown':\n      return unknownToAst({\n        ...args,\n        schema: schema as SchemaWithType<'unknown'>,\n      });\n    case 'void':\n      return voidToAst({\n        ...args,\n        schema: schema as SchemaWithType<'void'>,\n      });\n  }\n}\n","import type { SymbolMeta } from '@hey-api/codegen-core';\nimport { fromRef, ref, refs } from '@hey-api/codegen-core';\nimport type { IR, SchemaWithType } from '@hey-api/shared';\nimport { applyNaming, deduplicateSchema, pathToJsonPointer, refToName } from '@hey-api/shared';\n\nimport { maybeBigInt } from '../../../plugins/shared/utils/coerce';\nimport { $ } from '../../../ts-dsl';\nimport { identifiers } from '../constants';\nimport { exportAst } from '../shared/export';\nimport { getZodModule } from '../shared/module';\nimport { irOperationToAst } from '../shared/operation';\nimport type { Ast, IrSchemaToAstOptions, PluginState } from '../shared/types';\nimport { irWebhookToAst } from '../shared/webhook';\nimport type { ZodPlugin } from '../types';\nimport { irSchemaWithTypeToAst } from './toAst';\n\nexport function irSchemaToAst({\n  optional,\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  /**\n   * Accept `optional` to handle optional object properties. We can't handle\n   * this inside the object function because `.optional()` must come before\n   * `.default()` which is handled in this function.\n   */\n  optional?: boolean;\n  schema: IR.SchemaObject;\n}): Ast {\n  let ast: Partial<Ast> = {};\n\n  const z = plugin.external('zod.z');\n\n  if (schema.$ref) {\n    const query: SymbolMeta = {\n      category: 'schema',\n      resource: 'definition',\n      resourceId: schema.$ref,\n      tool: 'zod',\n    };\n    const refSymbol = plugin.referenceSymbol(query);\n    if (plugin.isSymbolRegistered(query)) {\n      ast.expression = $(refSymbol);\n    } else {\n      ast.expression = $(z)\n        .attr(identifiers.lazy)\n        .call($.func().returns('any').do($(refSymbol).return()));\n      ast.hasLazyExpression = true;\n      state.hasLazyExpression['~ref'] = true;\n    }\n  } else if (schema.type) {\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: schema as SchemaWithType,\n      state,\n    });\n    ast.expression = typeAst.expression;\n    ast.hasLazyExpression = typeAst.hasLazyExpression;\n\n    if (plugin.config.metadata && schema.description) {\n      ast.expression = ast.expression\n        .attr(identifiers.register)\n        .call(\n          $(z).attr(identifiers.globalRegistry),\n          $.object().pretty().prop('description', $.literal(schema.description)),\n        );\n    }\n  } else if (schema.items) {\n    schema = deduplicateSchema({ schema });\n\n    if (schema.items) {\n      const itemSchemas = schema.items.map((item, index) =>\n        irSchemaToAst({\n          plugin,\n          schema: item,\n          state: {\n            ...state,\n            path: ref([...fromRef(state.path), 'items', index]),\n          },\n        }),\n      );\n\n      if (schema.logicalOperator === 'and') {\n        const firstSchema = schema.items[0]!;\n        // we want to add an intersection, but not every schema can use the same API.\n        // if the first item contains another array or not an object, we cannot use\n        // `.merge()` as that does not exist on `.union()` and non-object schemas.\n        if (\n          firstSchema.logicalOperator === 'or' ||\n          (firstSchema.type && firstSchema.type !== 'object')\n        ) {\n          ast.expression = $(z)\n            .attr(identifiers.intersection)\n            .call(...itemSchemas.map((schema) => schema.expression));\n        } else {\n          ast.expression = itemSchemas[0]!.expression;\n          itemSchemas.slice(1).forEach((schema) => {\n            ast.expression = ast\n              .expression!.attr(identifiers.and)\n              .call(\n                schema.hasLazyExpression\n                  ? $(z).attr(identifiers.lazy).call($.func().do(schema.expression.return()))\n                  : schema.expression,\n              );\n          });\n        }\n      } else {\n        ast.expression = $(z)\n          .attr(identifiers.union)\n          .call(\n            $.array()\n              .pretty()\n              .elements(...itemSchemas.map((schema) => schema.expression)),\n          );\n      }\n    } else {\n      ast = irSchemaToAst({\n        plugin,\n        schema,\n        state,\n      });\n    }\n  } else {\n    // catch-all fallback for failed schemas\n    const typeAst = irSchemaWithTypeToAst({\n      plugin,\n      schema: {\n        type: 'unknown',\n      },\n      state,\n    });\n    ast.expression = typeAst.expression;\n  }\n\n  if (ast.expression) {\n    if (schema.accessScope === 'read') {\n      ast.expression = ast.expression.attr(identifiers.readonly).call();\n    }\n\n    if (optional) {\n      ast.expression = $(z).attr(identifiers.optional).call(ast.expression);\n      ast.typeName = identifiers.ZodOptional;\n    }\n\n    if (schema.default !== undefined) {\n      ast.expression = ast.expression\n        .attr(identifiers.default)\n        .call(\n          schema.type === 'integer' || schema.type === 'number'\n            ? maybeBigInt(schema.default, schema.format)\n            : $.fromValue(schema.default),\n        );\n    }\n  }\n\n  return ast as Ast;\n}\n\nfunction handleComponent({\n  plugin,\n  schema,\n  state,\n}: IrSchemaToAstOptions & {\n  schema: IR.SchemaObject;\n}): void {\n  const $ref = pathToJsonPointer(fromRef(state.path));\n  const ast = irSchemaToAst({ plugin, schema, state });\n  const baseName = refToName($ref);\n  const symbol = plugin.symbol(applyNaming(baseName, plugin.config.definitions), {\n    meta: {\n      category: 'schema',\n      path: fromRef(state.path),\n      resource: 'definition',\n      resourceId: $ref,\n      tags: fromRef(state.tags),\n      tool: 'zod',\n    },\n  });\n  const typeInferSymbol = plugin.config.definitions.types.infer.enabled\n    ? plugin.symbol(applyNaming(baseName, plugin.config.definitions.types.infer), {\n        meta: {\n          category: 'type',\n          path: fromRef(state.path),\n          resource: 'definition',\n          resourceId: $ref,\n          tags: fromRef(state.tags),\n          tool: 'zod',\n          variant: 'infer',\n        },\n      })\n    : undefined;\n  exportAst({\n    ast,\n    plugin,\n    schema,\n    symbol,\n    typeInferSymbol,\n  });\n}\n\nexport const handlerV4: ZodPlugin['Handler'] = ({ plugin }) => {\n  plugin.symbol('z', {\n    external: getZodModule({ plugin }),\n    importKind: 'namespace',\n    meta: {\n      category: 'external',\n      resource: 'zod.z',\n    },\n  });\n\n  plugin.forEach('operation', 'parameter', 'requestBody', 'schema', 'webhook', (event) => {\n    const state = refs<PluginState>({\n      hasLazyExpression: false,\n      path: event._path,\n      tags: event.tags,\n    });\n    switch (event.type) {\n      case 'operation':\n        irOperationToAst({\n          getAst: (schema, path) => {\n            const state = refs<PluginState>({\n              hasLazyExpression: false,\n              path,\n              tags: event.tags,\n            });\n            return irSchemaToAst({ plugin, schema, state });\n          },\n          operation: event.operation,\n          plugin,\n          state,\n        });\n        break;\n      case 'parameter':\n        handleComponent({\n          plugin,\n          schema: event.parameter.schema,\n          state,\n        });\n        break;\n      case 'requestBody':\n        handleComponent({\n          plugin,\n          schema: event.requestBody.schema,\n          state,\n        });\n        break;\n      case 'schema':\n        handleComponent({\n          plugin,\n          schema: event.schema,\n          state,\n        });\n        break;\n      case 'webhook':\n        irWebhookToAst({\n          getAst: (schema, path) => {\n            const state = refs<PluginState>({\n              hasLazyExpression: false,\n              path,\n              tags: event.tags,\n            });\n            return irSchemaToAst({ plugin, schema, state });\n          },\n          operation: event.operation,\n          plugin,\n          state,\n        });\n        break;\n    }\n  });\n};\n","import { handlerMini } from './mini/plugin';\nimport type { ZodPlugin } from './types';\nimport { handlerV3 } from './v3/plugin';\nimport { handlerV4 } from './v4/plugin';\n\nexport const handler: ZodPlugin['Handler'] = (args) => {\n  const { plugin } = args;\n  switch (plugin.config.compatibilityVersion) {\n    case 3:\n      return handlerV3(args);\n    case 'mini':\n      return handlerMini(args);\n    case 4:\n    default:\n      return handlerV4(args);\n  }\n};\n","import { definePluginConfig, mappers } from '@hey-api/shared';\nimport colors from 'ansi-colors';\n\nimport { Api } from './api';\nimport { handler } from './plugin';\nimport type { ZodPlugin } from './types';\n\ntype CompatibilityVersion = NonNullable<ZodPlugin['Config']['config']['compatibilityVersion']>;\n\nexport const defaultConfig: ZodPlugin['Config'] = {\n  api: new Api(),\n  config: {\n    case: 'camelCase',\n    comments: true,\n    includeInEntry: false,\n    metadata: false,\n  },\n  handler,\n  name: 'zod',\n  resolveConfig: (plugin, context) => {\n    const packageName = 'zod';\n    const version = context.package.getVersion(packageName);\n\n    const inferCompatibleVersion = (): CompatibilityVersion => {\n      if (version && (version.major === 4 || version.major === 3)) {\n        return version.major;\n      }\n\n      // default compatibility version\n      return 4;\n    };\n\n    const ensureCompatibleVersion = (\n      compatibilityVersion: CompatibilityVersion | undefined,\n    ): CompatibilityVersion => {\n      if (!compatibilityVersion) {\n        return inferCompatibleVersion();\n      }\n\n      if (!version) {\n        return compatibilityVersion;\n      }\n\n      if (\n        compatibilityVersion === 4 ||\n        compatibilityVersion === 3 ||\n        compatibilityVersion === 'mini'\n      ) {\n        if (!context.package.satisfies(version, '>=3.25.0 <5.0.0')) {\n          const compatibleVersion = inferCompatibleVersion();\n          console.warn(\n            `🔌 ${colors.yellow('Warning:')} Installed ${colors.cyan(packageName)} ${colors.cyan(`v${version.version}`)} does not support compatibility version ${colors.yellow(String(compatibilityVersion))}, using ${colors.yellow(String(compatibleVersion))}.`,\n          );\n          return compatibleVersion;\n        }\n      }\n\n      return compatibilityVersion;\n    };\n\n    plugin.config.compatibilityVersion = ensureCompatibleVersion(\n      plugin.config.compatibilityVersion,\n    );\n\n    plugin.config.dates = context.valueToObject({\n      defaultValue: {\n        local: false,\n        offset: false,\n      },\n      value: plugin.config.dates,\n    });\n\n    plugin.config.types = context.valueToObject({\n      defaultValue: {\n        infer: {\n          case: 'PascalCase',\n          enabled: false,\n        },\n      },\n      mappers: {\n        object: (fields, defaultValue) => ({\n          ...fields,\n          infer: context.valueToObject({\n            defaultValue: {\n              ...(defaultValue.infer as Extract<\n                typeof defaultValue.infer,\n                Record<string, unknown>\n              >),\n              enabled:\n                fields.infer !== undefined\n                  ? Boolean(fields.infer)\n                  : (\n                      defaultValue.infer as Extract<\n                        typeof defaultValue.infer,\n                        Record<string, unknown>\n                      >\n                    ).enabled,\n            },\n            mappers,\n            value: fields.infer,\n          }),\n        }),\n      },\n      value: plugin.config.types,\n    });\n\n    plugin.config.definitions = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}ZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.definitions,\n    });\n\n    plugin.config.requests = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}Data',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}DataZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.requests,\n    });\n\n    plugin.config.responses = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}Response',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}ResponseZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.responses,\n    });\n\n    plugin.config.webhooks = context.valueToObject({\n      defaultValue: {\n        case: plugin.config.case ?? 'camelCase',\n        enabled: true,\n        name: 'z{{name}}WebhookRequest',\n        types: {\n          ...plugin.config.types,\n          infer: {\n            ...(plugin.config.types.infer as Extract<\n              typeof plugin.config.types.infer,\n              Record<string, unknown>\n            >),\n            name: '{{name}}WebhookRequestZodType',\n          },\n        },\n      },\n      mappers: {\n        ...mappers,\n        object: (fields, defaultValue) => ({\n          ...fields,\n          types: context.valueToObject({\n            defaultValue: defaultValue.types!,\n            mappers: {\n              object: (fields, defaultValue) => ({\n                ...fields,\n                infer: context.valueToObject({\n                  defaultValue: {\n                    ...(defaultValue.infer as Extract<\n                      typeof defaultValue.infer,\n                      Record<string, unknown>\n                    >),\n                    enabled:\n                      fields.infer !== undefined\n                        ? Boolean(fields.infer)\n                        : (\n                            defaultValue.infer as Extract<\n                              typeof defaultValue.infer,\n                              Record<string, unknown>\n                            >\n                          ).enabled,\n                  },\n                  mappers,\n                  value: fields.infer,\n                }),\n              }),\n            },\n            value: fields.types,\n          }),\n        }),\n      },\n      value: plugin.config.webhooks,\n    });\n  },\n  tags: ['validator'],\n};\n\n/**\n * Type helper for Zod plugin, returns {@link Plugin.Config} object\n */\nexport const defineConfig = definePluginConfig(defaultConfig);\n","import type { Plugin, PluginConfigMap, PluginNames } from '@hey-api/shared';\n\nimport { defaultConfig as angularCommon } from '../plugins/@angular/common';\nimport { defaultConfig as fakerJsFaker } from '../plugins/@faker-js/faker';\nimport { defaultConfig as heyApiClientAngular } from '../plugins/@hey-api/client-angular';\nimport { defaultConfig as heyApiClientAxios } from '../plugins/@hey-api/client-axios';\nimport { defaultConfig as heyApiClientFetch } from '../plugins/@hey-api/client-fetch';\nimport { defaultConfig as heyApiClientKy } from '../plugins/@hey-api/client-ky';\nimport { defaultConfig as heyApiClientNext } from '../plugins/@hey-api/client-next';\nimport { defaultConfig as heyApiClientNuxt } from '../plugins/@hey-api/client-nuxt';\nimport { defaultConfig as heyApiClientOfetch } from '../plugins/@hey-api/client-ofetch';\nimport { defaultConfig as heyApiSchemas } from '../plugins/@hey-api/schemas';\nimport { defaultConfig as heyApiSdk } from '../plugins/@hey-api/sdk';\nimport { defaultConfig as heyApiTransformers } from '../plugins/@hey-api/transformers';\nimport { defaultConfig as heyApiTypeScript } from '../plugins/@hey-api/typescript';\nimport { defaultConfig as piniaColada } from '../plugins/@pinia/colada';\nimport { defaultConfig as tanStackAngularQuery } from '../plugins/@tanstack/angular-query-experimental';\nimport { defaultConfig as tanStackReactQuery } from '../plugins/@tanstack/react-query';\nimport { defaultConfig as tanStackSolidQuery } from '../plugins/@tanstack/solid-query';\nimport { defaultConfig as tanStackSvelteQuery } from '../plugins/@tanstack/svelte-query';\nimport { defaultConfig as tanStackVueQuery } from '../plugins/@tanstack/vue-query';\nimport { defaultConfig as arktype } from '../plugins/arktype';\nimport { defaultConfig as fastify } from '../plugins/fastify';\nimport { defaultConfig as swr } from '../plugins/swr';\nimport { defaultConfig as valibot } from '../plugins/valibot';\nimport { defaultConfig as zod } from '../plugins/zod';\n\nexport const defaultPluginConfigs: {\n  [K in PluginNames]: Plugin.Config<PluginConfigMap[K]>;\n} = {\n  '@angular/common': angularCommon,\n  '@faker-js/faker': fakerJsFaker,\n  '@hey-api/client-angular': heyApiClientAngular,\n  '@hey-api/client-axios': heyApiClientAxios,\n  '@hey-api/client-fetch': heyApiClientFetch,\n  '@hey-api/client-ky': heyApiClientKy,\n  '@hey-api/client-next': heyApiClientNext,\n  '@hey-api/client-nuxt': heyApiClientNuxt,\n  '@hey-api/client-ofetch': heyApiClientOfetch,\n  '@hey-api/schemas': heyApiSchemas,\n  '@hey-api/sdk': heyApiSdk,\n  '@hey-api/transformers': heyApiTransformers,\n  '@hey-api/typescript': heyApiTypeScript,\n  '@pinia/colada': piniaColada,\n  '@tanstack/angular-query-experimental': tanStackAngularQuery,\n  '@tanstack/react-query': tanStackReactQuery,\n  '@tanstack/solid-query': tanStackSolidQuery,\n  '@tanstack/svelte-query': tanStackSvelteQuery,\n  '@tanstack/vue-query': tanStackVueQuery,\n  arktype,\n  fastify,\n  swr,\n  valibot,\n  zod,\n};\n","import type { AnyPluginName, PluginContext, PluginNames } from '@hey-api/shared';\nimport { dependencyFactory, valueToObject } from '@hey-api/shared';\n\nimport { defaultPluginConfigs } from '../plugins/config';\nimport type { Config, UserConfig } from './types';\n\n/**\n * Default plugins used to generate artifacts if plugins aren't specified.\n */\nexport const defaultPlugins = [\n  '@hey-api/typescript',\n  '@hey-api/sdk',\n] as const satisfies ReadonlyArray<PluginNames>;\n\nfunction getPluginsConfig({\n  dependencies,\n  userPlugins,\n  userPluginsConfig,\n}: {\n  dependencies: Record<string, string>;\n  userPlugins: ReadonlyArray<AnyPluginName>;\n  userPluginsConfig: Config['plugins'];\n}): Pick<Config, 'plugins' | 'pluginOrder'> {\n  const circularReferenceTracker = new Set<AnyPluginName>();\n  const pluginOrder = new Set<AnyPluginName>();\n  const plugins: Config['plugins'] = {};\n\n  const dfs = (name: AnyPluginName) => {\n    if (circularReferenceTracker.has(name)) {\n      throw new Error(`Circular reference detected at '${name}'`);\n    }\n\n    if (pluginOrder.has(name)) {\n      return;\n    }\n\n    circularReferenceTracker.add(name);\n\n    const defaultPlugin = defaultPluginConfigs[name as PluginNames];\n    const userPlugin = userPluginsConfig[name as PluginNames];\n\n    if (!defaultPlugin && !userPlugin) {\n      throw new Error(\n        `unknown plugin dependency \"${name}\" - do you need to register a custom plugin with this name?`,\n      );\n    }\n\n    const plugin = {\n      ...defaultPlugin,\n      ...userPlugin,\n      config: {\n        ...defaultPlugin?.config,\n        ...userPlugin?.config,\n      },\n      dependencies: new Set([\n        ...(defaultPlugin?.dependencies || []),\n        ...(userPlugin?.dependencies || []),\n      ]),\n    };\n\n    if (plugin.resolveConfig) {\n      const context: PluginContext = {\n        package: dependencyFactory(dependencies),\n        pluginByTag: (tag, props = {}) => {\n          const { defaultPlugin, errorMessage } = props;\n\n          for (const userPlugin of userPlugins) {\n            const defaultConfig =\n              defaultPluginConfigs[userPlugin as PluginNames] ||\n              userPluginsConfig[userPlugin as PluginNames];\n            if (defaultConfig && defaultConfig.tags?.includes(tag) && userPlugin !== name) {\n              return userPlugin as any;\n            }\n          }\n\n          if (defaultPlugin) {\n            const defaultConfig =\n              defaultPluginConfigs[defaultPlugin as PluginNames] ||\n              userPluginsConfig[defaultPlugin as PluginNames];\n            if (defaultConfig && defaultConfig.tags?.includes(tag) && defaultPlugin !== name) {\n              return defaultPlugin;\n            }\n          }\n\n          throw new Error(errorMessage || `missing plugin - no plugin with tag \"${tag}\" found`);\n        },\n        valueToObject,\n      };\n      // @ts-expect-error\n      plugin.resolveConfig(plugin, context);\n    }\n\n    for (const dependency of plugin.dependencies) {\n      dfs(dependency);\n    }\n\n    circularReferenceTracker.delete(name);\n    pluginOrder.add(name);\n\n    // @ts-expect-error\n    plugins[name] = plugin;\n  };\n\n  for (const name of userPlugins) {\n    dfs(name);\n  }\n\n  return {\n    pluginOrder: Array.from(pluginOrder) as ReadonlyArray<PluginNames>,\n    plugins,\n  };\n}\n\nfunction isPluginClient(plugin: Required<UserConfig>['plugins'][number]): boolean {\n  if (typeof plugin === 'string') {\n    return plugin.startsWith('@hey-api/client');\n  }\n\n  return (\n    plugin.name.startsWith('@hey-api/client') ||\n    // @ts-expect-error\n    (plugin.tags && plugin.tags.includes('client'))\n  );\n}\n\nexport function getPlugins({\n  dependencies,\n  userConfig,\n}: {\n  dependencies: Record<string, string>;\n  userConfig: UserConfig;\n}): Pick<Config, 'plugins' | 'pluginOrder'> {\n  const userPluginsConfig: Config['plugins'] = {};\n\n  let definedPlugins: UserConfig['plugins'] = defaultPlugins;\n\n  if (userConfig.plugins) {\n    userConfig.plugins = userConfig.plugins.filter(\n      (plugin) =>\n        (typeof plugin === 'string' && plugin) || (typeof plugin !== 'string' && plugin.name),\n    );\n    if (userConfig.plugins.length === 1 && isPluginClient(userConfig.plugins[0]!)) {\n      definedPlugins = [...defaultPlugins, ...userConfig.plugins];\n    } else {\n      definedPlugins = userConfig.plugins;\n    }\n  }\n\n  const userPlugins = definedPlugins\n    .map((plugin) => {\n      if (typeof plugin === 'string') {\n        return plugin;\n      }\n\n      const pluginName = plugin.name;\n\n      if (pluginName) {\n        // @ts-expect-error\n        if (plugin.handler) {\n          // @ts-expect-error\n          userPluginsConfig[pluginName] = plugin;\n        } else {\n          // @ts-expect-error\n          userPluginsConfig[pluginName] = {\n            config: { ...plugin },\n          };\n          // @ts-expect-error\n          delete userPluginsConfig[pluginName]!.config.name;\n        }\n      }\n\n      return pluginName;\n    })\n    .filter(Boolean);\n\n  return getPluginsConfig({ dependencies, userPlugins, userPluginsConfig });\n}\n","import path from 'node:path';\n\nimport { detectInteractiveSession } from '@hey-api/codegen-core';\nimport { ConfigError, getInput, getLogs, getParser } from '@hey-api/shared';\nimport colors from 'ansi-colors';\n\nimport { getOutput } from './output/config';\nimport { getPlugins } from './plugins';\nimport type { Config } from './types';\nimport type { ValidationResult } from './validate';\n\nexport type ResolvedJob = {\n  config: Config;\n  errors: Array<Error>;\n  index: number;\n};\n\nexport function resolveConfig(\n  validated: ValidationResult,\n  dependencies: Record<string, string>,\n): ResolvedJob {\n  const logs = getLogs(validated.job.config.logs);\n  const input = getInput(validated.job.config);\n  const output = getOutput(validated.job.config);\n  const parser = getParser(validated.job.config);\n\n  output.path = path.resolve(process.cwd(), output.path);\n\n  let plugins: Pick<Config, 'plugins' | 'pluginOrder'>;\n\n  try {\n    plugins = getPlugins({ dependencies, userConfig: validated.job.config });\n  } catch (error) {\n    if (error instanceof ConfigError) {\n      validated.errors.push(error);\n    }\n    plugins = {\n      pluginOrder: [],\n      plugins: {},\n    };\n  }\n\n  const config: Config = {\n    configFile: validated.job.config.configFile ?? '',\n    dryRun: validated.job.config.dryRun ?? false,\n    input,\n    interactive: validated.job.config.interactive ?? detectInteractiveSession(),\n    logs,\n    output,\n    parser,\n    pluginOrder: plugins.pluginOrder,\n    plugins: plugins.plugins,\n  };\n\n  if (logs.level === 'debug') {\n    const jobPrefix = colors.gray(`[Job ${validated.job.index}] `);\n    console.warn(`${jobPrefix}${colors.cyan('config:')}`, config);\n  }\n\n  return {\n    config,\n    errors: validated.errors,\n    index: validated.job.index,\n  };\n}\n","import { ConfigError, getInput } from '@hey-api/shared';\n\nimport type { Job } from './expand';\nimport { getOutput } from './output/config';\n\nexport type ValidationResult = {\n  errors: Array<ConfigError>;\n  job: Job;\n};\n\nexport function validateJobs(jobs: ReadonlyArray<Job>): ReadonlyArray<ValidationResult> {\n  return jobs.map((job) => {\n    const errors: Array<ConfigError> = [];\n    const { config } = job;\n\n    const inputs = getInput(config);\n    if (!inputs.length) {\n      errors.push(\n        new ConfigError(\n          'missing input - which OpenAPI specification should we use to generate your output?',\n        ),\n      );\n    }\n\n    const output = getOutput(config);\n    if (!output.path) {\n      errors.push(new ConfigError('missing output - where should we generate your output?'));\n    }\n\n    return { errors, job };\n  });\n}\n","import type { Logger } from '@hey-api/codegen-core';\nimport { loadConfigFile } from '@hey-api/codegen-core';\n\nimport { expandToJobs } from './expand';\nimport { getProjectDependencies } from './packages';\nimport type { ResolvedJob } from './resolve';\nimport { resolveConfig } from './resolve';\nimport type { UserConfig } from './types';\nimport { validateJobs } from './validate';\n\nexport type Configs = {\n  dependencies: Record<string, string>;\n  jobs: ReadonlyArray<ResolvedJob>;\n  /**\n   * @deprecated Use `jobs` instead.\n   */\n  results: ReadonlyArray<ResolvedJob>;\n};\n\n/**\n * @internal\n */\nexport async function resolveJobs({\n  logger,\n  userConfigs,\n}: {\n  logger: Logger;\n  userConfigs: ReadonlyArray<UserConfig>;\n}): Promise<Configs> {\n  const configs: Array<UserConfig> = [];\n  let dependencies: Record<string, string> = {};\n\n  const eventLoad = logger.timeEvent('load');\n  for (const userConfig of userConfigs) {\n    let configFile: string | undefined;\n    if (userConfig.configFile) {\n      const parts = userConfig.configFile.split('.');\n      configFile = parts.slice(0, parts.length - 1).join('.');\n    }\n\n    const loaded = await loadConfigFile<UserConfig>({\n      configFile,\n      logger,\n      name: 'openapi-ts',\n      userConfig,\n    });\n\n    if (!Object.keys(dependencies).length) {\n      // TODO: handle dependencies for multiple configs properly?\n      dependencies = getProjectDependencies(loaded.foundConfig ? loaded.configFile : undefined);\n    }\n\n    configs.push(...loaded.configs);\n  }\n  eventLoad.timeEnd();\n\n  const eventBuild = logger.timeEvent('build');\n  const jobs = validateJobs(expandToJobs(configs));\n  const resolvedJobs = jobs.map((validated) => resolveConfig(validated, dependencies));\n  eventBuild.timeEnd();\n\n  return {\n    dependencies,\n    jobs: resolvedJobs,\n    results: resolvedJobs,\n  };\n}\n"],"mappings":"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"}